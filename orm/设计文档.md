# 轻量级ORM框架设计文档

## 1. 概述

### 1.1 设计目标

本设计旨在实现一个轻量级、高性能的ORM框架，具有以下特性：

- **规范性**：遵循JDBC标准和ORM设计模式
- **通用性**：支持多种关系型数据库
- **专业性**：提供完整的ORM功能实现
- **灵活性**：支持注解和编程式配置
- **可靠性**：具备完善的错误处理机制
- **安全性**：内置SQL注入防护机制
- **可复用性**：模块化设计，组件可独立使用
- **容错性**：具备优雅的错误恢复能力

### 1.2 核心原则

1. **轻量级设计**：最小化依赖，仅依赖JDBC和必要的工具类
2. **高性能**：优化SQL生成和执行过程
3. **易用性**：提供简洁的API接口
4. **无侵入性**：实体类不需要继承特定基类
5. **类型安全**：编译时检查，减少运行时错误

## 2. 架构设计

### 2.1 整体架构

```
LightweightORM
├── core (核心模块)
│   ├── Session (会话管理)
│   ├── EntityManager (实体管理)
│   └── TransactionManager (事务管理)
├── mapping (映射模块)
│   ├── AnnotationProcessor (注解处理器)
│   ├── EntityMetadata (实体元数据)
│   └── TableMapper (表映射器)
├── query (查询模块)
│   ├── QueryBuilder (查询构建器)
│   ├── Criteria (条件构造器)
│   └── SQLGenerator (SQL生成器)
├── persistence (持久化模块)
│   ├── Persister (持久化器)
│   ├── Loader (加载器)
│   └── Executor (执行器)
├── datasource (数据源模块)
│   ├── DataSourceManager (数据源管理器)
│   ├── ConnectionProvider (连接提供者接口)
│   └── HikariConnectionProvider (HikariCP实现)
└── util (工具模块)
    ├── ResultSetMapper (结果集映射)
    └── SQLUtils (SQL工具类)
```

### 2.2 核心组件

#### 2.2.1 Session

会话接口，负责与数据库的交互，是ORM框架的核心入口。

#### 2.2.2 EntityManager

实体管理器，负责实体的CRUD操作。

#### 2.2.3 TransactionManager

事务管理器，负责事务的开启、提交和回滚。

#### 2.2.4 QueryBuilder

查询构建器，提供链式API构建查询语句。

#### 2.2.5 AnnotationProcessor

注解处理器，处理实体类上的ORM注解。

#### 2.2.6 DataSourceManager

数据源管理器，负责多数据源的注册、获取和管理。

## 3. 详细设计

### 3.1 核心类设计

#### 3.1.1 Session接口

```java
public interface Session {
    <T> T findById(Class<T> entityClass, Object id);
    <T> List<T> findAll(Class<T> entityClass);
    void save(Object entity);
    void update(Object entity);
    void delete(Object entity);
    <T> Query<T> createQuery(Class<T> resultClass);
    void beginTransaction();
    void commit();
    void rollback();
    void close();
}
```

#### 3.1.2 MultiDataSourceSession接口

```java
public interface MultiDataSourceSession extends Session {
    void switchDataSource(String dataSourceName);
    String getCurrentDataSourceName();
}
```

#### 3.1.3 EntityManager类

```java
public class EntityManager {
    public <T> T findById(Class<T> entityClass, Object id);
    public <T> List<T> findAll(Class<T> entityClass);
    public void save(Object entity);
    public void update(Object entity);
    public void delete(Object entity);
    public <T> Query<T> createQuery(Class<T> resultClass);
}
```

#### 3.1.4 Query接口

```java
public interface Query<T> {
    Query<T> where(String condition, Object... params);
    Query<T> orderBy(String orderBy);
    Query<T> limit(int limit);
    Query<T> offset(int offset);
    List<T> list();
    T single();
    int executeUpdate();
}
```

### 3.2 注解设计

#### 3.2.1 @Entity注解

标记一个类为实体类：

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Entity {
    String table() default "";
    String schema() default "";
}
```

#### 3.2.2 @Id注解

标记主键字段：

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Id {
    boolean autoGenerate() default false;
}
```

#### 3.2.3 @Column注解

标记普通字段：

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Column {
    String name() default "";
    boolean nullable() default true;
    int length() default 255;
}
```

### 3.3 映射机制

#### 3.3.1 元数据管理

实体元数据通过注解处理器在运行时解析并缓存：

```java
public class EntityMetadata {
    private Class<?> entityClass;
    private String tableName;
    private Field idField;
    private Map<String, Field> columnFields;
    private Map<String, String> fieldColumnMapping;
    // getters and setters
}
```

#### 3.3.2 映射解析器

```java
public class AnnotationProcessor {
    public static EntityMetadata processEntity(Class<?> entityClass) {
        // 解析实体类注解
        // 解析字段注解
        // 构建元数据对象
    }
}
```

## 4. 查询构建器设计

### 4.1 Criteria API

提供类型安全的查询构建方式：

```java
public class Criteria {
    public static <T> Query<T> select(Class<T> entityClass) {
        // 创建查询对象
    }
    
    public static Condition eq(String field, Object value) {
        // 等于条件
    }
    
    public static Condition like(String field, String pattern) {
        // 模糊匹配条件
    }
    
    public static Condition gt(String field, Object value) {
        // 大于条件
    }
    
    // 其他条件方法
}
```

### 4.2 查询执行流程

1. 解析查询条件
2. 生成SQL语句
3. 执行SQL并获取结果集
4. 将结果集映射为实体对象

## 5. 事务管理

### 5.1 事务隔离级别

```java
public enum IsolationLevel {
    READ_UNCOMMITTED,
    READ_COMMITTED,
    REPEATABLE_READ,
    SERIALIZABLE
}
```

### 5.2 事务管理器

```java
public class TransactionManager {
    public void beginTransaction(IsolationLevel level);
    public void commit();
    public void rollback();
    public boolean isActive();
}
```

## 6. 数据源管理

### 6.1 连接提供者接口

```java
public interface ConnectionProvider {
    Connection getConnection() throws SQLException;

    void releaseConnection(Connection connection);

    void close();
}
```

### 6.2 HikariCP连接提供者

```java
public class HikariConnectionProvider implements ConnectionProvider {
    private HikariDataSource dataSource;

    public HikariConnectionProvider(HikariConfig config) {
        this.dataSource = new HikariDataSource(config);
    }

    @Override
    public Connection getConnection() throws SQLException {
        return dataSource.getConnection();
    }

    @Override
    public void releaseConnection(Connection connection) {
        if (connection != null) {
            try {
                connection.close();
            } catch (SQLException e) {
                // 记录日志
            }
        }
    }

    @Override
    public void close() {
        if (dataSource != null) {
            dataSource.close();
        }
    }

    public HikariDataSource getDataSource() {
        return dataSource;
    }
}
```

### 6.3 数据源管理器

```java
public class DataSourceManager {
    private static final Map<String, ConnectionProvider> dataSourceMap = new ConcurrentHashMap<>();
    
    public static void registerDataSource(String name, ConnectionProvider provider) {
        dataSourceMap.put(name, provider);
    }
    
    public static ConnectionProvider getDataSource(String name) {
        return dataSourceMap.get(name);
    }
    
    public static Set<String> getDataSourceNames() {
        return dataSourceMap.keySet();
    }
    
    public static void unregisterDataSource(String name) {
        ConnectionProvider provider = dataSourceMap.remove(name);
        if (provider != null) {
            provider.close();
        }
    }
    
    public static void closeAll() {
        for (ConnectionProvider provider : dataSourceMap.values()) {
            provider.close();
        }
        dataSourceMap.clear();
    }
}
```

### 6.4 多数据源会话实现

```java
public class MultiDataSourceSessionImpl implements MultiDataSourceSession {
    private String currentDataSourceName;
    private Map<String, Session> sessions = new HashMap<>();
    
    public MultiDataSourceSessionImpl(String defaultDataSourceName) {
        this.currentDataSourceName = defaultDataSourceName;
    }
    
    @Override
    public void switchDataSource(String dataSourceName) {
        if (!DataSourceManager.getDataSourceNames().contains(dataSourceName)) {
            throw new ORMException("DataSource not found: " + dataSourceName);
        }
        this.currentDataSourceName = dataSourceName;
    }
    
    @Override
    public String getCurrentDataSourceName() {
        return currentDataSourceName;
    }
    
    private Session getCurrentSession() {
        Session session = sessions.get(currentDataSourceName);
        if (session == null) {
            ConnectionProvider provider = DataSourceManager.getDataSource(currentDataSourceName);
            session = new SessionImpl(provider); // 假设存在Session实现
            sessions.put(currentDataSourceName, session);
        }
        return session;
    }
    
    @Override
    public <T> T findById(Class<T> entityClass, Object id) {
        return getCurrentSession().findById(entityClass, id);
    }
    
    @Override
    public <T> List<T> findAll(Class<T> entityClass) {
        return getCurrentSession().findAll(entityClass);
    }
    
    @Override
    public void save(Object entity) {
        getCurrentSession().save(entity);
    }
    
    @Override
    public void update(Object entity) {
        getCurrentSession().update(entity);
    }
    
    @Override
    public void delete(Object entity) {
        getCurrentSession().delete(entity);
    }
    
    @Override
    public <T> Query<T> createQuery(Class<T> resultClass) {
        return getCurrentSession().createQuery(resultClass);
    }
    
    @Override
    public void beginTransaction() {
        getCurrentSession().beginTransaction();
    }
    
    @Override
    public void commit() {
        getCurrentSession().commit();
    }
    
    @Override
    public void rollback() {
        getCurrentSession().rollback();
    }
    
    @Override
    public void close() {
        for (Session session : sessions.values()) {
            session.close();
        }
        sessions.clear();
    }
}
```

## 7. 安全性设计

### 7.1 SQL注入防护

1. 所有用户输入都通过参数化查询处理
2. 禁止直接拼接SQL字符串
3. 对特殊字符进行转义处理

### 7.2 数据验证

```java
public class ValidationUtils {
    public static void validateEntity(Object entity) {
        // 验证实体对象的有效性
    }
}
```

## 8. 性能优化

### 8.1 一级缓存

Session级别的缓存，避免重复查询：

```java
public class FirstLevelCache {
    private Map<Object, Object> cache = new HashMap<>();
    
    public void put(Object key, Object value) {
        cache.put(key, value);
    }
    
    public Object get(Object key) {
        return cache.get(key);
    }
    
    public void remove(Object key) {
        cache.remove(key);
    }
    
    public void clear() {
        cache.clear();
    }
}
```

### 8.2 批处理支持

```java
public interface BatchOperation {
    void saveBatch(List<Object> entities);
    void updateBatch(List<Object> entities);
    void deleteBatch(List<Object> entities);
}
```

## 9. 使用示例

### 9.1 实体类定义

```java
@Entity(table = "users")
public class User {
    @Id(autoGenerate = true)
    private Long id;
    
    @Column(name = "username", length = 50)
    private String username;
    
    @Column(name = "email", length = 100)
    private String email;
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    // getters and setters
}
```

### 9.2 配置数据源

```java
// 配置主数据源
HikariConfig primaryConfig=new HikariConfig();
        primaryConfig.setJdbcUrl("jdbc:mysql://localhost:3306/primary_db");
        primaryConfig.setUsername("user");
        primaryConfig.setPassword("password");
        HikariConnectionProvider primaryProvider=new HikariConnectionProvider(primaryConfig);
        DataSourceManager.registerDataSource("primary",primaryProvider);

// 配置备用数据源
        HikariConfig secondaryConfig=new HikariConfig();
        secondaryConfig.setJdbcUrl("jdbc:mysql://localhost:3306/secondary_db");
        secondaryConfig.setUsername("user");
        secondaryConfig.setPassword("password");
        HikariConnectionProvider secondaryProvider=new HikariConnectionProvider(secondaryConfig);
        DataSourceManager.registerDataSource("secondary",secondaryProvider);
```

### 9.3 基本操作

```java
// 创建多数据源会话
MultiDataSourceSession session = new MultiDataSourceSessionImpl("primary");

// 保存实体到主数据源
User user = new User();
user.setUsername("john");
user.setEmail("john@example.com");
user.setCreatedAt(LocalDateTime.now());
session.save(user);

// 查询实体
User foundUser = session.findById(User.class, 1L);

// 更新实体
foundUser.setEmail("john.doe@example.com");
session.update(foundUser);

// 删除实体
session.delete(foundUser);

// 查询列表
Query<User> query = session.createQuery(User.class);
List<User> users = query.where("username = ?", "john").list();

// 切换到备用数据源
session.switchDataSource("secondary");

// 在备用数据源上执行操作
User secondaryUser = new User();
secondaryUser.setUsername("jane");
secondaryUser.setEmail("jane@example.com");
secondaryUser.setCreatedAt(LocalDateTime.now());
session.save(secondaryUser);

// 事务操作
session.beginTransaction();
try {
    session.save(user1);
    session.save(user2);
    session.commit();
} catch (Exception e) {
    session.rollback();
    throw e;
}

// 关闭会话
session.close();

// 关闭所有数据源
DataSourceManager.closeAll();
```

## 10. 扩展性设计

### 10.1 方言接口

支持不同数据库的SQL方言：

```java
public interface Dialect {
    String getIdentityColumnString();
    String getSelectGUIDString();
    boolean supportsLimit();
    String getLimitString(String sql, int offset, int limit);
}
```

### 10.2 自定义类型映射

```java
public interface UserType {
    Object nullSafeGet(ResultSet rs, String[] names) throws SQLException;
    void nullSafeSet(PreparedStatement st, Object value, int index) throws SQLException;
}
```

## 11. 错误处理

### 11.1 异常体系

```java
public class ORMException extends RuntimeException {
    public ORMException(String message) {
        super(message);
    }
    
    public ORMException(String message, Throwable cause) {
        super(message, cause);
    }
}

public class MappingException extends ORMException {
    // 映射相关异常
}

public class SQLException extends ORMException {
    // SQL执行异常
}
```

## 12. 部署和使用

### 12.1 Maven依赖

```xml
<dependency>
    <groupId>com.im</groupId>
    <artifactId>orm</artifactId>
    <version>1.0.0</version>
</dependency>

<!-- HikariCP依赖 -->
<dependency>
    <groupId>com.zaxxer</groupId>
    <artifactId>HikariCP</artifactId>
    <version>4.0.3</version>
</dependency>
```

### 12.2 配置示例

```java
// 配置数据源
HikariConfig config=new HikariConfig();
        config.setJdbcUrl("jdbc:mysql://localhost:3306/mydb");
        config.setUsername("user");
        config.setPassword("password");
        config.setMaximumPoolSize(20);
        config.setMinimumIdle(5);
        config.setConnectionTimeout(30000);
        config.setIdleTimeout(600000);
        config.setMaxLifetime(1800000);

// 创建连接提供者
        HikariConnectionProvider provider=new HikariConnectionProvider(config);

// 注册数据源
        DataSourceManager.registerDataSource("default",provider);

// 创建会话工厂
        SessionFactory factory=new SessionFactory();

// 创建会话
        MultiDataSourceSession session=factory.createSession("default");
```

这个设计文档描述了一个轻量级ORM框架的核心设计和实现方案。该框架具有简单易用、高性能、可扩展等特点，能够满足智能制造框架项目的需求，并支持多数据源和高性能连接池（HikariCP）。