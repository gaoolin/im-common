# 半导体制造行业工具类使用文档

## 1. 通用工具类

### 1.1 BatchProcessor - 批量数据处理工具

#### 概述
[BatchProcessor](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\common\BatchProcessor.java#L30-L582) 是一个通用的批量数据处理工具类，支持分批处理和并行处理大量数据，特别适用于半导体制造行业中的大数据处理场景。

#### 核心功能
- 分批处理大量数据
- 并行处理提升性能
- 完善的处理结果跟踪
- 异常处理和容错机制

#### 使用示例

##### 分批处理数据
```java
// 准备大量测试数据
List<TestData> testDataList = generateTestData(10000);

// 分批处理（每批1000条记录）
List<BatchProcessor.BatchResult<TestData>> results = 
    BatchProcessor.processInBatches(testDataList, 1000, batch -> {
        // 处理每批数据
        processBatchData(batch);
        System.out.println("Processed batch with " + batch.size() + " items");
    });

// 检查处理结果
for (BatchProcessor.BatchResult<TestData> result : results) {
    if (result.isSuccess()) {
        System.out.println("Batch " + result.getBatchIndex() + " processed successfully");
    } else {
        System.err.println("Batch " + result.getBatchIndex() + " failed: " + 
                          result.getError().getMessage());
    }
}
```


##### 并行处理数据
```java
// 准备待处理数据
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// 并行处理（使用4个线程）
List<Integer> squaredNumbers = BatchProcessor.processParallel(
    numbers, 
    x -> x * x,  // 计算平方
    4  // 4个并发线程
);

System.out.println("Squared numbers: " + squaredNumbers);
```


#### 最佳实践
1. **合理设置批处理大小**：根据内存和处理能力调整批处理大小
2. **监控处理性能**：利用处理时间统计优化性能
3. **异常处理**：妥善处理部分失败的情况
4. **资源管理**：注意线程池资源的释放

### 1.2 DataQualityChecker - 数据质量检查工具

#### 概述
[DataQualityChecker](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\common\DataQualityChecker.java#L30-L582) 是一个通用的数据质量检查工具类，用于评估制造数据的完整性、一致性和准确性。

#### 核心功能
- 数据完整性检查
- 数据一致性验证
- 多维度质量评估
- 详细的质量报告生成

#### 使用示例

##### 检查数据完整性
```java
// 准备测试数据
List<String> testData = Arrays.asList("A", "B", "", "D", null, "F");

// 定义完整性验证规则
Predicate<String> notEmptyValidator = s -> s != null && !s.isEmpty();

// 检查完整性（要求90%以上的数据完整）
DataQualityChecker.CompletenessResult result = 
    DataQualityChecker.checkCompleteness(testData, notEmptyValidator, 0.9);

System.out.println("Completeness Check Result:");
System.out.println("Total items: " + result.getTotal());
System.out.println("Valid items: " + result.getValid());
System.out.println("Completeness: " + String.format("%.2f%%", result.getCompleteness() * 100));
System.out.println("Pass: " + result.isPass());
System.out.println("Message: " + result.getMessage());
```


##### 检查数据一致性
```java
// 准备多个数据源的数据
List<List<Integer>> dataSources = Arrays.asList(
    Arrays.asList(1, 2, 3, 4, 5),
    Arrays.asList(1, 2, 3, 4, 5),
    Arrays.asList(1, 2, 3, 4, 6)  // 最后一个元素不同
);

// 定义比较器
Comparator<Integer> integerComparator = Integer::compareTo;

// 检查一致性（要求95%以上一致）
DataQualityChecker.ConsistencyResult result = 
    DataQualityChecker.checkConsistency(dataSources, integerComparator, 0.95);

System.out.println("Consistency Check Result:");
System.out.println("Total comparisons: " + result.getTotalComparisons());
System.out.println("Consistent comparisons: " + result.getConsistentComparisons());
System.out.println("Consistency: " + String.format("%.2f%%", result.getConsistency() * 100));
System.out.println("Pass: " + result.isPass());
```


##### 生成综合质量报告
```java
// 准备测试数据
List<TestRecord> records = generateTestRecords(1000);

// 定义多个质量维度的验证器
List<Predicate<TestRecord>> validators = Arrays.asList(
    record -> record.getId() != null && !record.getId().isEmpty(),  // ID完整性
    record -> record.getValue() != null,  // 值完整性
    record -> record.getTimestamp() != null,  // 时间戳完整性
    record -> record.getValue() >= 0 && record.getValue() <= 100  // 值范围有效性
);

// 生成质量报告
DataQualityChecker.DataQualityReport report = 
    DataQualityChecker.generateQualityReport(records, validators);

System.out.println("Data Quality Report:");
System.out.println("Overall Score: " + String.format("%.2f%%", report.getOverallScore() * 100));
System.out.println("Overall Pass: " + report.isOverallPass());

for (DataQualityChecker.QualityDimensionResult dimension : report.getDimensionResults()) {
    System.out.println("  " + dimension.getDimensionName() + ": " + 
                      String.format("%.2f%%", dimension.getScore() * 100) + 
                      " (" + (dimension.isPass() ? "PASS" : "FAIL") + ")");
}
```


#### 最佳实践
1. **定义清晰的验证规则**：根据业务需求制定明确的数据质量标准
2. **设置合理的阈值**：根据不同数据类型设置合适的质量阈值
3. **定期质量评估**：建立数据质量监控机制
4. **质量改进**：根据质量报告持续改进数据采集和处理流程

## 2. 半导体行业专用工具

### 2.1 SecsGemKit - SECS/GEM协议工具

#### 概述
[SecsGemKit](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\semiconductor\protocol\SecsGemKit.java#L30-L582) 是一个专业的SECS/GEM协议工具类，用于处理半导体制造设备通信中的SECS消息。

#### 核心功能
- SECS消息解析和构建
- SECS消息发送和接收
- 协议格式验证
- 连接管理

#### 使用示例

##### 解析SECS消息
```java
// 模拟接收到的原始SECS消息数据
byte[] rawData = new byte[] {
    0x00, 0x01,  // 设备ID
    0x01,        // Stream
    0x01,        // Function
    (byte) 0x80, // P-Type
    0x00,        // Reserved
    0x00, 0x00, 0x00, 0x05,  // 数据长度
    0x48, 0x65, 0x6C, 0x6C, 0x6F  // "Hello"
};

// 解析SECS消息
SecsGemKit.SecsMessage message = SecsGemKit.parseSecsMessage(rawData);

if (message != null) {
    System.out.println("Parsed SECS message:");
    System.out.println("Header: " + Arrays.toString(message.getHeader()));
    System.out.println("Body length: " + message.getBody().length);
    System.out.println("Body content: " + new String(message.getBody()));
}
```


##### 构建和发送SECS消息
```java
// 构建SECS消息
byte[] messageData = "S1F1 Online Request".getBytes();
SecsGemKit.SecsMessage message = SecsGemKit.buildSecsMessage(
    1,  // Stream 1
    1,  // Function 1
    123,  // 设备ID
    messageData
);

if (message != null) {
    System.out.println("Built SECS message:");
    System.out.println("Message size: " + message.toByteArray().length + " bytes");
    
    // 发送消息（需要实现具体的连接）
    // SecsGemKit.SecsMessage response = SecsGemKit.sendSecsMessage(connection, message, 5000);
}
```


#### 最佳实践
1. **连接管理**：妥善管理SECS连接的生命周期
2. **超时设置**：根据设备响应时间合理设置超时
3. **异常处理**：处理网络异常和协议错误
4. **日志记录**：详细记录通信过程便于调试

### 2.2 WaferMapParser - Wafer Map解析工具

#### 概述
[WaferMapParser](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\semiconductor\data\WaferMapParser.java#L30-L582) 是一个专业的Wafer Map解析工具类，用于处理半导体制造中的晶圆图数据。

#### 核心功能
- 多种Wafer Map格式解析
- Die状态分析和统计
- 良率计算和报告生成
- 数据验证和质量检查

#### 使用示例

##### 解析Wafer Map文件
```java
// 解析CDF格式的Wafer Map文件
WaferMapParser.WaferMap waferMap = WaferMapParser.parseWaferMap(
    "/path/to/wafer_map.cdf", 
    WaferMapParser.WaferMapFormat.CDF
);

if (waferMap != null) {
    System.out.println("Parsed Wafer Map:");
    System.out.println("Lot ID: " + waferMap.getLotId());
    System.out.println("Wafer ID: " + waferMap.getWaferId());
    System.out.println("Total Dies: " + waferMap.getDies().size());
    System.out.println("Wafer Size: " + waferMap.getWaferSize() + "mm");
    
    // 显示前几个Die的信息
    waferMap.getDies().stream().limit(10).forEach(die -> {
        System.out.println("Die(" + die.getX() + "," + die.getY() + "): " + die.getStatus());
    });
}
```


##### 生成Wafer Map分析报告
```java
// 生成Wafer Map统计报告
WaferMapParser.WaferMapReport report = WaferMapParser.generateReport(waferMap);

if (report != null) {
    System.out.println("Wafer Map Analysis Report:");
    System.out.println("Total Dies: " + report.getTotalDies());
    System.out.println("Good Dies: " + report.getGoodDies());
    System.out.println("Bad Dies: " + report.getBadDies());
    System.out.println("Yield: " + String.format("%.2f%%", report.getYield() * 100));
    
    System.out.println("Status Distribution:");
    report.getStatusCounts().forEach((status, count) -> {
        System.out.println("  " + status + ": " + count);
    });
}
```


#### 最佳实践
1. **格式支持**：根据设备输出格式选择合适的解析器
2. **数据验证**：验证解析结果的完整性和正确性
3. **性能优化**：对于大尺寸Wafer Map，考虑内存使用优化
4. **报告定制**：根据分析需求定制报告内容

## 3. 异常处理

### 3.1 SemiconductorException - 半导体行业专用异常

#### 概述
[SemiconductorException](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\exception\SemiconductorException.java#L30-L582) 是半导体行业的专用异常类，提供了针对不同异常类型的分类和处理。

#### 异常类型
- [PROTOCOL_ERROR](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\exception\SemiconductorException.java#L24-L24): 协议相关错误
- [EQUIPMENT_ERROR](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\exception\SemiconductorException.java#L25-L25): 设备相关错误
- [DATA_ERROR](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\exception\SemiconductorException.java#L26-L26): 数据相关错误
- [QUALITY_ERROR](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\exception\SemiconductorException.java#L27-L27): 质量相关错误
- [PROCESS_ERROR](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\exception\SemiconductorException.java#L28-L28): 工艺相关错误

#### 使用示例

##### 协议异常处理
```java
try {
    // 尝试发送SECS消息
    sendSecsMessage(message);
} catch (SemiconductorException.ProtocolException e) {
    System.err.println("Protocol error occurred: " + e.getErrorMessage());
    System.err.println("Error code: " + e.getErrorCode());
    
    // 根据错误码采取相应措施
    switch (e.getErrorCode()) {
        case "P-001":
            // 重连设备
            reconnectEquipment();
            break;
        case "P-002":
            // 重新初始化协议
            reinitializeProtocol();
            break;
        default:
            // 记录错误并通知维护人员
            logErrorAndNotify(e);
    }
}
```


##### 设备异常处理
```java
try {
    // 尝试操作设备
    operateEquipment(equipmentId, command);
} catch (SemiconductorException.EquipmentException e) {
    System.err.println("Equipment error: " + e.getErrorMessage());
    
    // 根据异常类型处理
    switch (e.getExceptionType()) {
        case EQUIPMENT_ERROR:
            // 设备故障，停止生产并通知维护
            stopProductionLine();
            notifyMaintenanceTeam(e);
            break;
        default:
            // 其他设备错误，记录日志
            logEquipmentError(e);
    }
}
```


#### 最佳实践
1. **异常分类**：根据业务场景选择合适的异常类型
2. **错误码规范**：建立统一的错误码命名规范
3. **异常链**：保留原始异常信息便于问题追踪
4. **恢复机制**：实现适当的错误恢复和重试机制

## 4. 实际应用场景

### 4.1 数据采集和质量监控系统
```java
public class DataAcquisitionSystem {
    private static final Logger logger = LoggerFactory.getLogger(DataAcquisitionSystem.class);
    
    public void collectAndProcessEquipmentData(String equipmentId) {
        try {
            // 1. 采集设备数据
            List<EquipmentData> rawData = collectRawData(equipmentId);
            
            // 2. 检查数据质量
            DataQualityChecker.CompletenessResult qualityResult = 
                DataQualityChecker.checkCompleteness(rawData, 
                    data -> data != null && data.isValid(), 0.95);
            
            if (!qualityResult.isPass()) {
                throw new SemiconductorException.DataException(
                    "D-001", 
                    "Data quality check failed: " + qualityResult.getMessage()
                );
            }
            
            // 3. 批量处理数据
            List<BatchProcessor.BatchResult<EquipmentData>> batchResults = 
                BatchProcessor.processInBatches(rawData, 1000, this::processBatch);
            
            // 4. 检查处理结果
            long failedBatches = batchResults.stream()
                .filter(result -> !result.isSuccess())
                .count();
                
            if (failedBatches > 0) {
                logger.warn("Failed to process {} batches of equipment data", failedBatches);
            }
            
            logger.info("Successfully processed {} records from equipment {}", 
                       rawData.size(), equipmentId);
                       
        } catch (SemiconductorException.DataException e) {
            logger.error("Data processing error for equipment {}: {}", equipmentId, e.getErrorMessage());
            // 通知数据质量问题
            notifyDataQualityIssue(equipmentId, e);
        } catch (Exception e) {
            logger.error("Unexpected error during data acquisition for equipment {}", equipmentId, e);
        }
    }
    
    private List<EquipmentData> collectRawData(String equipmentId) {
        // 实现数据采集逻辑
        return new ArrayList<>();
    }
    
    private void processBatch(List<EquipmentData> batch) {
        // 实现批处理逻辑
    }
    
    private void notifyDataQualityIssue(String equipmentId, SemiconductorException.DataException e) {
        // 实现质量问题通知逻辑
    }
}
```


### 4.2 Wafer测试数据分析系统
```java
public class WaferAnalysisSystem {
    private static final Logger logger = LoggerFactory.getLogger(WaferAnalysisSystem.class);
    
    public void analyzeWaferTestResults(String waferMapFilePath) {
        try {
            // 1. 解析Wafer Map
            WaferMapParser.WaferMap waferMap = WaferMapParser.parseWaferMap(
                waferMapFilePath, WaferMapParser.WaferMapFormat.AUTO_DETECT);
                
            if (waferMap == null) {
                throw new SemiconductorException.DataException(
                    "D-002", 
                    "Failed to parse wafer map file: " + waferMapFilePath
                );
            }
            
            // 2. 生成分析报告
            WaferMapParser.WaferMapReport report = WaferMapParser.generateReport(waferMap);
            
            // 3. 质量检查
            if (report.getYield() < 0.8) {  // 良率低于80%
                logger.warn("Low yield detected: {}%", String.format("%.2f", report.getYield() * 100));
                // 触发质量警报
                triggerQualityAlert(waferMap, report);
            }
            
            // 4. 保存分析结果
            saveAnalysisReport(waferMap, report);
            
            logger.info("Wafer analysis completed. Yield: {}%, Total Dies: {}", 
                       String.format("%.2f", report.getYield() * 100), 
                       report.getTotalDies());
                       
        } catch (SemiconductorException.DataException e) {
            logger.error("Wafer analysis error: {}", e.getErrorMessage());
            // 处理数据异常
        } catch (Exception e) {
            logger.error("Unexpected error during wafer analysis", e);
        }
    }
    
    private void triggerQualityAlert(WaferMapParser.WaferMap waferMap, 
                                   WaferMapParser.WaferMapReport report) {
        // 实现质量警报逻辑
    }
    
    private void saveAnalysisReport(WaferMapParser.WaferMap waferMap, 
                                  WaferMapParser.WaferMapReport report) {
        // 实现报告保存逻辑
    }
}
```


## 5. 最佳实践总结

### 5.1 性能优化
1. **批量处理**：使用[BatchProcessor](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\common\BatchProcessor.java#L30-L582)处理大量数据
2. **并行计算**：合理使用并行处理提升性能
3. **内存管理**：注意大文件和大数据集的内存使用
4. **缓存机制**：适当使用缓存减少重复计算

### 5.2 错误处理
1. **异常分类**：使用[SemiconductorException](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\exception\SemiconductorException.java#L30-L582)进行精确异常处理
2. **恢复机制**：实现故障恢复和重试逻辑
3. **日志记录**：详细记录操作日志便于问题排查
4. **监控告警**：建立完善的监控和告警机制

### 5.3 数据质量
1. **质量检查**：使用[DataQualityChecker](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\common\DataQualityChecker.java#L30-L582)确保数据质量
2. **验证规则**：制定明确的数据验证规则
3. **质量报告**：定期生成数据质量报告
4. **持续改进**：根据质量报告持续优化数据流程

### 5.4 安全性
1. **访问控制**：控制对敏感数据和设备的访问
2. **数据保护**：保护生产数据的安全
3. **审计日志**：记录关键操作的审计日志
4. **合规性**：确保符合行业标准和法规要求

这套工具类和组件为半导体制造行业提供了完整的解决方案，能够有效提升数据处理效率、保证数据质量、简化设备通信，并提供专业的异常处理机制。