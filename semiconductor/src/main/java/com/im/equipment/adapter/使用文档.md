# EquipmentAdapter 使用说明文档

## 1. 概述

[EquipmentAdapter](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\semiconductor\equipment\adapter\EquipmentAdapter.java#L12-L1013)
是一个专业的设备通信适配器工具类，专门为半导体封测设备的多协议通信设计。该工具解决了不同厂商设备通信协议差异大、设备通信集成复杂、设备命令标准化困难和设备响应处理不统一等问题。

## 2. 核心功能

### 2.1 多协议设备通信

- 支持多种设备通信协议（SECS/GEM、Modbus、OPC UA、HTTP等）
- 统一的连接管理接口
- 灵活的连接配置和参数设置

### 2.2 标准化设备命令

- 统一的设备命令接口
- 标准化的命令类型和参数
- 可配置的命令处理策略

### 2.3 设备状态轮询

- 定期轮询设备状态
- 可配置的轮询间隔和超时时间
- 自动化的轮询任务管理

### 2.4 设备事件监听

- 实时监听设备事件
- 灵活的事件注册和注销机制
- 完善的事件处理流程

## 3. 支持的协议类型

### 3.1 协议类型枚举

```java
public enum ProtocolType {
    SECSGEM("SECS/GEM协议"),
    MODBUS("Modbus协议"),
    OPCUA("OPC UA协议"),
    HTTP("HTTP协议"),
    CUSTOM("自定义协议");
}
```

## 4. 基本使用方法

### 4.1 设备连接管理

```java
// 设备连接管理示例
public class EquipmentConnectionExample {
    public void manageEquipmentConnections() {
        System.out.println("开始设备连接管理示例...");
        
        // 1. 创建连接配置
        EquipmentAdapter.ConnectionConfig config = new EquipmentAdapter.ConnectionConfig()
                .setHost("192.168.1.100")
                .setPort(5000)
                .setConnectionTimeout(30000)
                .setResponseTimeout(10000)
                .setMaxRetries(3)
                .setRetryDelay(1000);
        
        // 2. 创建设备连接
        String equipmentId = "EQ-20250820-001";
        EquipmentAdapter.ProtocolType protocol = EquipmentAdapter.ProtocolType.SECSGEM;
        
        EquipmentAdapter.EquipmentConnection connection = 
            EquipmentAdapter.createConnection(equipmentId, protocol, config);
        
        if (connection != null && connection.isConnected()) {
            System.out.println("设备连接创建成功:");
            System.out.println("  设备ID: " + connection.getEquipmentId());
            System.out.println("  协议类型: " + connection.getProtocol());
            System.out.println("  连接状态: 已连接");
            
            // 3. 测试连接健康状态
            try {
                boolean isHealthy = connection.ping();
                System.out.println("  连接健康状态: " + (isHealthy ? "健康" : "不健康"));
            } catch (Exception e) {
                System.err.println("  连接健康检查失败: " + e.getMessage());
            }
            
            // 4. 断开连接
            try {
                connection.disconnect();
                System.out.println("  连接已断开");
            } catch (Exception e) {
                System.err.println("  断开连接失败: " + e.getMessage());
            }
        } else {
            System.err.println("设备连接创建失败");
        }
        
        // 5. 批量创建多个设备连接
        System.out.println("\n批量创建设备连接:");
        String[] equipmentIds = {"EQ-001", "EQ-002", "EQ-003"};
        EquipmentAdapter.ProtocolType[] protocols = {
            EquipmentAdapter.ProtocolType.SECSGEM,
            EquipmentAdapter.ProtocolType.MODBUS,
            EquipmentAdapter.ProtocolType.OPCUA
        };
        
        for (int i = 0; i < equipmentIds.length; i++) {
            EquipmentAdapter.EquipmentConnection conn = 
                EquipmentAdapter.createConnection(equipmentIds[i], protocols[i], config);
            
            if (conn != null && conn.isConnected()) {
                System.out.println("  " + equipmentIds[i] + " (" + protocols[i] + "): 连接成功");
            } else {
                System.out.println("  " + equipmentIds[i] + " (" + protocols[i] + "): 连接失败");
            }
        }
    }
}
```

### 4.2 标准化设备命令

```java
// 标准化设备命令示例
public class StandardCommandExample {
    public void sendStandardCommands() {
        System.out.println("开始标准化设备命令示例...");
        
        // 1. 创建命令配置
        EquipmentAdapter.CommandConfig config = new EquipmentAdapter.CommandConfig()
                .setResponseTimeout(10000)
                .setMaxRetries(3)
                .setRetryDelay(1000)
                .setEnableCache(true)
                .setProtocol(EquipmentAdapter.ProtocolType.SECSGEM)
                .setProcessorName("default");
        
        // 2. 发送获取设备信息命令
        String equipmentId = "EQ-20250820-001";
        EquipmentAdapter.StandardCommand infoCommand = 
            new EquipmentAdapter.StandardCommand(EquipmentAdapter.StandardCommand.CommandType.GET_INFO, equipmentId);
        
        EquipmentAdapter.EquipmentResponse infoResponse = 
            EquipmentAdapter.sendStandardCommand(equipmentId, infoCommand, config);
        
        if (infoResponse != null && infoResponse.getStatus() == EquipmentAdapter.ResponseStatus.SUCCESS) {
            System.out.println("获取设备信息命令执行成功:");
            System.out.println("  响应状态: " + infoResponse.getStatus());
            System.out.println("  响应消息: " + infoResponse.getMessage());
            
            Object data = infoResponse.getData();
            if (data instanceof EquipmentAdapter.EquipmentInfo) {
                EquipmentAdapter.EquipmentInfo info = (EquipmentAdapter.EquipmentInfo) data;
                System.out.println("  设备名称: " + info.getEquipmentName());
                System.out.println("  设备型号: " + info.getModel());
                System.out.println("  制造商: " + info.getManufacturer());
                System.out.println("  序列号: " + info.getSerialNumber());
            }
        } else {
            System.err.println("获取设备信息命令执行失败:");
            System.err.println("  响应状态: " + (infoResponse != null ? infoResponse.getStatus() : "null"));
            System.err.println("  错误消息: " + (infoResponse != null ? infoResponse.getMessage() : "null"));
        }
        
        // 3. 发送获取设备状态命令
        EquipmentAdapter.StandardCommand statusCommand = 
            new EquipmentAdapter.StandardCommand(EquipmentAdapter.StandardCommand.CommandType.GET_STATUS, equipmentId);
        statusCommand.setParameter("detailLevel", "full");
        
        EquipmentAdapter.EquipmentResponse statusResponse = 
            EquipmentAdapter.sendStandardCommand(equipmentId, statusCommand, config);
        
        if (statusResponse != null && statusResponse.getStatus() == EquipmentAdapter.ResponseStatus.SUCCESS) {
            System.out.println("\n获取设备状态命令执行成功:");
            System.out.println("  响应状态: " + statusResponse.getStatus());
            
            Object data = statusResponse.getData();
            if (data instanceof EquipmentAdapter.EquipmentStatus) {
                EquipmentAdapter.EquipmentStatus status = (EquipmentAdapter.EquipmentStatus) data;
                System.out.println("  设备状态: " + status.getState());
                System.out.println("  状态时间戳: " + new Date(status.getTimestamp()));
            }
        } else {
            System.err.println("\n获取设备状态命令执行失败:");
            System.err.println("  响应状态: " + (statusResponse != null ? statusResponse.getStatus() : "null"));
        }
        
        // 4. 发送控制命令
        EquipmentAdapter.StandardCommand controlCommand = 
            new EquipmentAdapter.StandardCommand(EquipmentAdapter.StandardCommand.CommandType.CONTROL, equipmentId);
        controlCommand.setParameter("action", "start");
        controlCommand.setParameter("parameters", Map.of("speed", 1000, "temperature", 25.0));
        
        EquipmentAdapter.EquipmentResponse controlResponse = 
            EquipmentAdapter.sendStandardCommand(equipmentId, controlCommand, config);
        
        System.out.println("\n发送控制命令:");
        if (controlResponse != null && controlResponse.getStatus() == EquipmentAdapter.ResponseStatus.SUCCESS) {
            System.out.println("  控制命令执行成功");
        } else {
            System.err.println("  控制命令执行失败");
        }
        
        // 5. 异步发送命令
        System.out.println("\n异步发送命令示例:");
        CompletableFuture<EquipmentAdapter.EquipmentResponse> futureResponse = 
            EquipmentAdapter.sendStandardCommandAsync(equipmentId, infoCommand, config);
        
        try {
            EquipmentAdapter.EquipmentResponse asyncResponse = futureResponse.get(10, TimeUnit.SECONDS);
            System.out.println("  异步命令执行完成，状态: " + asyncResponse.getStatus());
        } catch (Exception e) {
            System.err.println("  异步命令执行超时或异常: " + e.getMessage());
        }
    }
}
```

### 4.3 设备状态轮询

```java
// 设备状态轮询示例
public class EquipmentPollingExample {
    public void pollEquipmentStatus() {
        System.out.println("开始设备状态轮询示例...");
        
        // 1. 创建轮询配置
        EquipmentAdapter.PollingConfig config = new EquipmentAdapter.PollingConfig()
                .setPollingInterval(5000)  // 5秒轮询一次
                .setResponseTimeout(10000)
                .setMaxRetries(3)
                .setRetryDelay(1000)
                .setEnableCache(true)
                .setProtocol(EquipmentAdapter.ProtocolType.SECSGEM);
        
        // 2. 启动设备轮询
        String equipmentId = "EQ-20250820-001";
        boolean started = EquipmentAdapter.startPolling(equipmentId, config);
        System.out.println("启动设备轮询: " + (started ? "成功" : "失败"));
        
        // 3. 手动执行一次轮询
        System.out.println("\n手动执行轮询:");
        EquipmentAdapter.PollingResult result = EquipmentAdapter.pollEquipmentStatus(equipmentId, config);
        
        if (result != null && result.getStatus() == EquipmentAdapter.PollingStatus.SUCCESS) {
            System.out.println("  轮询执行成功:");
            System.out.println("    状态: " + result.getStatus());
            System.out.println("    消息: " + result.getMessage());
            
            EquipmentAdapter.EquipmentStatus status = result.getEquipmentStatus();
            if (status != null) {
                System.out.println("    设备状态: " + status.getState());
                System.out.println("    状态时间: " + new Date(status.getTimestamp()));
            }
        } else {
            System.err.println("  轮询执行失败:");
            System.err.println("    状态: " + (result != null ? result.getStatus() : "null"));
            System.err.println("    消息: " + (result != null ? result.getMessage() : "null"));
        }
        
        // 4. 等待一段时间观察轮询效果
        System.out.println("\n等待15秒观察轮询效果...");
        try {
            Thread.sleep(15000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // 5. 停止设备轮询
        boolean stopped = EquipmentAdapter.stopPolling(equipmentId);
        System.out.println("\n停止设备轮询: " + (stopped ? "成功" : "失败"));
    }
}
```

### 4.4 设备事件监听

```java
// 设备事件监听示例
public class EquipmentEventListeningExample {
    public void listenToEquipmentEvents() {
        System.out.println("开始设备事件监听示例...");
        
        // 1. 创建事件监听器
        EquipmentAdapter.EquipmentEventListener listener = new EquipmentAdapter.EquipmentEventListener() {
            @Override
            public void onEquipmentEvent(EquipmentAdapter.EquipmentEvent event) {
                System.out.println("收到设备事件:");
                System.out.println("  事件类型: " + event.getEventType());
                System.out.println("  设备ID: " + event.getEquipmentId());
                System.out.println("  事件时间: " + event.getEventTime());
                System.out.println("  事件消息: " + event.getMessage());
                
                Object eventData = event.getEventData();
                if (eventData != null) {
                    System.out.println("  事件数据: " + eventData.toString());
                }
            }
            
            @Override
            public void onError(EquipmentAdapter.EquipmentException exception) {
                System.err.println("设备事件处理错误:");
                System.err.println("  设备ID: " + exception.getEquipmentId());
                System.err.println("  错误代码: " + exception.getErrorCode());
                System.err.println("  错误消息: " + exception.getMessage());
            }
        };
        
        // 2. 注册事件监听器
        String equipmentId = "EQ-20250820-001";
        EquipmentAdapter.registerEventListener(equipmentId, listener);
        System.out.println("已注册设备事件监听器: " + equipmentId);
        
        // 3. 模拟触发事件
        System.out.println("\n模拟触发设备事件:");
        EquipmentAdapter.EquipmentEvent statusChangeEvent = new EquipmentAdapter.EquipmentEvent(
            EquipmentAdapter.EventType.STATUS_CHANGE,
            equipmentId,
            new EquipmentAdapter.EquipmentStatus(equipmentId, EquipmentAdapter.EquipmentState.RUNNING, System.currentTimeMillis())
        );
        statusChangeEvent.setAttribute("previousState", EquipmentAdapter.EquipmentState.IDLE);
        statusChangeEvent.setAttribute("reason", "自动启动");
        
        EquipmentAdapter.fireEvent(equipmentId, statusChangeEvent);
        
        // 4. 触发告警事件
        EquipmentAdapter.EquipmentEvent alarmEvent = new EquipmentAdapter.EquipmentEvent(
            EquipmentAdapter.EventType.ALARM,
            equipmentId,
            "温度过高告警"
        );
        alarmEvent.setAttribute("temperature", 85.5);
        alarmEvent.setAttribute("threshold", 80.0);
        alarmEvent.setAttribute("severity", "HIGH");
        
        EquipmentAdapter.fireEvent(equipmentId, alarmEvent);
        
        // 5. 注销事件监听器
        EquipmentAdapter.unregisterEventListener(equipmentId);
        System.out.println("\n已注销设备事件监听器: " + equipmentId);
    }
}
```

## 5. 高级使用示例

### 5.1 完整的设备通信流程

```java
public class CompleteEquipmentCommunicationProcess {
    public void executeCompleteCommunicationProcess() {
        try {
            System.out.println("=== 开始完整的设备通信流程 ===");
            
            // 步骤1: 初始化连接配置
            System.out.println("\n步骤1: 初始化连接配置");
            initializeConnectionConfiguration();
            
            // 步骤2: 建立设备连接
            System.out.println("\n步骤2: 建立设备连接");
            EquipmentAdapter.EquipmentConnection connection = establishEquipmentConnection();
            
            if (connection == null) {
                System.err.println("无法建立设备连接，流程终止");
                return;
            }
            
            // 步骤3: 获取设备信息
            System.out.println("\n步骤3: 获取设备信息");
            getEquipmentInformation(connection.getEquipmentId());
            
            // 步骤4: 获取设备状态
            System.out.println("\n步骤4: 获取设备状态");
            getEquipmentStatus(connection.getEquipmentId());
            
            // 步骤5: 发送控制命令
            System.out.println("\n步骤5: 发送控制命令");
            sendControlCommands(connection.getEquipmentId());
            
            // 步骤6: 启动状态轮询
            System.out.println("\n步骤6: 启动状态轮询");
            startEquipmentPolling(connection.getEquipmentId());
            
            // 步骤7: 注册事件监听
            System.out.println("\n步骤7: 注册事件监听");
            registerEventListeners(connection.getEquipmentId());
            
            // 步骤8: 模拟设备交互
            System.out.println("\n步骤8: 模拟设备交互");
            simulateEquipmentInteraction(connection.getEquipmentId());
            
            // 步骤9: 停止轮询和监听
            System.out.println("\n步骤9: 停止轮询和监听");
            stopPollingAndListening(connection.getEquipmentId());
            
            // 步骤10: 断开设备连接
            System.out.println("\n步骤10: 断开设备连接");
            disconnectEquipment(connection);
            
            System.out.println("\n=== 设备通信流程完成 ===");
            
        } catch (Exception e) {
            System.err.println("设备通信流程执行过程中发生错误: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    private void initializeConnectionConfiguration() {
        System.out.println("初始化连接配置...");
        
        // 创建默认连接配置
        EquipmentAdapter.ConnectionConfig defaultConfig = new EquipmentAdapter.ConnectionConfig();
        System.out.println("  默认连接超时: " + defaultConfig.getConnectionTimeout() + "ms");
        System.out.println("  默认响应超时: " + defaultConfig.getResponseTimeout() + "ms");
        System.out.println("  默认最大重试次数: " + defaultConfig.getMaxRetries());
        System.out.println("  默认重试延迟: " + defaultConfig.getRetryDelay() + "ms");
        
        // 创建自定义连接配置
        EquipmentAdapter.ConnectionConfig customConfig = new EquipmentAdapter.ConnectionConfig()
                .setHost("192.168.1.100")
                .setPort(5000)
                .setConnectionTimeout(30000)
                .setResponseTimeout(15000)
                .setMaxRetries(5)
                .setRetryDelay(2000);
        
        System.out.println("  自定义连接配置:");
        System.out.println("    主机: " + customConfig.getHost());
        System.out.println("    端口: " + customConfig.getPort());
        System.out.println("    连接超时: " + customConfig.getConnectionTimeout() + "ms");
        System.out.println("    响应超时: " + customConfig.getResponseTimeout() + "ms");
    }
    
    private EquipmentAdapter.EquipmentConnection establishEquipmentConnection() {
        System.out.println("建立设备连接...");
        
        String equipmentId = "EQ-COMPLETE-TEST";
        EquipmentAdapter.ProtocolType protocol = EquipmentAdapter.ProtocolType.SECSGEM;
        EquipmentAdapter.ConnectionConfig config = new EquipmentAdapter.ConnectionConfig()
                .setHost("192.168.1.100")
                .setPort(5000);
        
        EquipmentAdapter.EquipmentConnection connection = 
            EquipmentAdapter.createConnection(equipmentId, protocol, config);
        
        if (connection != null && connection.isConnected()) {
            System.out.println("  设备连接建立成功: " + equipmentId);
            return connection;
        } else {
            System.err.println("  设备连接建立失败: " + equipmentId);
            return null;
        }
    }
    
    private void getEquipmentInformation(String equipmentId) {
        System.out.println("获取设备信息...");
        
        EquipmentAdapter.StandardCommand command = 
            new EquipmentAdapter.StandardCommand(EquipmentAdapter.StandardCommand.CommandType.GET_INFO, equipmentId);
        
        EquipmentAdapter.EquipmentResponse response = 
            EquipmentAdapter.sendStandardCommand(equipmentId, command);
        
        if (response != null && response.getStatus() == EquipmentAdapter.ResponseStatus.SUCCESS) {
            System.out.println("  设备信息获取成功");
            Object data = response.getData();
            if (data instanceof EquipmentAdapter.EquipmentInfo) {
                EquipmentAdapter.EquipmentInfo info = (EquipmentAdapter.EquipmentInfo) data;
                System.out.println("    设备名称: " + info.getEquipmentName());
                System.out.println("    设备型号: " + info.getModel());
                System.out.println("    制造商: " + info.getManufacturer());
            }
        } else {
            System.err.println("  设备信息获取失败");
        }
    }
    
    private void getEquipmentStatus(String equipmentId) {
        System.out.println("获取设备状态...");
        
        EquipmentAdapter.StandardCommand command = 
            new EquipmentAdapter.StandardCommand(EquipmentAdapter.StandardCommand.CommandType.GET_STATUS, equipmentId);
        
        EquipmentAdapter.EquipmentResponse response = 
            EquipmentAdapter.sendStandardCommand(equipmentId, command);
        
        if (response != null && response.getStatus() == EquipmentAdapter.ResponseStatus.SUCCESS) {
            System.out.println("  设备状态获取成功");
            Object data = response.getData();
            if (data instanceof EquipmentAdapter.EquipmentStatus) {
                EquipmentAdapter.EquipmentStatus status = (EquipmentAdapter.EquipmentStatus) data;
                System.out.println("    当前状态: " + status.getState());
                System.out.println("    状态时间: " + new Date(status.getTimestamp()));
            }
        } else {
            System.err.println("  设备状态获取失败");
        }
    }
    
    private void sendControlCommands(String equipmentId) {
        System.out.println("发送控制命令...");
        
        // 发送启动命令
        EquipmentAdapter.StandardCommand startCommand = 
            new EquipmentAdapter.StandardCommand(EquipmentAdapter.StandardCommand.CommandType.CONTROL, equipmentId);
        startCommand.setParameter("action", "start");
        startCommand.setParameter("mode", "auto");
        
        EquipmentAdapter.EquipmentResponse startResponse = 
            EquipmentAdapter.sendStandardCommand(equipmentId, startCommand);
        
        System.out.println("  发送启动命令: " + 
                         (startResponse != null && startResponse.getStatus() == EquipmentAdapter.ResponseStatus.SUCCESS ? 
                          "成功" : "失败"));
        
        // 发送参数设置命令
        EquipmentAdapter.StandardCommand configCommand = 
            new EquipmentAdapter.StandardCommand(EquipmentAdapter.StandardCommand.CommandType.CONFIGURE, equipmentId);
        configCommand.setParameter("temperature", 25.0);
        configCommand.setParameter("pressure", 1.0);
        configCommand.setParameter("speed", 1000);
        
        EquipmentAdapter.EquipmentResponse configResponse = 
            EquipmentAdapter.sendStandardCommand(equipmentId, configCommand);
        
        System.out.println("  发送配置命令: " + 
                         (configResponse != null && configResponse.getStatus() == EquipmentAdapter.ResponseStatus.SUCCESS ? 
                          "成功" : "失败"));
    }
    
    private void startEquipmentPolling(String equipmentId) {
        System.out.println("启动设备轮询...");
        
        EquipmentAdapter.PollingConfig config = new EquipmentAdapter.PollingConfig()
                .setPollingInterval(10000);  // 10秒轮询一次
        
        boolean started = EquipmentAdapter.startPolling(equipmentId, config);
        System.out.println("  设备轮询启动: " + (started ? "成功" : "失败"));
        
        // 执行一次手动轮询
        EquipmentAdapter.PollingResult result = EquipmentAdapter.pollEquipmentStatus(equipmentId, config);
        if (result != null && result.getStatus() == EquipmentAdapter.PollingStatus.SUCCESS) {
            System.out.println("  手动轮询执行成功");
        }
    }
    
    private void registerEventListeners(String equipmentId) {
        System.out.println("注册事件监听器...");
        
        EquipmentAdapter.EquipmentEventListener listener = new EquipmentAdapter.EquipmentEventListener() {
            @Override
            public void onEquipmentEvent(EquipmentAdapter.EquipmentEvent event) {
                System.out.println("    收到事件: " + event.getEventType() + " - " + event.getEquipmentId());
            }
            
            @Override
            public void onError(EquipmentAdapter.EquipmentException exception) {
                System.err.println("    事件处理错误: " + exception.getMessage());
            }
        };
        
        EquipmentAdapter.registerEventListener(equipmentId, listener);
        System.out.println("  事件监听器注册成功");
    }
    
    private void simulateEquipmentInteraction(String equipmentId) {
        System.out.println("模拟设备交互...");
        
        // 等待5秒观察轮询效果
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // 触发状态变化事件
        EquipmentAdapter.EquipmentEvent statusEvent = new EquipmentAdapter.EquipmentEvent(
            EquipmentAdapter.EventType.STATUS_CHANGE,
            equipmentId,
            new EquipmentAdapter.EquipmentStatus(equipmentId, EquipmentAdapter.EquipmentState.RUNNING, System.currentTimeMillis())
        );
        EquipmentAdapter.fireEvent(equipmentId, statusEvent);
        System.out.println("  触发状态变化事件");
        
        // 触发告警事件
        EquipmentAdapter.EquipmentEvent alarmEvent = new EquipmentAdapter.EquipmentEvent(
            EquipmentAdapter.EventType.ALARM,
            equipmentId,
            "模拟告警"
        );
        EquipmentAdapter.fireEvent(equipmentId, alarmEvent);
        System.out.println("  触发告警事件");
    }
    
    private void stopPollingAndListening(String equipmentId) {
        System.out.println("停止轮询和监听...");
        
        // 停止轮询
        boolean pollingStopped = EquipmentAdapter.stopPolling(equipmentId);
        System.out.println("  轮询停止: " + (pollingStopped ? "成功" : "失败"));
        
        // 注销监听器
        EquipmentAdapter.unregisterEventListener(equipmentId);
        System.out.println("  监听器注销: 成功");
    }
    
    private void disconnectEquipment(EquipmentAdapter.EquipmentConnection connection) {
        System.out.println("断开设备连接...");
        
        try {
            connection.disconnect();
            System.out.println("  设备连接断开成功");
        } catch (Exception e) {
            System.err.println("  设备连接断开失败: " + e.getMessage());
        }
    }
}
```

### 5.2 设备通信数据分析

```java
public class EquipmentCommunicationDataAnalysis {
    public void analyzeCommunicationData() {
        System.out.println("=== 设备通信数据分析 ===");
        
        // 分析协议使用情况
        analyzeProtocolUsage();
        
        // 分析命令执行情况
        analyzeCommandExecution();
        
        // 分析设备连接状态
        analyzeConnectionStatus();
        
        // 分析事件处理情况
        analyzeEventHandling();
        
        System.out.println("=== 数据分析完成 ===");
    }
    
    private void analyzeProtocolUsage() {
        System.out.println("\n分析协议使用情况:");
        
        // 模拟不同协议的使用统计
        Map<EquipmentAdapter.ProtocolType, Integer> protocolUsage = new EnumMap<>(EquipmentAdapter.ProtocolType.class);
        protocolUsage.put(EquipmentAdapter.ProtocolType.SECSGEM, 45);
        protocolUsage.put(EquipmentAdapter.ProtocolType.MODBUS, 30);
        protocolUsage.put(EquipmentAdapter.ProtocolType.OPCUA, 15);
        protocolUsage.put(EquipmentAdapter.ProtocolType.HTTP, 8);
        protocolUsage.put(EquipmentAdapter.ProtocolType.CUSTOM, 2);
        
        int totalConnections = protocolUsage.values().stream().mapToInt(Integer::intValue).sum();
        
        System.out.println("  总连接数: " + totalConnections);
        System.out.println("  协议分布:");
        for (Map.Entry<EquipmentAdapter.ProtocolType, Integer> entry : protocolUsage.entrySet()) {
            double percentage = (double) entry.getValue() / totalConnections * 100;
            System.out.println("    " + entry.getKey() + ": " + entry.getValue() + 
                             " (" + String.format("%.1f", percentage) + "%)");
        }
    }
    
    private void analyzeCommandExecution() {
        System.out.println("\n分析命令执行情况:");
        
        // 获取适配器统计信息
        EquipmentAdapter.AdapterStatistics stats = EquipmentAdapter.getStatistics();
        
        System.out.println("  总命令数: " + stats.getTotalCommands());
        System.out.println("  成功命令数: " + stats.getSuccessfulCommands());
        System.out.println("  失败命令数: " + stats.getFailedCommands());
        System.out.println("  成功率: " + String.format("%.2f", stats.getSuccessRate()) + "%");
        
        if (stats.getTotalCommands() > 0) {
            System.out.println("  平均响应时间: 待实现");
            System.out.println("  最繁忙时段: 待实现");
        }
    }
    
    private void analyzeConnectionStatus() {
        System.out.println("\n分析设备连接状态:");
        
        EquipmentAdapter.AdapterStatistics stats = EquipmentAdapter.getStatistics();
        
        System.out.println("  活跃连接数: " + stats.getActiveConnections());
        System.out.println("  连接池大小: " + stats.getConnectionPoolSize());
        System.out.println("  缓存大小: " + stats.getResponseCacheSize());
        
        // 模拟连接状态分布
        Map<String, String> connectionStates = new HashMap<>();
        connectionStates.put("CONN-001", "CONNECTED");
        connectionStates.put("CONN-002", "CONNECTED");
        connectionStates.put("CONN-003", "DISCONNECTED");
        connectionStates.put("CONN-004", "CONNECTED");
        connectionStates.put("CONN-005", "ERROR");
        
        long connectedCount = connectionStates.values().stream()
                .filter(state -> "CONNECTED".equals(state))
                .count();
        long disconnectedCount = connectionStates.values().stream()
                .filter(state -> "DISCONNECTED".equals(state))
                .count();
        long errorCount = connectionStates.values().stream()
                .filter(state -> "ERROR".equals(state))
                .count();
        
        System.out.println("  连接状态分布:");
        System.out.println("    已连接: " + connectedCount);
        System.out.println("    已断开: " + disconnectedCount);
        System.out.println("    错误: " + errorCount);
    }
    
    private void analyzeEventHandling() {
        System.out.println("\n分析事件处理情况:");
        
        EquipmentAdapter.AdapterStatistics stats = EquipmentAdapter.getStatistics();
        
        System.out.println("  事件监听器数: " + stats.getEventListeners());
        System.out.println("  轮询任务数: " + stats.getPollingTasks());
        
        // 模拟事件类型分布
        Map<EquipmentAdapter.EventType, Integer> eventTypes = new EnumMap<>(EquipmentAdapter.EventType.class);
        eventTypes.put(EquipmentAdapter.EventType.STATUS_CHANGE, 50);
        eventTypes.put(EquipmentAdapter.EventType.ALARM, 20);
        eventTypes.put(EquipmentAdapter.EventType.ERROR, 5);
        eventTypes.put(EquipmentAdapter.EventType.MAINTENANCE, 8);
        eventTypes.put(EquipmentAdapter.EventType.CUSTOM, 17);
        
        int totalEvents = eventTypes.values().stream().mapToInt(Integer::intValue).sum();
        
        System.out.println("  事件类型分布 (总计: " + totalEvents + "):");
        for (Map.Entry<EquipmentAdapter.EventType, Integer> entry : eventTypes.entrySet()) {
            double percentage = (double) entry.getValue() / totalEvents * 100;
            System.out.println("    " + entry.getKey() + ": " + entry.getValue() + 
                             " (" + String.format("%.1f", percentage) + "%)");
        }
    }
}
```

## 6. 配置参数详解

### 6.1 系统级配置参数

```java
public class EquipmentAdapterConfig {
    // 默认连接超时时间（毫秒）
    public static final long DEFAULT_CONNECTION_TIMEOUT = 30000; // 30秒
    
    // 默认响应超时时间（毫秒）
    public static final long DEFAULT_RESPONSE_TIMEOUT = 10000; // 10秒
    
    // 默认最大重试次数
    public static final int DEFAULT_MAX_RETRIES = 3;
    
    // 默认重试延迟（毫秒）
    public static final long DEFAULT_RETRY_DELAY = 1000; // 1秒
    
    // 默认轮询间隔（毫秒）
    public static final long DEFAULT_POLLING_INTERVAL = 5000; // 5秒
    
    // 默认缓存超时时间（毫秒）
    public static final long DEFAULT_CACHE_TIMEOUT = 30 * 60 * 1000; // 30分钟
    
    // 默认连接池大小
    public static final int DEFAULT_CONNECTION_POOL_SIZE = 10;
    
    // 默认最大命令队列大小
    public static final int DEFAULT_MAX_COMMAND_QUEUE_SIZE = 1000;
}
```

### 6.2 连接配置类详解

```java
public class ConnectionConfigDetails {
    /*
     * ConnectionConfig 配置参数详解:
     * 
     * connectionTimeout: 连接超时时间（毫秒）
     *   - 默认值: 30000 (30秒)
     *   - 建议范围: 5000-60000 (5秒-1分钟)
     *   - 过小的值可能导致连接失败
     *   - 过大的值会延长错误检测时间
     * 
     * responseTimeout: 响应超时时间（毫秒）
     *   - 默认值: 10000 (10秒)
     *   - 建议范围: 1000-30000 (1秒-30秒)
     *   - 根据设备响应速度调整
     * 
     * maxRetries: 最大重试次数
     *   - 默认值: 3
     *   - 建议范围: 1-10
     *   - 防止网络波动导致通信中断
     * 
     * retryDelay: 重试延迟（毫秒）
     *   - 默认值: 1000 (1秒)
     *   - 建议范围: 500-10000 (0.5秒-10秒)
     *   - 递增延迟可避免重试风暴
     * 
     * host: 设备主机地址
     *   - 根据实际设备IP地址设置
     * 
     * port: 设备端口号
     *   - 根据设备通信协议设置
     */
    
    public static void explainConfigParameters() {
        System.out.println("ConnectionConfig 参数详解:");
        System.out.println("connectionTimeout: 连接超时时间，影响连接建立的等待时间");
        System.out.println("responseTimeout: 响应超时时间，影响命令执行的等待时间");
        System.out.println("maxRetries: 最大重试次数，提高通信可靠性");
        System.out.println("retryDelay: 重试延迟，避免重试风暴");
        System.out.println("host: 设备主机地址，指定目标设备IP");
        System.out.println("port: 设备端口号，指定目标设备端口");
    }
}
```

### 6.3 命令配置类详解

```java
public class CommandConfigDetails {
    /*
     * CommandConfig 配置参数详解:
     * 
     * responseTimeout: 命令响应超时时间（毫秒）
     *   - 默认值: 10000 (10秒)
     *   - 可针对不同命令类型调整
     * 
     * maxRetries: 命令执行最大重试次数
     *   - 默认值: 3
     *   - 可根据命令重要性调整
     * 
     * retryDelay: 命令重试延迟（毫秒）
     *   - 默认值: 1000 (1秒)
     *   - 可设置递增延迟策略
     * 
     * enableCache: 是否启用响应缓存
     *   - 默认值: true
     *   - 对于频繁查询的命令可提高性能
     * 
     * protocol: 指定通信协议类型
     *   - 可覆盖默认协议选择
     * 
     * processorName: 指定命令处理器
     *   - 可选择不同的处理策略
     */
    
    public static void explainCommandConfigParameters() {
        System.out.println("CommandConfig 参数详解:");
        System.out.println("responseTimeout: 命令响应超时，影响命令执行等待时间");
        System.out.println("maxRetries: 命令重试次数，提高命令执行可靠性");
        System.out.println("retryDelay: 命令重试延迟，避免重试风暴");
        System.out.println("enableCache: 响应缓存开关，提高重复查询性能");
        System.out.println("protocol: 通信协议类型，可指定特定协议");
        System.out.println("processorName: 命令处理器名称，可选择不同处理策略");
    }
}
```

## 7. 错误处理

### 7.1 异常处理示例

```java
public class EquipmentAdapterErrorHandler {
    public void handleAdapterErrors() {
        System.out.println("设备适配器错误处理示例");
        
        try {
            // 创建连接配置
            EquipmentAdapter.ConnectionConfig config = new EquipmentAdapter.ConnectionConfig()
                    .setHost("invalid.host")
                    .setPort(9999);
            
            // 尝试创建连接（预期会失败）
            String equipmentId = "EQ-ERROR-TEST";
            EquipmentAdapter.EquipmentConnection connection = 
                EquipmentAdapter.createConnection(equipmentId, EquipmentAdapter.ProtocolType.SECSGEM, config);
            
            if (connection == null) {
                System.err.println("设备连接创建失败，已正确处理错误");
            }
            
            // 尝试发送命令（预期会失败）
            EquipmentAdapter.StandardCommand command = 
                new EquipmentAdapter.StandardCommand(EquipmentAdapter.StandardCommand.CommandType.GET_INFO, equipmentId);
            
            EquipmentAdapter.EquipmentResponse response = 
                EquipmentAdapter.sendStandardCommand(equipmentId, command);
            
            if (response != null && response.getStatus() != EquipmentAdapter.ResponseStatus.SUCCESS) {
                System.err.println("命令执行失败: " + response.getMessage());
                handleCommandError(response);
            }
            
        } catch (Exception e) {
            System.err.println("适配器使用过程中发生异常: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    private void handleCommandError(EquipmentAdapter.EquipmentResponse response) {
        switch (response.getStatus()) {
            case FAILURE:
                System.err.println("  命令执行一般性失败");
                break;
            case TIMEOUT:
                System.err.println("  命令执行超时");
                break;
            case UNAUTHORIZED:
                System.err.println("  设备未授权访问");
                break;
            case NOT_FOUND:
                System.err.println("  设备或命令未找到");
                break;
            default:
                System.err.println("  未知错误状态: " + response.getStatus());
        }
    }
    
    public boolean safeCommandExecution(String equipmentId, EquipmentAdapter.StandardCommand command) {
        if (equipmentId == null || equipmentId.isEmpty() || command == null) {
            System.err.println("设备ID或命令不能为空");
            return false;
        }
        
        EquipmentAdapter.CommandConfig config = new EquipmentAdapter.CommandConfig()
                .setMaxRetries(3)
                .setRetryDelay(1000);
        
        int maxAttempts = 3;
        int attemptCount = 0;
        
        while (attemptCount < maxAttempts) {
            try {
                EquipmentAdapter.EquipmentResponse response = 
                    EquipmentAdapter.sendStandardCommand(equipmentId, command, config);
                
                if (response != null && response.getStatus() == EquipmentAdapter.ResponseStatus.SUCCESS) {
                    System.out.println("命令执行成功");
                    return true;
                } else {
                    System.err.println("第" + (attemptCount + 1) + "次命令执行失败: " + 
                                     (response != null ? response.getMessage() : "null"));
                }
                
            } catch (Exception e) {
                System.err.println("第" + (attemptCount + 1) + "次命令执行异常: " + e.getMessage());
            }
            
            attemptCount++;
            
            // 重试前等待
            if (attemptCount < maxAttempts) {
                try {
                    Thread.sleep(1000 * attemptCount); // 递增延迟
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
        
        System.err.println("命令执行最终失败，已重试 " + maxAttempts + " 次");
        return false;
    }
}
```

## 8. 最佳实践

### 8.1 连接管理最佳实践

```java
public class ConnectionManagementBestPractices {
    public void demonstrateBestPractices() {
        System.out.println("设备连接管理最佳实践演示");
        
        // 1. 连接池管理
        System.out.println("1. 连接池管理");
        manageConnectionPool();
        
        // 2. 连接健康检查
        System.out.println("2. 连接健康检查");
        performHealthChecks();
        
        // 3. 资源释放
        System.out.println("3. 资源释放");
        releaseResourcesProperly();
        
        // 4. 错误恢复
        System.out.println("4. 错误恢复");
        implementErrorRecovery();
    }
    
    private void manageConnectionPool() {
        System.out.println("连接池管理实践:");
        
        // 复用现有连接
        System.out.println("  优先复用现有连接");
        
        // 限制连接池大小
        System.out.println("  合理设置连接池大小");
        
        // 定期清理无效连接
        System.out.println("  定期清理无效连接");
    }
    
    private void performHealthChecks() {
        System.out.println("连接健康检查实践:");
        
        // 定期发送心跳包
        System.out.println("  定期发送心跳包检测连接状态");
        
        // 快速失败机制
        System.out.println("  实现快速失败机制");
        
        // 自动重连机制
        System.out.println("  实现自动重连机制");
    }
    
    private void releaseResourcesProperly() {
        System.out.println("资源释放实践:");
        
        // 及时关闭连接
        System.out.println("  及时关闭不再使用的连接");
        
        // 清理事件监听器
        System.out.println("  清理注册的事件监听器");
        
        // 停止轮询任务
        System.out.println("  停止正在进行的轮询任务");
    }
    
    private void implementErrorRecovery() {
        System.out.println("错误恢复实践:");
        
        // 实现重试机制
        System.out.println("  实现指数退避重试机制");
        
        // 降级处理
        System.out.println("  实现服务降级处理");
        
        // 告警通知
        System.out.println("  实现错误告警通知机制");
    }
}
```

### 8.2 性能优化实践

```java
public class PerformanceOptimization {
    public void demonstratePerformanceOptimization() {
        System.out.println("设备适配器性能优化实践");
        
        // 1. 响应缓存
        System.out.println("1. 响应缓存优化");
        useResponseCaching();
        
        // 2. 批量处理
        System.out.println("2. 批量处理优化");
        optimizeBatchProcessing();
        
        // 3. 异步处理
        System.out.println("3. 异步处理优化");
        useAsyncProcessing();
        
        // 4. 连接复用
        System.out.println("4. 连接复用优化");
        reuseConnections();
    }
    
    private void useResponseCaching() {
        System.out.println("响应缓存优化:");
        
        // 启用缓存
        EquipmentAdapter.CommandConfig config = new EquipmentAdapter.CommandConfig()
                .setEnableCache(true);
        
        System.out.println("  启用命令响应缓存");
        System.out.println("  合理设置缓存超时时间");
        System.out.println("  针对频繁查询命令使用缓存");
    }
    
    private void optimizeBatchProcessing() {
        System.out.println("批量处理优化:");
        
        // 批量发送命令
        String equipmentId = "EQ-BATCH-TEST";
        List<EquipmentAdapter.StandardCommand> commands = new ArrayList<>();
        
        for (int i = 0; i < 10; i++) {
            EquipmentAdapter.StandardCommand command = 
                new EquipmentAdapter.StandardCommand(EquipmentAdapter.StandardCommand.CommandType.GET_STATUS, equipmentId);
            command.setParameter("index", i);
            commands.add(command);
        }
        
        System.out.println("  批量发送 " + commands.size() + " 个命令");
        System.out.println("  减少连接建立次数");
        System.out.println("  提高处理效率");
    }
    
    private void useAsyncProcessing() {
        System.out.println("异步处理优化:");
        
        // 使用异步方式发送命令
        String equipmentId = "EQ-ASYNC-TEST";
        EquipmentAdapter.StandardCommand command = 
            new EquipmentAdapter.StandardCommand(EquipmentAdapter.StandardCommand.CommandType.GET_INFO, equipmentId);
        
        CompletableFuture<EquipmentAdapter.EquipmentResponse> future = 
            EquipmentAdapter.sendStandardCommandAsync(equipmentId, command);
        
        System.out.println("  使用异步方式发送命令");
        System.out.println("  避免阻塞主线程");
        System.out.println("  提高并发处理能力");
    }
    
    private void reuseConnections() {
        System.out.println("连接复用优化:");
        
        // 复用现有连接
        System.out.println("  复用现有的设备连接");
        System.out.println("  避免频繁建立和关闭连接");
        System.out.println("  使用连接池管理连接资源");
    }
}
```

## 9. 系统集成

### 9.1 与Spring框架集成

```java
@Component
public class SpringEquipmentAdapterService {
    
    // 设备连接管理服务
    public EquipmentAdapter.EquipmentConnection createEquipmentConnection(String equipmentId, 
                                                                         EquipmentAdapter.ProtocolType protocol) {
        EquipmentAdapter.ConnectionConfig config = new EquipmentAdapter.ConnectionConfig();
        return EquipmentAdapter.createConnection(equipmentId, protocol, config);
    }
    
    // 设备命令发送服务
    @Async
    public CompletableFuture<EquipmentAdapter.EquipmentResponse> sendEquipmentCommandAsync(
            String equipmentId, 
            EquipmentAdapter.StandardCommand command) {
        return CompletableFuture.completedFuture(
            EquipmentAdapter.sendStandardCommand(equipmentId, command)
        );
    }
    
    // 设备状态轮询服务
    @Scheduled(fixedRate = 30000) // 每30秒轮询一次
    public void pollEquipmentStatus() {
        // 获取所有需要轮询的设备
        // List<String> equipmentIds = getAllEquipmentForPolling();
        
        // for (String equipmentId : equipmentIds) {
        //     EquipmentAdapter.PollingResult result = EquipmentAdapter.pollEquipmentStatus(equipmentId, new EquipmentAdapter.PollingConfig());
        //     if (result != null && result.getEquipmentStatus() != null) {
        //         // 处理轮询结果
        //         handleEquipmentStatus(result.getEquipmentStatus());
        //     }
        // }
        
        System.out.println("定时轮询设备状态");
    }
    
    // 设备事件监听服务
    @EventListener
    public void handleEquipmentEvent(EquipmentAdapter.EquipmentEvent event) {
        // 处理设备事件
        System.out.println("处理设备事件: " + event.getEventType() + " - " + event.getEquipmentId());
        // 实现具体的事件处理逻辑
    }
    
    // 获取适配器统计信息
    public EquipmentAdapter.AdapterStatistics getAdapterStatistics() {
        return EquipmentAdapter.getStatistics();
    }
}
```

### 9.2 与消息队列集成

```java
@Component
public class MessageQueueIntegration {
    
    // Kafka集成示例
    @KafkaListener(topics = "equipment-commands", groupId = "equipment-adapter-processor")
    public void handleEquipmentCommand(String commandJson) {
        try {
            // 解析JSON到设备命令对象
            EquipmentCommandMessage commandMessage = parseCommandFromJson(commandJson);
            
            // 执行设备命令
            executeEquipmentCommand(commandMessage);
            
        } catch (Exception e) {
            System.err.println("处理设备命令时发生错误: " + e.getMessage());
        }
    }
    
    @KafkaListener(topics = "equipment-events", groupId = "equipment-adapter-processor")
    public void handleEquipmentEvent(String eventJson) {
        try {
            // 解析JSON到设备事件对象
            EquipmentEventMessage eventMessage = parseEventFromJson(eventJson);
            
            // 处理设备事件
            processEquipmentEvent(eventMessage);
            
        } catch (Exception e) {
            System.err.println("处理设备事件时发生错误: " + e.getMessage());
        }
    }
    
    // RabbitMQ集成示例
    @RabbitListener(queues = "equipment-status-queue")
    public void handleEquipmentStatus(EquipmentStatusMessage statusMessage) {
        try {
            // 处理设备状态更新
            updateEquipmentStatus(statusMessage);
            
        } catch (Exception e) {
            System.err.println("处理设备状态时发生错误: " + e.getMessage());
        }
    }
    
    // 私有辅助方法
    private EquipmentCommandMessage parseCommandFromJson(String json) {
        // 实现JSON到设备命令对象的解析
        return new EquipmentCommandMessage("EQ-001", "GET_STATUS", new HashMap<>());
    }
    
    private EquipmentEventMessage parseEventFromJson(String json) {
        // 实现JSON到设备事件对象的解析
        return new EquipmentEventMessage("EQ-001", "ALARM", "Temperature high");
    }
    
    private void executeEquipmentCommand(EquipmentCommandMessage commandMessage) {
        System.out.println("执行设备命令: " + commandMessage.getEquipmentId() + 
                          " - " + commandMessage.getCommand());
        // 实现具体的设备命令执行逻辑
    }
    
    private void processEquipmentEvent(EquipmentEventMessage eventMessage) {
        System.out.println("处理设备事件: " + eventMessage.getEquipmentId() + 
                          " - " + eventMessage.getEventType() + 
                          ": " + eventMessage.getMessage());
        // 实现具体的设备事件处理逻辑
    }
    
    private void updateEquipmentStatus(EquipmentStatusMessage statusMessage) {
        System.out.println("更新设备状态: " + statusMessage.getEquipmentId() + 
                          " -> " + statusMessage.getStatus());
        // 实现具体的设备状态更新逻辑
    }
}

// 设备命令消息类
class EquipmentCommandMessage {
    private String equipmentId;
    private String command;
    private Map<String, Object> parameters;
    private long timestamp;
    
    public EquipmentCommandMessage(String equipmentId, String command, Map<String, Object> parameters) {
        this.equipmentId = equipmentId;
        this.command = command;
        this.parameters = parameters;
        this.timestamp = System.currentTimeMillis();
    }
    
    // Getters and Setters
    public String getEquipmentId() { return equipmentId; }
    public void setEquipmentId(String equipmentId) { this.equipmentId = equipmentId; }
    
    public String getCommand() { return command; }
    public void setCommand(String command) { this.command = command; }
    
    public Map<String, Object> getParameters() { return parameters; }
    public void setParameters(Map<String, Object> parameters) { this.parameters = parameters; }
    
    public long getTimestamp() { return timestamp; }
    public void setTimestamp(long timestamp) { this.timestamp = timestamp; }
}

// 设备事件消息类
class EquipmentEventMessage {
    private String equipmentId;
    private String eventType;
    private String message;
    private Map<String, Object> data;
    private long timestamp;
    
    public EquipmentEventMessage(String equipmentId, String eventType, String message) {
        this.equipmentId = equipmentId;
        this.eventType = eventType;
        this.message = message;
        this.data = new HashMap<>();
        this.timestamp = System.currentTimeMillis();
    }
    
    // Getters and Setters
    public String getEquipmentId() { return equipmentId; }
    public void setEquipmentId(String equipmentId) { this.equipmentId = equipmentId; }
    
    public String getEventType() { return eventType; }
    public void setEventType(String eventType) { this.eventType = eventType; }
    
    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
    
    public Map<String, Object> getData() { return data; }
    public void setData(Map<String, Object> data) { this.data = data; }
    
    public long getTimestamp() { return timestamp; }
    public void setTimestamp(long timestamp) { this.timestamp = timestamp; }
}

// 设备状态消息类
class EquipmentStatusMessage {
    private String equipmentId;
    private EquipmentAdapter.EquipmentState status;
    private Map<String, Object> attributes;
    private long timestamp;
    
    public EquipmentStatusMessage(String equipmentId, EquipmentAdapter.EquipmentState status) {
        this.equipmentId = equipmentId;
        this.status = status;
        this.attributes = new HashMap<>();
        this.timestamp = System.currentTimeMillis();
    }
    
    // Getters and Setters
    public String getEquipmentId() { return equipmentId; }
    public void setEquipmentId(String equipmentId) { this.equipmentId = equipmentId; }
    
    public EquipmentAdapter.EquipmentState getStatus() { return status; }
    public void setStatus(EquipmentAdapter.EquipmentState status) { this.status = status; }
    
    public Map<String, Object> getAttributes() { return attributes; }
    public void setAttributes(Map<String, Object> attributes) { this.attributes = attributes; }
    
    public long getTimestamp() { return timestamp; }
    public void setTimestamp(long timestamp) { this.timestamp = timestamp; }
}
```

这个使用说明文档涵盖了 [EquipmentAdapter](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\semiconductor\equipment\adapter\EquipmentAdapter.java#L12-L1013)
的主要功能和使用方法，可以帮助开发者快速上手并正确使用该设备通信适配器工具类。