# 轻量级HTTP服务器设计文档

## 1. 概述

### 1.1 设计目标

本设计旨在实现一个轻量级、高性能的HTTP服务器，具有以下特性：

- **规范性**：遵循HTTP/1.1协议标准
- **通用性**：支持所有标准HTTP方法
- **专业性**：提供完整的HTTP功能实现
- **灵活性**：支持函数式编程和链式API
- **可靠性**：具备完善的错误处理机制
- **安全性**：内置基础安全防护机制
- **可复用性**：模块化设计，组件可独立使用
- **容错性**：具备优雅的错误恢复能力

### 1.2 核心原则

1. **零外部依赖**：仅使用Java标准库
2. **函数式设计**：避免注解和反射机制
3. **高性能**：优化内存使用和处理速度
4. **易用性**：提供简洁的API接口

## 2. 架构设计

### 2.1 整体架构

```
HttpServer
├── Router (路由管理)
├── Middleware (中间件链)
├── Context (请求上下文)
└── Handler (请求处理器)
```

### 2.2 核心组件

#### 2.2.1 HttpServer

服务器主类，负责监听端口、接收请求和分发处理。

#### 2.2.2 Router

路由管理器，负责路由注册和匹配。

#### 2.2.3 Context

请求上下文，封装请求和响应信息。

#### 2.2.4 Handler

处理器接口，定义请求处理逻辑。

#### 2.2.5 Middleware

中间件接口，提供请求处理链。

## 3. 详细设计

### 3.1 HttpServer类

#### 3.1.1 类定义

```java
public class HttpServer {
    private final Router router;
    private final List<Middleware> middlewares;
    private final ExecutorService executor;
    private com.sun.net.httpserver.HttpServer server;
}
```

#### 3.1.2 核心方法

| 方法                                     | 描述         |
|----------------------------------------|------------|
| `get(String path, Handler handler)`    | 注册GET路由    |
| `post(String path, Handler handler)`   | 注册POST路由   |
| `put(String path, Handler handler)`    | 注册PUT路由    |
| `delete(String path, Handler handler)` | 注册DELETE路由 |
| `use(Middleware middleware)`           | 添加中间件      |
| `listen(int port)`                     | 启动服务器监听    |

### 3.2 Router类

#### 3.2.1 类定义

```java
public class Router {
    private final List<Route> routes;
    private final Map<String, Object> routeTrie; // 路由前缀树
}
```

#### 3.2.2 核心方法

| 方法                                                             | 描述    |
|----------------------------------------------------------------|-------|
| `addRoute(Route route)`                                        | 添加路由  |
| `match(String method, String path)`                            | 匹配路由  |
| `registerHandler(String method, String path, Handler handler)` | 注册处理器 |

### 3.3 Route类

#### 3.3.1 类定义

```java
public class Route {
    private final String method;
    private final String path;
    private final Handler handler;
    private final Map<String, String> pathParams;
}
```

#### 3.3.2 静态工厂方法

| 方法                                     | 描述         |
|----------------------------------------|------------|
| `GET(String path, Handler handler)`    | 创建GET路由    |
| `POST(String path, Handler handler)`   | 创建POST路由   |
| `PUT(String path, Handler handler)`    | 创建PUT路由    |
| `DELETE(String path, Handler handler)` | 创建DELETE路由 |

### 3.4 Context类

#### 3.4.1 类定义

```java
public class Context {
    private final HttpExchange exchange;
    private final Map<String, String> pathParams;
    private final Map<String, Object> attributes;
}
```

#### 3.4.2 核心方法

| 方法                            | 描述         |
|-------------------------------|------------|
| `method()`                    | 获取HTTP方法   |
| `path()`                      | 获取请求路径     |
| `queryParam(String name)`     | 获取查询参数     |
| `pathParam(String name)`      | 获取路径参数     |
| `header(String name)`         | 获取请求头      |
| `body()`                      | 获取请求体      |
| `bodyAsClass(Class<T> clazz)` | 解析请求体为指定类型 |
| `json(Object object)`         | 返回JSON响应   |
| `status(int code)`            | 设置响应状态码    |
| `send(String body)`           | 发送响应体      |

### 3.5 Handler接口

#### 3.5.1 接口定义

```java

@FunctionalInterface
public interface Handler {
    void handle(Context ctx) throws Exception;
}
```

### 3.6 Middleware接口

#### 3.6.1 接口定义

```java

@FunctionalInterface
public interface Middleware {
    void handle(Context ctx, Handler next) throws Exception;
}
```

## 4. 功能特性

### 4.1 路由功能

#### 4.1.1 静态路由

```
GET /users
POST /users
PUT /users/{id}
DELETE /users/{id}
```

#### 4.1.2 参数化路由

支持路径参数：

```
/users/{id}
/posts/{postId}/comments/{commentId}
```

#### 4.1.3 路由组

支持路由分组和前缀：

```java
server.use("/api/v1",apiV1Middleware);
        server.get("/api/v1/users",userHandler);
```

### 4.2 中间件系统

#### 4.2.1 内置中间件

1. **日志中间件**：记录请求日志
2. **CORS中间件**：处理跨域请求
3. **Body解析中间件**：解析请求体
4. **静态文件中间件**：提供静态文件服务

#### 4.2.2 自定义中间件

```java
Middleware authMiddleware=(ctx,next)->{
        String token=ctx.header("Authorization");
        if(isValidToken(token)){
        next.handle(ctx);
        }else{
        ctx.status(401).send("Unauthorized");
        }
        };
```

### 4.3 请求处理

#### 4.3.1 请求解析

- 解析HTTP方法
- 解析请求路径和查询参数
- 解析请求头
- 解析请求体（支持JSON、表单等）

#### 4.3.2 响应构建

- 设置状态码
- 设置响应头
- 发送响应体
- JSON序列化支持

### 4.4 错误处理

#### 4.4.1 内置错误处理

- 404 Not Found
- 405 Method Not Allowed
- 500 Internal Server Error

#### 4.4.2 自定义错误处理

```java
server.error(404,(ctx,error)->{
        ctx.status(404).json(Map.of("error","Not Found"));
        });
```

## 5. 安全特性

### 5.1 基础安全措施

1. **请求大小限制**：防止缓冲区溢出攻击
2. **超时控制**：防止慢速攻击
3. **Header验证**：防止Header注入攻击

### 5.2 可选安全中间件

1. **CORS支持**：跨域资源共享控制
2. **CSRF防护**：防止跨站请求伪造
3. **速率限制**：防止暴力破解和DDoS攻击

## 6. 性能优化

### 6.1 线程池管理

```java
// 根据CPU核心数配置线程池
int processors=Runtime.getRuntime().availableProcessors();
        ExecutorService executor=Executors.newFixedThreadPool(processors*2);
```

### 6.2 连接复用

- 启用HTTP Keep-Alive
- 合理设置连接超时时间

### 6.3 内存优化

- 及时释放请求和响应资源
- 使用对象池减少GC压力

## 7. 使用示例

### 7.1 基础服务器

```java
HttpServer server=new HttpServer();

        server.get("/",ctx->{
        ctx.send("Hello World!");
        });

        server.listen(8080);
```

### 7.2 REST API

```java
HttpServer server=new HttpServer();

// 获取用户列表
        server.get("/users",ctx->{
        List<User> users=userService.findAll();
        ctx.json(users);
        });

// 获取单个用户
        server.get("/users/{id}",ctx->{
        String id=ctx.pathParam("id");
        User user=userService.findById(id);
        if(user!=null){
        ctx.json(user);
        }else{
        ctx.status(404).send("User not found");
        }
        });

// 创建用户
        server.post("/users",ctx->{
        User user=ctx.bodyAsClass(User.class);
        User saved=userService.save(user);
        ctx.status(201).json(saved);
        });

        server.listen(8080);
```

### 7.3 中间件使用

```java
HttpServer server=new HttpServer();

// 日志中间件
        server.use((ctx,next)->{
        long start=System.currentTimeMillis();
        next.handle(ctx);
        long duration=System.currentTimeMillis()-start;
        System.out.println(ctx.method()+" "+ctx.path()+" - "+duration+"ms");
        });

// 认证中间件
        server.use("/admin",(ctx,next)->{
        String token=ctx.header("Authorization");
        if("secret-token".equals(token)){
        next.handle(ctx);
        }else{
        ctx.status(401).send("Unauthorized");
        }
        });

        server.listen(8080);
```

## 8. 扩展性设计

### 8.1 插件系统

支持通过中间件机制扩展功能：

```java
// 自定义插件示例
public class MetricsMiddleware implements Middleware {
    private final MetricsCollector collector;

    @Override
    public void handle(Context ctx, Handler next) throws Exception {
        long start = System.currentTimeMillis();
        next.handle(ctx);
        long duration = System.currentTimeMillis() - start;
        collector.recordRequest(ctx.method(), ctx.path(), duration);
    }
}
```

### 8.2 配置管理

```java
ServerConfig config=new ServerConfig()
        .port(8080)
        .maxThreads(100)
        .requestTimeout(30000)
        .maxRequestSize(1024*1024);

        HttpServer server=new HttpServer(config);
```

## 9. 测试支持

### 9.1 单元测试

提供MockContext用于单元测试：

```java
@Test
public void testUserHandler(){
        MockContext ctx=new MockContext();
        ctx.pathParam("id","123");

        userHandler.handle(ctx);

        assertEquals(200,ctx.responseStatus());
        assertNotNull(ctx.responseBody());
        }
```

### 9.2 集成测试

提供测试客户端用于集成测试：

```java
@Test
public void testServer(){
        HttpServer server=new HttpServer();
        server.get("/test",ctx->ctx.send("OK"));
        server.listen(8080);

        HttpClient client=new HttpClient();
        HttpResponse response=client.get("http://localhost:8080/test");

        assertEquals(200,response.getStatusCode());
        assertEquals("OK",response.getBody());
        }
```

## 10. 部署和运维

### 10.1 部署方式

1. **独立运行**：打包为JAR文件直接运行
2. **容器化部署**：构建Docker镜像
3. **集群部署**：配合负载均衡器使用

### 10.2 监控和日志

1. **内置指标**：请求数、响应时间、错误率等
2. **日志输出**：支持标准日志框架集成
3. **健康检查**：提供健康检查端点

这份设计文档提供了一个完整的轻量级HTTP服务器实现方案，兼顾了性能、功能和易用性。按照此文档开发的服务器将具有高性能、低资源占用的特点，同时保持良好的扩展性和维护性。