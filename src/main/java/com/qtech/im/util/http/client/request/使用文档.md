# HttpKit 详细使用说明

[HttpKit](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\util\http\HttpKit.java#L31-L489)
是一个功能强大的HTTP客户端工具，结合 [HttpConfig](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\util\http\HttpConfig.java#L15-L351)、[HttpMethod](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\util\http\HttpMethod.java#L14-L175)
和 [HttpStatus](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\util\http\HttpStatus.java#L22-L424) 工具，提供了完整的HTTP客户端解决方案。

## 1. 基础概念

### 1.1 核心组件

- **HttpKit**: HTTP客户端主类，负责执行HTTP请求
- **HttpConfig**: HTTP客户端配置类，定义连接、超时、重试等参数
- **HttpMethod**: HTTP方法类，定义请求方法及其属性
- **HttpStatus**: HTTP状态码类，处理响应状态码

### 1.2 设计特点

- 单例模式：全局共享实例
- 连接池管理：支持并发请求
- 异步支持：提供异步执行能力
- 重试机制：自动重试失败请求
- SSL支持：支持HTTPS请求
- GZIP压缩：自动处理压缩响应

## 2. 初始化和配置

### 2.1 使用默认配置

```java
// 获取默认的HttpKit实例
HttpKit httpKit = HttpKit.getInstance();
```

### 2.2 使用自定义配置

```java
// 创建自定义配置
HttpConfig config = HttpConfig.builder()
    // 连接配置
    .connectTimeout(5000)    // 连接超时5秒
    .readTimeout(10000)      // 读取超时10秒
    .writeTimeout(10000)     // 写入超时10秒
    
    // 连接池配置
    .maxConnections(100)     // 最大连接数
    .maxConnectionsPerRoute(20) // 每路由最大连接数
    
    // 重试配置
    .maxRetries(3)           // 最大重试次数
    .retryInterval(1000)     // 重试间隔1秒
    .exponentialBackoff(true) // 指数退避
    
    // 请求配置
    .userAgent("MyApp/1.0")  // User-Agent
    .defaultContentType("application/json; charset=UTF-8")
    .followRedirects(true)   // 跟随重定向
    .useCaches(false)        // 不使用缓存
    
    // 响应配置
    .enableGzip(true)        // 启用GZIP压缩
    .maxResponseSize(10 * 1024 * 1024) // 最大响应10MB
    
    // 安全配置
    .verifySsl(true)         // 验证SSL证书
    .verifyHostname(true)    // 验证主机名
    
    // 容错配置
    .failOnServerError(false) // 服务器错误不立即失败
    .failOnClientError(false) // 客户端错误不立即失败
    
    .build();

// 创建带配置的HttpKit实例
HttpKit httpKit = HttpKit.getInstance(config);
```

### 2.3 使用预定义配置

```java
// 默认配置
HttpConfig defaultConfig = HttpConfig.defaultConfig();

// 宽松配置（适用于测试环境）
HttpConfig looseConfig = HttpConfig.looseConfig();

// 严格配置（适用于生产环境）
HttpConfig strictConfig = HttpConfig.strictConfig();

// 使用预定义配置创建HttpKit实例
HttpKit httpKit = HttpKit.getInstance(strictConfig);
```

## 3. 构建和发送HTTP请求

### 3.1 基本请求构建

```java
// 创建GET请求
HttpKit.HttpRequest getRequest = new HttpKit.HttpRequest(
    HttpMethod.GET, 
    "https://api.example.com/users"
);

// 创建POST请求
HttpKit.HttpRequest postRequest = new HttpKit.HttpRequest(
    HttpMethod.POST, 
    "https://api.example.com/users"
);
postRequest.setBody("{\"name\":\"John\",\"email\":\"john@example.com\"}");
postRequest.setContentType("application/json");

// 创建PUT请求
HttpKit.HttpRequest putRequest = new HttpKit.HttpRequest(
    HttpMethod.PUT, 
    "https://api.example.com/users/123"
);
putRequest.setBody("{\"name\":\"John Doe\",\"email\":\"john.doe@example.com\"}");

// 创建DELETE请求
HttpKit.HttpRequest deleteRequest = new HttpKit.HttpRequest(
    HttpMethod.DELETE, 
    "https://api.example.com/users/123"
);
```

### 3.2 设置请求参数

```java
// 设置请求头
HttpKit.HttpRequest request = new HttpKit.HttpRequest(HttpMethod.POST, "https://api.example.com/users");
request.addHeader("Authorization", "Bearer your-token");
request.addHeader("X-API-Key", "your-api-key");

// 设置查询参数
request.addQueryParam("page", "1");
request.addQueryParam("size", "10");

// 设置请求体
request.setBody("{\"name\":\"John\"}");

// 设置特定超时
request.setConnectTimeout(3000);
request.setReadTimeout(5000);

// 设置内容类型
request.setContentType("application/json");
```

### 3.3 执行请求

```java
// 同步执行请求
HttpKit.HttpResponse response = httpKit.execute(request);

// 执行请求（指定重试次数）
HttpKit.HttpResponse response = httpKit.execute(request, 5);

// 使用快捷方法
HttpKit.HttpResponse getResponse = httpKit.get("https://api.example.com/users");
HttpKit.HttpResponse postResponse = httpKit.post("https://api.example.com/users", "{\"name\":\"John\"}");
```

## 4. 处理HTTP响应

### 4.1 基本响应处理

```java
HttpKit.HttpResponse response = httpKit.execute(request);

// 检查响应是否成功
if (response.isSuccess()) {
    System.out.println("请求成功");
} else {
    System.out.println("请求失败");
}

// 获取状态码
int statusCode = response.getStatusCode();

// 获取状态消息
String statusMessage = response.getStatusMessage();

// 获取响应体
String body = response.getBody();

// 获取响应头
String contentType = response.getHeader("Content-Type");
List<String> setCookies = response.getHeaders("Set-Cookie");
```

### 4.2 使用HttpStatus处理响应

```java
HttpKit.HttpResponse response = httpKit.execute(request);
HttpStatus status = HttpStatus.valueOf(response.getStatusCode());

// 根据状态码分类处理
if (status.isSuccess()) {
    System.out.println("成功: " + status.getReasonPhrase());
    processSuccessResponse(response);
} else if (status.isRedirect()) {
    System.out.println("重定向: " + status.getReasonPhrase());
    handleRedirect(response);
} else if (status.isClientError()) {
    System.out.println("客户端错误: " + status.getReasonPhrase());
    handleClientError(response);
} else if (status.isServerError()) {
    System.out.println("服务器错误: " + status.getReasonPhrase());
    handleServerError(response);
}

// 特定状态码处理
switch (status.getCode()) {
    case 200: // OK
        handleOk(response);
        break;
    case 201: // Created
        handleCreated(response);
        break;
    case 400: // Bad Request
        handleBadRequest(response);
        break;
    case 401: // Unauthorized
        handleUnauthorized(response);
        break;
    case 404: // Not Found
        handleNotFound(response);
        break;
    case 500: // Internal Server Error
        handleInternalServerError(response);
        break;
    default:
        handleUnknownStatus(response);
        break;
}
```

## 5. 高级功能

### 5.1 异步请求

```java
// 异步执行请求
httpKit.executeAsync(request, new HttpKit.HttpCallback() {
    @Override
    public void onSuccess(HttpKit.HttpResponse response) {
        // 处理成功响应
        System.out.println("请求成功: " + response.getStatusCode());
        processResponse(response);
    }

    @Override
    public void onError(Exception error) {
        // 处理错误
        System.err.println("请求失败: " + error.getMessage());
        handleError(error);
    }
});
```

### 5.2 表单数据提交

```java
// 提交表单数据
Map<String, String> formData = new HashMap<>();
formData.put("username", "john");
formData.put("password", "secret");
formData.put("remember", "true");

HttpKit.HttpResponse response = httpKit.postForm("https://api.example.com/login", formData);
```

### 5.3 带参数的GET请求

```java
// GET请求带查询参数
Map<String, String> queryParams = new HashMap<>();
queryParams.put("page", "1");
queryParams.put("size", "10");
queryParams.put("sort", "name");

HttpKit.HttpResponse response = httpKit.get("https://api.example.com/users", queryParams);
```

## 6. 实际应用示例

### 6.1 REST API客户端

```java
public class UserApiClient {
    private final HttpKit httpKit;
    private final String baseUrl;
    private final String authToken;

    public UserApiClient(String baseUrl, String authToken) {
        this.baseUrl = baseUrl;
        this.authToken = authToken;
        // 使用严格配置
        HttpConfig config = HttpConfig.strictConfig()
            .setMaxRetries(3)
            .setConnectTimeout(5000)
            .build();
        this.httpKit = HttpKit.getInstance(config);
    }

    public User createUser(User user) throws Exception {
        String url = baseUrl + "/users";
        String jsonBody = toJson(user);
        
        HttpKit.HttpRequest request = new HttpKit.HttpRequest(HttpMethod.POST, url);
        request.setBody(jsonBody);
        request.addHeader("Authorization", "Bearer " + authToken);
        request.addHeader("Content-Type", "application/json");
        
        HttpKit.HttpResponse response = httpKit.execute(request);
        HttpStatus status = HttpStatus.valueOf(response.getStatusCode());
        
        if (status == HttpStatus.CREATED) {
            return fromJson(response.getBody(), User.class);
        } else {
            throw new Exception("创建用户失败: " + status.getReasonPhrase());
        }
    }

    public User getUser(String userId) throws Exception {
        String url = baseUrl + "/users/" + userId;
        
        HttpKit.HttpRequest request = new HttpKit.HttpRequest(HttpMethod.GET, url);
        request.addHeader("Authorization", "Bearer " + authToken);
        
        HttpKit.HttpResponse response = httpKit.execute(request);
        HttpStatus status = HttpStatus.valueOf(response.getStatusCode());
        
        if (status == HttpStatus.OK) {
            return fromJson(response.getBody(), User.class);
        } else if (status == HttpStatus.NOT_FOUND) {
            return null; // 用户不存在
        } else {
            throw new Exception("获取用户失败: " + status.getReasonPhrase());
        }
    }

    public void updateUser(String userId, User user) throws Exception {
        String url = baseUrl + "/users/" + userId;
        String jsonBody = toJson(user);
        
        HttpKit.HttpRequest request = new HttpKit.HttpRequest(HttpMethod.PUT, url);
        request.setBody(jsonBody);
        request.addHeader("Authorization", "Bearer " + authToken);
        request.addHeader("Content-Type", "application/json");
        
        HttpKit.HttpResponse response = httpKit.execute(request);
        HttpStatus status = HttpStatus.valueOf(response.getStatusCode());
        
        if (status != HttpStatus.OK) {
            throw new Exception("更新用户失败: " + status.getReasonPhrase());
        }
    }

    public void deleteUser(String userId) throws Exception {
        String url = baseUrl + "/users/" + userId;
        
        HttpKit.HttpRequest request = new HttpKit.HttpRequest(HttpMethod.DELETE, url);
        request.addHeader("Authorization", "Bearer " + authToken);
        
        HttpKit.HttpResponse response = httpKit.execute(request);
        HttpStatus status = HttpStatus.valueOf(response.getStatusCode());
        
        if (status != HttpStatus.NO_CONTENT) {
            throw new Exception("删除用户失败: " + status.getReasonPhrase());
        }
    }

    private String toJson(Object obj) {
        // 实现JSON序列化
        return "{}";
    }

    private <T> T fromJson(String json, Class<T> clazz) {
        // 实现JSON反序列化
        return null;
    }
}
```

### 6.2 文件上传示例

```java
public class FileUploadClient {
    private final HttpKit httpKit;
    private final String uploadUrl;

    public FileUploadClient(String uploadUrl) {
        this.uploadUrl = uploadUrl;
        HttpConfig config = HttpConfig.builder()
            .setConnectTimeout(30000) // 较长的连接超时
            .setReadTimeout(60000)    // 较长的读取超时
            .setMaxRetries(2)
            .build();
        this.httpKit = HttpKit.getInstance(config);
    }

    public UploadResult uploadFile(String filePath, String fileName) throws Exception {
        // 读取文件内容
        String fileContent = readFileContent(filePath);
        
        // 构建请求
        HttpKit.HttpRequest request = new HttpKit.HttpRequest(HttpMethod.POST, uploadUrl);
        request.setBody(fileContent);
        request.addHeader("Content-Type", "application/octet-stream");
        request.addHeader("Content-Disposition", "attachment; filename=\"" + fileName + "\"");
        
        // 执行上传
        HttpKit.HttpResponse response = httpKit.execute(request);
        HttpStatus status = HttpStatus.valueOf(response.getStatusCode());
        
        if (status.isSuccess()) {
            return new UploadResult(true, response.getBody(), null);
        } else {
            return new UploadResult(false, null, "上传失败: " + status.getReasonPhrase());
        }
    }

    private String readFileContent(String filePath) throws IOException {
        // 实现文件读取逻辑
        return "";
    }
}
```

### 6.3 批量处理示例

```java
public class BatchProcessor {
    private final HttpKit httpKit;
    private final int batchSize;

    public BatchProcessor(int batchSize) {
        this.batchSize = batchSize;
        HttpConfig config = HttpConfig.builder()
            .setMaxRetries(3)
            .setRetryInterval(2000)
            .setFailOnServerError(false) // 允许部分失败
            .build();
        this.httpKit = HttpKit.getInstance(config);
    }

    public BatchResult processBatch(List<ApiRequest> requests) {
        BatchResult result = new BatchResult();
        List<ApiRequest> batch = new ArrayList<>();
        
        for (ApiRequest request : requests) {
            batch.add(request);
            
            // 达到批次大小或处理完所有请求时执行批次
            if (batch.size() >= batchSize || request == requests.get(requests.size() - 1)) {
                processBatchChunk(batch, result);
                batch.clear();
            }
        }
        
        return result;
    }

    private void processBatchChunk(List<ApiRequest> batch, BatchResult result) {
        for (ApiRequest apiRequest : batch) {
            try {
                HttpKit.HttpRequest request = createHttpRequest(apiRequest);
                HttpKit.HttpResponse response = httpKit.execute(request);
                
                HttpStatus status = HttpStatus.valueOf(response.getStatusCode());
                if (status.isSuccess()) {
                    result.addSuccess(apiRequest, response);
                } else {
                    result.addFailure(apiRequest, new Exception(status.getReasonPhrase()));
                }
            } catch (Exception e) {
                result.addFailure(apiRequest, e);
            }
        }
    }

    private HttpKit.HttpRequest createHttpRequest(ApiRequest apiRequest) {
        HttpMethod method = HttpMethod.fromString(apiRequest.getMethod());
        HttpKit.HttpRequest request = new HttpKit.HttpRequest(method, apiRequest.getUrl());
        
        if (apiRequest.getBody() != null) {
            request.setBody(apiRequest.getBody());
        }
        
        if (apiRequest.getHeaders() != null) {
            for (Map.Entry<String, String> header : apiRequest.getHeaders().entrySet()) {
                request.addHeader(header.getKey(), header.getValue());
            }
        }
        
        return request;
    }
}
```

## 7. 最佳实践

### 7.1 配置管理

```java
public class HttpClientFactory {
    public static HttpKit createProductionClient() {
        HttpConfig config = HttpConfig.strictConfig()
            .setMaxRetries(2)
            .setConnectTimeout(5000)
            .setReadTimeout(10000)
            .setFailOnServerError(true)
            .build();
        return HttpKit.getInstance(config);
    }

    public static HttpKit createTestClient() {
        HttpConfig config = HttpConfig.looseConfig()
            .setMaxRetries(5)
            .setConnectTimeout(10000)
            .build();
        return HttpKit.getInstance(config);
    }

    public static HttpKit createHighPerformanceClient() {
        HttpConfig config = HttpConfig.builder()
            .setMaxConnections(200)
            .setMaxConnectionsPerRoute(50)
            .setConnectTimeout(2000)
            .setReadTimeout(5000)
            .setMaxRetries(1)
            .build();
        return HttpKit.getInstance(config);
    }
}
```

### 7.2 错误处理

```java
public class RobustHttpClient {
    private final HttpKit httpKit;

    public RobustHttpClient() {
        HttpConfig config = HttpConfig.builder()
            .setMaxRetries(3)
            .setRetryInterval(1000)
            .setExponentialBackoff(true)
            .setFailOnServerError(false) // 允许重试
            .build();
        this.httpKit = HttpKit.getInstance(config);
    }

    public ApiResponse executeRequest(HttpKit.HttpRequest request) throws Exception {
        try {
            HttpKit.HttpResponse response = httpKit.execute(request);
            HttpStatus status = HttpStatus.valueOf(response.getStatusCode());
            
            // 处理特定状态码
            switch (status.getCode()) {
                case 429: // Too Many Requests
                    // 等待后重试
                    Thread.sleep(5000);
                    return executeRequest(request); // 递归重试
                    
                case 503: // Service Unavailable
                    // 服务不可用，稍后重试
                    Thread.sleep(10000);
                    return executeRequest(request);
                    
                default:
                    if (status.isSuccess()) {
                        return new ApiResponse(true, response.getBody(), null);
                    } else {
                        return new ApiResponse(false, null, status.getReasonPhrase());
                    }
            }
        } catch (Exception e) {
            // 记录错误日志
            System.err.println("HTTP请求失败: " + e.getMessage());
            throw e;
        }
    }
}
```

### 7.3 资源管理

```java
public class ManagedHttpClient implements AutoCloseable {
    private final HttpKit httpKit;

    public ManagedHttpClient() {
        HttpConfig config = HttpConfig.defaultConfig();
        this.httpKit = HttpKit.getInstance(config);
    }

    public HttpKit.HttpResponse execute(HttpKit.HttpRequest request) throws Exception {
        return httpKit.execute(request);
    }

    @Override
    public void close() {
        // 关闭HttpKit，释放资源
        httpKit.close();
    }

    // 使用示例
    public static void main(String[] args) {
        try (ManagedHttpClient client = new ManagedHttpClient()) {
            HttpKit.HttpRequest request = new HttpKit.HttpRequest(HttpMethod.GET, "https://api.example.com/users");
            HttpKit.HttpResponse response = client.execute(request);
            System.out.println("响应: " + response.getBody());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

通过以上详细的使用说明，您可以充分利用 [HttpKit](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\util\http\HttpKit.java#L31-L489)
及其配套工具类 [HttpConfig](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\util\http\HttpConfig.java#L15-L351)、[HttpMethod](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\util\http\HttpMethod.java#L14-L175)
和 [HttpStatus](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\util\http\HttpStatus.java#L22-L424) 构建强大、可靠的HTTP客户端应用。