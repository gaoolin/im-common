# HTTP 响应处理系统使用文档

## 1. 概述

HTTP 响应处理系统是一套完整的 HTTP 响应处理解决方案，包含响应实体、处理器、拦截器、工厂类和验证器等组件。该系统具有以下特性：

- **通用性**：支持所有 HTTP 响应类型处理
- **规范性**：遵循 HTTP 协议和行业标准
- **专业性**：提供丰富的响应处理能力
- **灵活性**：支持自定义处理逻辑
- **可靠性**：具备完善的错误处理机制
- **安全性**：包含响应安全验证功能
- **复用性**：模块化设计，组件可独立使用
- **容错性**：提供优雅的错误恢复机制

## 2. 核心组件

### 2.1 HttpResponse - 响应实体类

[HttpResponse](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\util\http\response\HttpResponse.java#L1-L6) 是 HTTP 响应的核心实体类，包含响应的所有信息。

#### 2.1.1 创建 HttpResponse

```java
// 使用构建器创建响应
HttpResponse response=HttpResponse.builder()
        .statusCode(200)
        .statusMessage("OK")
        .body("{\"name\":\"John\",\"age\":30}")
        .addHeader("Content-Type","application/json")
        .addHeader("Server","Apache")
        .responseTime(LocalDateTime.now())
        .responseDuration(150) // 响应耗时150ms
        .protocol("HTTP/1.1")
        .build();
```

#### 2.1.2 响应信息获取

```java
// 基本信息获取
int statusCode=response.getStatusCode();           // 200
        String statusMessage=response.getStatusMessage(); // "OK"
        LocalDateTime responseTime=response.getResponseTime(); // 响应时间
        long duration=response.getResponseDuration();     // 响应耗时

// 状态码判断
        boolean isSuccess=response.isSuccess();     // true
        boolean isRedirect=response.isRedirect();   // false
        boolean isClientError=response.isClientError(); // false
        boolean isServerError=response.isServerError(); // false
        boolean isError=response.isError();         // false

// 响应头操作
        Map<String, List<String>>headers=response.getHeaders(); // 获取所有响应头
        String contentType=response.getHeader("Content-Type");   // "application/json"
        List<String> setCookies=response.getHeaders("Set-Cookie"); // 获取所有Set-Cookie头

// 响应体操作
        byte[]bodyBytes=response.getBodyAsBytes();  // 获取字节数组形式的响应体
        String bodyString=response.getBodyAsString(); // 获取字符串形式的响应体
        int bodyLength=response.getBodyLength();     // 响应体长度

// 内容类型判断
        boolean isJson=response.isJson();  // true
        boolean isXml=response.isXml();    // false
        boolean isHtml=response.isHtml();  // false
        boolean isText=response.isText();  // false
```

### 2.2 ResponseHandler - 响应处理器接口

[ResponseHandler](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\util\http\response\ResponseHandler.java#L1-L6) 是响应处理器的接口，定义了处理响应的标准方法。

#### 2.2.1 JsonResponseHandler - JSON响应处理器

[JsonResponseHandler](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\util\http\handler\JsonResponseHandler.java#L1-L6) 是专门处理 JSON 响应的处理器。

```java
// 创建JSON响应处理器
JsonResponseHandler jsonHandler=new JsonResponseHandler();

// 或者自定义配置
        ObjectMapper customMapper=new ObjectMapper();
        JsonResponseHandler customJsonHandler=new JsonResponseHandler(customMapper,5*1024*1024); // 5MB限制

// 处理JSON响应
        HttpResponse jsonResponse=HttpResponse.builder()
        .statusCode(200)
        .body("{\"users\":[{\"id\":1,\"name\":\"John\"},{\"id\":2,\"name\":\"Jane\"}]}")
        .addHeader("Content-Type","application/json")
        .build();

        try{
        JsonNode jsonNode=jsonHandler.handle(jsonResponse);

        // 访问JSON数据
        JsonNode usersNode=jsonNode.get("users");
        if(usersNode!=null&&usersNode.isArray()){
        for(JsonNode userNode:usersNode){
        int id=userNode.get("id").asInt();
        String name=userNode.get("name").asText();
        System.out.println("User: "+id+" - "+name);
        }
        }
        }catch(ResponseHandlingException e){
        System.err.println("JSON处理失败: "+e.getMessage());
        System.err.println("错误类型: "+e.getErrorType());
        }
```

#### 2.2.2 自定义响应处理器

```java
// 实现自定义响应处理器
public class XmlResponseHandler implements ResponseHandler<Document> {
    private final DocumentBuilder documentBuilder;

    public XmlResponseHandler() throws ParserConfigurationException {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        this.documentBuilder = factory.newDocumentBuilder();
    }

    @Override
    public Document handle(HttpResponse response) throws ResponseHandlingException {
        if (!canHandle(response)) {
            throw new ResponseHandlingException(
                    "Response is not XML",
                    response,
                    ResponseHandlingException.ErrorType.UNSUPPORTED_CONTENT_TYPE
            );
        }

        try {
            ByteArrayInputStream inputStream = new ByteArrayInputStream(response.getBodyAsBytes());
            return documentBuilder.parse(inputStream);
        } catch (Exception e) {
            throw new ResponseHandlingException(
                    "Failed to parse XML response",
                    e,
                    response,
                    ResponseHandlingException.ErrorType.PARSING_ERROR
            );
        }
    }

    @Override
    public boolean canHandle(HttpResponse response) {
        return response.isXml();
    }

    @Override
    public String getName() {
        return "XmlResponseHandler";
    }
}
```

### 2.3 ResponseInterceptor - 响应拦截器

[ResponseInterceptor](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\util\http\response\ResponseInterceptor.java#L1-L6) 允许在响应处理前后执行自定义逻辑。

#### 2.3.1 日志拦截器示例

```java
public class LoggingResponseInterceptor implements ResponseInterceptor {
    private static final Logger logger = LoggerFactory.getLogger(LoggingResponseInterceptor.class);

    @Override
    public HttpResponse preHandle(HttpResponse response) throws ResponseHandlingException {
        logger.info("开始处理响应: {} {}", response.getStatusCode(), response.getStatusMessage());
        logger.debug("响应头: {}", response.getHeaders());
        return response; // 返回原始响应或修改后的响应
    }

    @Override
    public <T> T postHandle(HttpResponse response, T result) throws ResponseHandlingException {
        logger.info("响应处理完成，结果类型: {}", result != null ? result.getClass().getSimpleName() : "null");
        return result;
    }

    @Override
    public void afterCompletion(HttpResponse response) {
        logger.info("响应处理链完成，耗时: {}ms", response.getResponseDuration());
    }

    @Override
    public int getPriority() {
        return 10; // 优先级较低
    }

    @Override
    public String getName() {
        return "LoggingResponseInterceptor";
    }
}
```

#### 2.3.2 缓存拦截器示例

```java
public class CachingResponseInterceptor implements ResponseInterceptor {
    private final Map<String, CachedResponse> cache = new ConcurrentHashMap<>();
    private final long cacheTimeout = 5 * 60 * 1000; // 5分钟缓存

    @Override
    public HttpResponse preHandle(HttpResponse response) throws ResponseHandlingException {
        String cacheKey = generateCacheKey(response);

        // 检查缓存
        CachedResponse cached = cache.get(cacheKey);
        if (cached != null && !isExpired(cached)) {
            // 返回缓存的响应
            return cached.getResponse();
        }

        return response;
    }

    @Override
    public <T> T postHandle(HttpResponse response, T result) throws ResponseHandlingException {
        String cacheKey = generateCacheKey(response);

        // 缓存响应
        if (response.isSuccess() && response.isCacheable()) {
            cache.put(cacheKey, new CachedResponse(response, System.currentTimeMillis()));
        }

        return result;
    }

    @Override
    public void afterCompletion(HttpResponse response) {
        // 清理过期缓存
        cleanupExpiredCache();
    }

    private String generateCacheKey(HttpResponse response) {
        // 生成缓存键的逻辑
        return response.getStatusCode() + ":" + response.getHeader("ETag");
    }

    private boolean isExpired(CachedResponse cachedResponse) {
        return System.currentTimeMillis() - cachedResponse.getTimestamp() > cacheTimeout;
    }

    private void cleanupExpiredCache() {
        long now = System.currentTimeMillis();
        cache.entrySet().removeIf(entry ->
                now - entry.getValue().getTimestamp() > cacheTimeout);
    }

    @Override
    public int getPriority() {
        return 5; // 较高优先级
    }

    @Override
    public String getName() {
        return "CachingResponseInterceptor";
    }

    // 缓存响应包装类
    private static class CachedResponse {
        private final HttpResponse response;
        private final long timestamp;

        public CachedResponse(HttpResponse response, long timestamp) {
            this.response = response;
            this.timestamp = timestamp;
        }

        public HttpResponse getResponse() {
            return response;
        }

        public long getTimestamp() {
            return timestamp;
        }
    }
}
```

### 2.4 HttpResponseFactory - 响应工厂类

[HttpResponseFactory](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\util\http\response\HttpResponseFactory.java#L1-L6) 提供了创建常见类型响应的便捷方法。

#### 2.4.1 使用工厂类创建响应

```java
// 创建成功响应
HttpResponse successResponse=HttpResponseFactory.createSuccessResponse("Operation completed successfully");

// 创建JSON响应
        HttpResponse jsonResponse=HttpResponseFactory.createJsonResponse(200,"{\"status\":\"success\",\"data\":{}}");

// 创建错误响应
        HttpResponse errorResponse=HttpResponseFactory.createErrorResponse(404,"Resource not found");

// 创建重定向响应
        HttpResponse redirectResponse=HttpResponseFactory.createRedirectResponse("https://new-location.com");

// 从现有数据创建响应
        Map<String, List<String>>headers=new HashMap<>();
        headers.put("Content-Type",Arrays.asList("application/json"));
        HttpResponse customResponse=HttpResponseFactory.createResponse(
        200,
        "OK",
        headers,
        "{\"message\":\"hello\"}".getBytes(StandardCharsets.UTF_8),
        120 // 响应耗时
        );
```

### 2.5 ResponseValidator - 响应验证器

[ResponseValidator](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\util\http\response\ResponseValidator.java#L1-L6) 用于验证响应的合规性和安全性。

#### 2.5.1 响应验证示例

```java
// 创建验证器
HttpConfig config=HttpConfig.defaultConfig();
        ResponseValidator validator=new ResponseValidator(config);

// 验证响应
        HttpResponse response=HttpResponse.builder()
        .statusCode(200)
        .body("{\"data\":\"sensitive information\"}")
        .addHeader("Content-Type","application/json")
        .addHeader("Authorization","Bearer secret-token") // 敏感头
        .build();

        ResponseValidator.ValidationResult result=validator.validate(response);

// 检查验证结果
        if(result.isValid()){
        System.out.println("响应验证通过");
        }else{
        System.err.println("响应验证失败:");
        result.getErrors().forEach(System.err::println);
        }

        if(result.hasWarnings()){
        System.out.println("响应警告:");
        result.getWarnings().forEach(System.out::println);
        }

// 输出所有验证信息
        System.out.println("验证成功项:");
        result.getSuccesses().forEach(System.out::println);
```

## 3. 高级使用示例

### 3.1 完整的响应处理链

```java
public class ResponseProcessingChain {
    private final List<ResponseInterceptor> interceptors;
    private final Map<String, ResponseHandler<?>> handlers;

    public ResponseProcessingChain() {
        this.interceptors = new ArrayList<>();
        this.handlers = new HashMap<>();

        // 注册拦截器（按优先级排序）
        interceptors.add(new LoggingResponseInterceptor());
        interceptors.add(new CachingResponseInterceptor());
        interceptors.sort(Comparator.comparingInt(ResponseInterceptor::getPriority));

        // 注册处理器
        try {
            handlers.put("json", new JsonResponseHandler());
            handlers.put("xml", new XmlResponseHandler());
        } catch (Exception e) {
            throw new RuntimeException("Failed to initialize handlers", e);
        }
    }

    public <T> T processResponse(HttpResponse response, Class<T> resultType)
            throws ResponseHandlingException {

        // 预处理阶段
        HttpResponse processedResponse = response;
        for (ResponseInterceptor interceptor : interceptors) {
            processedResponse = interceptor.preHandle(processedResponse);
            if (processedResponse == null) {
                // 拦截器中断处理
                return null;
            }
        }

        // 处理阶段
        T result = null;
        ResponseHandler<T> handler = findHandler(processedResponse, resultType);
        if (handler != null) {
            result = handler.handle(processedResponse);
        }

        // 后处理阶段
        Object finalResult = result;
        for (ResponseInterceptor interceptor : interceptors) {
            try {
                finalResult = interceptor.postHandle(processedResponse, finalResult);
            } catch (ResponseHandlingException e) {
                // 记录错误但继续执行其他拦截器
                System.err.println("Interceptor " + interceptor.getName() + " postHandle failed: " + e.getMessage());
            }
        }

        // 完成阶段
        for (ResponseInterceptor interceptor : interceptors) {
            try {
                interceptor.afterCompletion(processedResponse);
            } catch (Exception e) {
                System.err.println("Interceptor " + interceptor.getName() + " afterCompletion failed: " + e.getMessage());
            }
        }

        return (T) finalResult;
    }

    @SuppressWarnings("unchecked")
    private <T> ResponseHandler<T> findHandler(HttpResponse response, Class<T> resultType) {
        // 根据响应类型和期望结果类型查找合适的处理器
        if (response.isJson() && resultType == JsonNode.class) {
            return (ResponseHandler<T>) handlers.get("json");
        }

        if (response.isXml() && resultType == Document.class) {
            return (ResponseHandler<T>) handlers.get("xml");
        }

        return null;
    }
}
```

### 3.2 与 HttpKit 集成使用

```java
public class EnhancedHttpClient {
    private final HttpKit httpKit;
    private final ResponseProcessingChain processingChain;
    private final ResponseValidator validator;

    public EnhancedHttpClient() {
        this.httpKit = HttpKit.getInstance();
        this.processingChain = new ResponseProcessingChain();
        this.validator = new ResponseValidator(HttpConfig.defaultConfig());
    }

    public <T> T executeRequest(HttpKit.HttpRequest request, Class<T> responseType)
            throws Exception {

        // 执行HTTP请求
        HttpResponse response = httpKit.execute(request);

        // 验证响应
        ResponseValidator.ValidationResult validationResult = validator.validate(response);
        if (!validationResult.isValid()) {
            throw new Exception("Response validation failed: " + validationResult.getErrors());
        }

        // 处理响应
        return processingChain.processResponse(response, responseType);
    }

    // 使用示例
    public void example() throws Exception {
        // 创建请求
        HttpKit.HttpRequest request = new HttpKit.HttpRequest(
                HttpMethod.GET,
                "https://api.example.com/users"
        );
        request.addHeader("Accept", "application/json");

        // 执行请求并处理JSON响应
        JsonNode jsonResult = executeRequest(request, JsonNode.class);
        System.out.println("用户数据: " + jsonResult.toPrettyString());
    }
}
```

### 3.3 响应监控和统计

```java
public class ResponseMetricsInterceptor implements ResponseInterceptor {
    private final AtomicLong totalResponses = new AtomicLong(0);
    private final AtomicLong successfulResponses = new AtomicLong(0);
    private final AtomicLong errorResponses = new AtomicLong(0);
    private final AtomicLong totalResponseTime = new AtomicLong(0);
    private final AtomicLong maxResponseTime = new AtomicLong(0);

    @Override
    public HttpResponse preHandle(HttpResponse response) throws ResponseHandlingException {
        totalResponses.incrementAndGet();

        if (response.isSuccess()) {
            successfulResponses.incrementAndGet();
        } else {
            errorResponses.incrementAndGet();
        }

        long duration = response.getResponseDuration();
        totalResponseTime.addAndGet(duration);

        // 更新最大响应时间
        maxResponseTime.accumulateAndGet(duration, Math::max);

        return response;
    }

    @Override
    public <T> T postHandle(HttpResponse response, T result) throws ResponseHandlingException {
        return result;
    }

    @Override
    public void afterCompletion(HttpResponse response) {
        // 可以在这里记录统计信息到日志或监控系统
        logMetrics();
    }

    private void logMetrics() {
        long total = totalResponses.get();
        if (total > 0) {
            double avgResponseTime = (double) totalResponseTime.get() / total;
            double successRate = (double) successfulResponses.get() / total * 100;

            System.out.printf("响应统计 - 总数: %d, 成功: %d (%.2f%%), 平均耗时: %.2fms, 最大耗时: %dms%n",
                    total, successfulResponses.get(), successRate, avgResponseTime, maxResponseTime.get());
        }
    }

    // 获取统计信息
    public ResponseMetrics getMetrics() {
        long total = totalResponses.get();
        return new ResponseMetrics(
                total,
                successfulResponses.get(),
                errorResponses.get(),
                total > 0 ? (double) totalResponseTime.get() / total : 0,
                maxResponseTime.get()
        );
    }

    @Override
    public int getPriority() {
        return 100; // 最低优先级
    }

    @Override
    public String getName() {
        return "ResponseMetricsInterceptor";
    }

    // 统计数据类
    public static class ResponseMetrics {
        private final long totalResponses;
        private final long successfulResponses;
        private final long errorResponses;
        private final double averageResponseTime;
        private final long maxResponseTime;

        public ResponseMetrics(long totalResponses, long successfulResponses,
                               long errorResponses, double averageResponseTime,
                               long maxResponseTime) {
            this.totalResponses = totalResponses;
            this.successfulResponses = successfulResponses;
            this.errorResponses = errorResponses;
            this.averageResponseTime = averageResponseTime;
            this.maxResponseTime = maxResponseTime;
        }

        // Getters
        public long getTotalResponses() {
            return totalResponses;
        }

        public long getSuccessfulResponses() {
            return successfulResponses;
        }

        public long getErrorResponses() {
            return errorResponses;
        }

        public double getAverageResponseTime() {
            return averageResponseTime;
        }

        public long getMaxResponseTime() {
            return maxResponseTime;
        }

        public double getSuccessRate() {
            return totalResponses > 0 ? (double) successfulResponses / totalResponses * 100 : 0;
        }
    }
}
```

## 4. 最佳实践

### 4.1 响应处理最佳实践

1. **始终验证响应**：在处理响应前使用 [ResponseValidator](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\util\http\response\ResponseValidator.java#L1-L6) 验证响应的合规性
2. **合理使用拦截器**：根据业务需求添加适当的拦截器，如日志、缓存、监控等
3. **异常处理**：妥善处理 [ResponseHandlingException](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\util\http\response\ResponseHandlingException.java#L1-L6)
   ，提供友好的错误信息
4. **资源管理**：及时释放响应相关的资源，避免内存泄漏
5. **性能优化**：对大响应体设置合理的大小限制，避免内存溢出

### 4.2 安全最佳实践

1. **敏感信息处理**：避免在日志中记录敏感响应头和响应体
2. **内容安全检查**：使用验证器检查潜在的安全风险，如 XSS 攻击
3. **响应大小限制**：设置合理的响应大小限制，防止拒绝服务攻击
4. **内容类型验证**：验证响应的内容类型是否符合预期

### 4.3 性能最佳实践

1. **缓存策略**：对可缓存的响应实施合适的缓存策略
2. **异步处理**：对于耗时的响应处理操作，考虑使用异步处理
3. **连接复用**：合理配置连接池参数，提高连接复用率
4. **压缩支持**：启用 GZIP 压缩以减少网络传输时间

通过以上详细的使用文档，您可以充分利用 HTTP 响应处理系统的各项功能，构建强大、安全、高效的 HTTP 客户端应用。