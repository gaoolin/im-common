# ErpConnector 使用说明文档

## 1. 概述

[ErpConnector](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\semiconductor\integration\erp\ErpConnector.java#L34-L1581) 是一个专业的ERP（企业资源规划）系统连接工具类，专门为半导体封测行业与ERP系统的数据交互设计。该工具解决了与ERP系统集成复杂、业务数据流转不顺畅、订单状态更新不及时和财务数据准确性难保证等问题。

## 2. 核心功能

### 2.1 订单状态同步
- 实时同步生产订单状态到ERP系统
- 支持多种订单状态类型
- 提供状态变更确认机制

### 2.2 生产计划接收
- 从ERP系统接收生产计划
- 转换为内部生产任务
- 支持计划变更和更新

### 2.3 成本数据上报
- 上报生产成本数据到ERP
- 支持多种成本类型分类
- 提供成本核算功能

### 2.4 库存信息同步
- 同步实时库存信息到ERP
- 支持多种库存类型管理
- 提供库存预警功能

## 3. 支持的ERP系统类型和数据类型

### 3.1 ERP系统类型
```java
public enum ErpType {
    SAP("SAP ERP", "SAP ERP"),
    ORACLE_EBS("Oracle EBS", "Oracle E-Business Suite"),
    MICROSOFT_DYNAMICS("Microsoft Dynamics", "Microsoft Dynamics 365"),
    KINGDEE("金蝶云", "Kingdee Cloud"),
    YONYOU("用友NC", "Yonyou NC"),
    CUSTOM("自定义ERP", "Custom ERP")
}
```


### 3.2 订单状态类型
```java
public enum OrderStatus {
    CREATED("已创建", 1),
    CONFIRMED("已确认", 2),
    IN_PRODUCTION("生产中", 3),
    PARTIALLY_COMPLETED("部分完成", 4),
    COMPLETED("已完成", 5),
    CANCELLED("已取消", 6),
    ON_HOLD("挂起", 7),
    SHIPPED("已发货", 8),
    DELIVERED("已交付", 9)
}
```


### 3.3 成本类型
```java
public enum CostType {
    MATERIAL("材料成本", "Material Cost"),
    LABOR("人工成本", "Labor Cost"),
    OVERHEAD("制造费用", "Overhead Cost"),
    EQUIPMENT("设备折旧", "Equipment Depreciation"),
    QUALITY("质量成本", "Quality Cost"),
    CUSTOM("自定义成本", "Custom Cost")
}
```


### 3.4 库存类型
```java
public enum InventoryType {
    RAW_MATERIAL("原材料", "Raw Material"),
    WORK_IN_PROGRESS("在制品", "Work In Progress"),
    FINISHED_GOOD("成品", "Finished Good"),
    CONSUMABLE("耗材", "Consumable"),
    PACKAGING_MATERIAL("包装材料", "Packaging Material")
}
```


## 4. 基本使用方法

### 4.1 初始化和配置

```java
// 初始化ERP连接器
public class ErpConnectorSetup {
    public void setupErpConnection() {
        System.out.println("初始化ERP连接器...");
        
        // 设置当前使用的ERP类型
        ErpConnector.setCurrentEngine(ErpConnector.ErpType.CUSTOM);
        
        // 设置当前订单状态同步器
        ErpConnector.setCurrentSynchronizer(ErpConnector.OrderStatus.CREATED);
        
        // 设置当前生产计划接收器
        ErpConnector.setCurrentReceiver(ErpConnector.PlanStatus.DRAFT);
        
        // 设置当前成本数据上报器
        ErpConnector.setCurrentReporter(ErpConnector.CostType.CUSTOM);
        
        // 设置当前库存数据同步器
        ErpConnector.setCurrentInventorySynchronizer(ErpConnector.InventoryType.RAW_MATERIAL);
        
        System.out.println("ERP连接器初始化完成");
        
        // 获取连接统计信息
        ErpConnector.ConnectionStatistics connectionStats = ErpConnector.getConnectionStatistics();
        System.out.println("连接状态: " + (connectionStats.isConnected() ? "已连接" : "未连接"));
        System.out.println("连接信息: " + connectionStats.getConnectionInfo());
    }
}
```


### 4.2 订单状态同步

```java
// 同步订单状态
public class OrderStatusSyncExample {
    public void syncOrderStatuses() {
        System.out.println("开始订单状态同步示例...");
        
        // 1. 同步订单状态到"生产中"
        String orderId1 = "ORDER-20250821-001";
        boolean synced1 = ErpConnector.syncOrderStatus(orderId1, ErpConnector.OrderStatus.IN_PRODUCTION);
        
        System.out.println("订单 " + orderId1 + " 状态同步到'生产中': " + (synced1 ? "成功" : "失败"));
        
        // 2. 同步订单状态到"已完成"
        String orderId2 = "ORDER-20250821-002";
        boolean synced2 = ErpConnector.syncOrderStatus(orderId2, ErpConnector.OrderStatus.COMPLETED);
        
        System.out.println("订单 " + orderId2 + " 状态同步到'已完成': " + (synced2 ? "成功" : "失败"));
        
        // 3. 同步订单状态到"已取消"
        String orderId3 = "ORDER-20250821-003";
        boolean synced3 = ErpConnector.syncOrderStatus(orderId3, ErpConnector.OrderStatus.CANCELLED);
        
        System.out.println("订单 " + orderId3 + " 状态同步到'已取消': " + (synced3 ? "成功" : "失败"));
        
        // 4. 批量同步订单状态
        Map<String, ErpConnector.OrderStatus> batchStatuses = new HashMap<>();
        batchStatuses.put("ORDER-20250821-004", ErpConnector.OrderStatus.CONFIRMED);
        batchStatuses.put("ORDER-20250821-005", ErpConnector.OrderStatus.IN_PRODUCTION);
        batchStatuses.put("ORDER-20250821-006", ErpConnector.OrderStatus.PARTIALLY_COMPLETED);
        
        Map<String, Boolean> batchResults = ErpConnector.syncBatchOrderStatus(batchStatuses);
        
        System.out.println("批量订单状态同步结果:");
        batchResults.forEach((orderId, result) -> 
            System.out.println("  " + orderId + ": " + (result ? "成功" : "失败")));
    }
    
    // 创建订单示例
    public void createOrders() {
        System.out.println("\n创建订单示例...");
        
        // 创建订单
        ErpConnector.Order order1 = ErpConnector.createOrder(
            "ORDER-20250821-001", 
            "CUST-001", 
            "客户A公司"
        );
        
        if (order1 != null) {
            // 添加订单项
            ErpConnector.OrderItem item1 = new ErpConnector.OrderItem(
                null, "PROD-001", "产品A", 1000
            );
            item1.setUnitPrice(new BigDecimal("10.50"))
                 .setUnit("PCS");
            
            order1.addItem(item1)
                 .setTotalAmount(new BigDecimal("10500.00"))
                 .setDeliveryDate(LocalDateTime.now().plusDays(7));
            
            System.out.println("创建订单成功: " + order1.getOrderId());
            System.out.println("  客户代码: " + order1.getCustomerCode());
            System.out.println("  客户名称: " + order1.getCustomerName());
            System.out.println("  订单项数: " + order1.getItems().size());
            System.out.println("  总金额: " + order1.getTotalAmount());
        }
        
        // 创建另一个订单
        ErpConnector.Order order2 = ErpConnector.createOrder(
            "ORDER-20250821-002", 
            "CUST-002", 
            "客户B公司"
        );
        
        if (order2 != null) {
            ErpConnector.OrderItem item2 = new ErpConnector.OrderItem(
                null, "PROD-002", "产品B", 500
            );
            item2.setUnitPrice(new BigDecimal("15.75"))
                 .setUnit("PCS");
            
            order2.addItem(item2)
                 .setTotalAmount(new BigDecimal("7875.00"))
                 .setDeliveryDate(LocalDateTime.now().plusDays(10));
            
            System.out.println("创建订单成功: " + order2.getOrderId());
        }
    }
}
```


### 4.3 生产计划接收

```java
// 接收生产计划
public class ProductionPlanReceivingExample {
    public void receiveProductionPlans() {
        System.out.println("开始生产计划接收示例...");
        
        // 1. 创建ERP计划
        ErpConnector.ErpPlan erpPlan = ErpConnector.createErpPlan(
            "PLAN-20250821-001",
            "PROD-001",
            "产品A",
            1000
        );
        
        if (erpPlan != null) {
            // 添加计划项
            ErpConnector.PlanItem planItem1 = new ErpConnector.PlanItem(
                null, "MAT-001", "原材料A", 1000
            );
            planItem1.setUnit("KG");
            
            ErpConnector.PlanItem planItem2 = new ErpConnector.PlanItem(
                null, "MAT-002", "原材料B", 500
            );
            planItem2.setUnit("PCS");
            
            erpPlan.addItem(planItem1)
                  .addItem(planItem2)
                  .setStartDate(LocalDateTime.now().plusHours(2))
                  .setEndDate(LocalDateTime.now().plusDays(2))
                  .setProductionLine("LINE-A")
                  .setStatus(ErpConnector.PlanStatus.APPROVED);
            
            System.out.println("创建ERP计划成功: " + erpPlan.getPlanId());
            System.out.println("  产品ID: " + erpPlan.getProductId());
            System.out.println("  产品名称: " + erpPlan.getProductName());
            System.out.println("  计划数量: " + erpPlan.getPlannedQuantity());
            System.out.println("  计划项数: " + erpPlan.getItems().size());
            System.out.println("  开始时间: " + erpPlan.getStartDate());
            System.out.println("  结束时间: " + erpPlan.getEndDate());
            System.out.println("  生产线: " + erpPlan.getProductionLine());
            System.out.println("  状态: " + erpPlan.getStatus().getDescription());
            
            // 2. 接收生产计划
            ErpConnector.ProductionPlan productionPlan = ErpConnector.receiveProductionPlan(erpPlan);
            
            if (productionPlan != null) {
                System.out.println("接收生产计划成功: " + productionPlan.getPlanId());
                System.out.println("  任务数: " + productionPlan.getTasks().size());
                System.out.println("  状态: " + productionPlan.getStatus().getDescription());
                
                // 显示生产任务
                for (ErpConnector.ProductionTask task : productionPlan.getTasks()) {
                    System.out.println("    任务ID: " + task.getTaskId());
                    System.out.println("    工艺步骤: " + task.getProcessStep());
                    System.out.println("    计划数量: " + task.getPlannedQuantity());
                }
            } else {
                System.err.println("接收生产计划失败");
            }
        }
        
        // 3. 创建另一个ERP计划
        ErpConnector.ErpPlan erpPlan2 = ErpConnector.createErpPlan(
            "PLAN-20250821-002",
            "PROD-002",
            "产品B",
            500
        );
        
        if (erpPlan2 != null) {
            erpPlan2.setStartDate(LocalDateTime.now().plusHours(24))
                   .setEndDate(LocalDateTime.now().plusDays(3))
                   .setProductionLine("LINE-B")
                   .setStatus(ErpConnector.PlanStatus.APPROVED);
            
            ErpConnector.ProductionPlan productionPlan2 = ErpConnector.receiveProductionPlan(erpPlan2);
            
            if (productionPlan2 != null) {
                System.out.println("接收生产计划成功: " + productionPlan2.getPlanId());
            }
        }
    }
}
```


### 4.4 成本数据上报

```java
// 上报成本数据
public class CostDataReportingExample {
    public void reportCostData() {
        System.out.println("开始成本数据上报示例...");
        
        // 1. 创建并上报材料成本
        ErpConnector.CostData materialCost = ErpConnector.createCostData(
            "PROD-001",
            ErpConnector.CostType.MATERIAL,
            new BigDecimal("5000.00")
        );
        
        if (materialCost != null) {
            materialCost.setCostCenter("CC-001")
                       .setBatchId("BATCH-20250821-001")
                       .setAttribute("supplier", "供应商A")
                       .setAttribute("material_type", "原材料");
            
            boolean reported1 = ErpConnector.reportCostData(materialCost);
            System.out.println("材料成本上报: " + (reported1 ? "成功" : "失败"));
            System.out.println("  成本ID: " + materialCost.getCostId());
            System.out.println("  产品ID: " + materialCost.getProductId());
            System.out.println("  成本类型: " + materialCost.getCostType().getChineseName());
            System.out.println("  金额: " + materialCost.getAmount() + " " + materialCost.getCurrency());
            System.out.println("  成本中心: " + materialCost.getCostCenter());
            System.out.println("  批次号: " + materialCost.getBatchId());
        }
        
        // 2. 创建并上报人工成本
        ErpConnector.CostData laborCost = ErpConnector.createCostData(
            "PROD-001",
            ErpConnector.CostType.LABOR,
            new BigDecimal("2000.00")
        );
        
        if (laborCost != null) {
            laborCost.setCostCenter("CC-001")
                    .setBatchId("BATCH-20250821-001")
                    .setAttribute("shift", "早班")
                    .setAttribute("operator_count", 10);
            
            boolean reported2 = ErpConnector.reportCostData(laborCost);
            System.out.println("人工成本上报: " + (reported2 ? "成功" : "失败"));
        }
        
        // 3. 创建并上报制造费用
        ErpConnector.CostData overheadCost = ErpConnector.createCostData(
            "PROD-001",
            ErpConnector.CostType.OVERHEAD,
            new BigDecimal("1500.00")
        );
        
        if (overheadCost != null) {
            overheadCost.setCostCenter("CC-001")
                       .setBatchId("BATCH-20250821-001")
                       .setAttribute("utility_type", "电力")
                       .setAttribute("consumption", "1000KWH");
            
            boolean reported3 = ErpConnector.reportCostData(overheadCost);
            System.out.println("制造费用上报: " + (reported3 ? "成功" : "失败"));
        }
        
        // 4. 批量上报成本数据
        List<ErpConnector.CostData> costDataList = new ArrayList<>();
        
        // 添加更多成本数据
        ErpConnector.CostData equipmentCost = ErpConnector.createCostData(
            "PROD-001",
            ErpConnector.CostType.EQUIPMENT,
            new BigDecimal("800.00")
        );
        if (equipmentCost != null) {
            equipmentCost.setBatchId("BATCH-20250821-001");
            costDataList.add(equipmentCost);
        }
        
        ErpConnector.CostData qualityCost = ErpConnector.createCostData(
            "PROD-001",
            ErpConnector.CostType.QUALITY,
            new BigDecimal("500.00")
        );
        if (qualityCost != null) {
            qualityCost.setBatchId("BATCH-20250821-001");
            costDataList.add(qualityCost);
        }
        
        List<ErpConnector.SyncResult> batchResults = ErpConnector.reportBatchCostData(costDataList);
        
        System.out.println("批量成本数据上报结果:");
        for (int i = 0; i < batchResults.size(); i++) {
            ErpConnector.SyncResult result = batchResults.get(i);
            System.out.println("  成本数据 " + (i+1) + ": " + 
                             (result.isSuccess() ? "成功" : "失败") + 
                             " - " + result.getMessage());
        }
    }
}
```


### 4.5 库存信息同步

```java
// 同步库存信息
public class InventoryDataSyncExample {
    public void syncInventoryData() {
        System.out.println("开始库存信息同步示例...");
        
        // 1. 创建并同步原材料库存
        ErpConnector.InventoryData rawMaterialInventory = ErpConnector.createInventoryData(
            "MAT-001",
            "原材料A"
        );
        
        if (rawMaterialInventory != null) {
            rawMaterialInventory.setInventoryType(ErpConnector.InventoryType.RAW_MATERIAL)
                              .setQuantity(5000)
                              .setReservedQuantity(1000)
                              .setAvailableQuantity(4000)
                              .setUnit("KG")
                              .setWarehouse("WH-001")
                              .setLocation("A区-01货架")
                              .setAttribute("supplier", "供应商A")
                              .setAttribute("last_purchase_date", "2025-08-20");
            
            boolean synced1 = ErpConnector.syncInventoryData(rawMaterialInventory);
            System.out.println("原材料库存同步: " + (synced1 ? "成功" : "失败"));
            System.out.println("  库存ID: " + rawMaterialInventory.getInventoryId());
            System.out.println("  产品ID: " + rawMaterialInventory.getProductId());
            System.out.println("  产品名称: " + rawMaterialInventory.getProductName());
            System.out.println("  库存类型: " + rawMaterialInventory.getInventoryType().getChineseName());
            System.out.println("  总数量: " + rawMaterialInventory.getQuantity() + " " + rawMaterialInventory.getUnit());
            System.out.println("  预留数量: " + rawMaterialInventory.getReservedQuantity() + " " + rawMaterialInventory.getUnit());
            System.out.println("  可用数量: " + rawMaterialInventory.getAvailableQuantity() + " " + rawMaterialInventory.getUnit());
            System.out.println("  仓库: " + rawMaterialInventory.getWarehouse());
            System.out.println("  位置: " + rawMaterialInventory.getLocation());
        }
        
        // 2. 创建并同步在制品库存
        ErpConnector.InventoryData wipInventory = ErpConnector.createInventoryData(
            "WIP-001",
            "在制品A"
        );
        
        if (wipInventory != null) {
            wipInventory.setInventoryType(ErpConnector.InventoryType.WORK_IN_PROGRESS)
                       .setQuantity(200)
                       .setReservedQuantity(50)
                       .setAvailableQuantity(150)
                       .setUnit("PCS")
                       .setWarehouse("WH-002")
                       .setLocation("B区-生产线上")
                       .setAttribute("process_step", "Wire Bonding")
                       .setAttribute("production_order", "ORDER-20250821-001");
            
            boolean synced2 = ErpConnector.syncInventoryData(wipInventory);
            System.out.println("在制品库存同步: " + (synced2 ? "成功" : "失败"));
        }
        
        // 3. 创建并同步成品库存
        ErpConnector.InventoryData finishedGoodInventory = ErpConnector.createInventoryData(
            "PROD-001",
            "产品A"
        );
        
        if (finishedGoodInventory != null) {
            finishedGoodInventory.setInventoryType(ErpConnector.InventoryType.FINISHED_GOOD)
                               .setQuantity(800)
                               .setReservedQuantity(200)
                               .setAvailableQuantity(600)
                               .setUnit("PCS")
                               .setWarehouse("WH-003")
                               .setLocation("C区-成品区")
                               .setAttribute("quality_status", "合格")
                               .setAttribute("last_inspection_date", "2025-08-21");
            
            boolean synced3 = ErpConnector.syncInventoryData(finishedGoodInventory);
            System.out.println("成品库存同步: " + (synced3 ? "成功" : "失败"));
        }
        
        // 4. 批量同步库存数据
        List<ErpConnector.InventoryData> inventoryDataList = new ArrayList<>();
        
        // 添加耗材库存
        ErpConnector.InventoryData consumableInventory = ErpConnector.createInventoryData(
            "CONS-001",
            "清洁剂"
        );
        if (consumableInventory != null) {
            consumableInventory.setInventoryType(ErpConnector.InventoryType.CONSUMABLE)
                             .setQuantity(50)
                             .setUnit("桶")
                             .setWarehouse("WH-004");
            inventoryDataList.add(consumableInventory);
        }
        
        // 添加包装材料库存
        ErpConnector.InventoryData packagingInventory = ErpConnector.createInventoryData(
            "PACK-001",
            "包装盒"
        );
        if (packagingInventory != null) {
            packagingInventory.setInventoryType(ErpConnector.InventoryType.PACKAGING_MATERIAL)
                            .setQuantity(10000)
                            .setUnit("个")
                            .setWarehouse("WH-005");
            inventoryDataList.add(packagingInventory);
        }
        
        List<ErpConnector.SyncResult> batchResults = ErpConnector.syncBatchInventoryData(inventoryDataList);
        
        System.out.println("批量库存数据同步结果:");
        for (int i = 0; i < batchResults.size(); i++) {
            ErpConnector.SyncResult result = batchResults.get(i);
            System.out.println("  库存数据 " + (i+1) + ": " + 
                             (result.isSuccess() ? "成功" : "失败") + 
                             " - " + result.getMessage());
        }
    }
}
```


## 5. 高级使用示例

### 5.1 完整的ERP集成流程

```java
public class CompleteErpIntegrationProcess {
    public void executeCompleteIntegrationProcess() {
        try {
            System.out.println("=== 开始完整的ERP集成流程 ===");
            
            // 步骤1: 初始化和配置
            System.out.println("\n步骤1: 初始化和配置ERP连接器");
            initializeErpConnector();
            
            // 步骤2: 订单状态同步
            System.out.println("\n步骤2: 同步订单状态");
            syncOrderStatuses();
            
            // 步骤3: 接收生产计划
            System.out.println("\n步骤3: 接收生产计划");
            receiveProductionPlans();
            
            // 步骤4: 上报成本数据
            System.out.println("\n步骤4: 上报成本数据");
            reportCostData();
            
            // 步骤5: 同步库存信息
            System.out.println("\n步骤5: 同步库存信息");
            syncInventoryData();
            
            // 步骤6: 状态监控
            System.out.println("\n步骤6: 监控系统状态");
            monitorSystemStatus();
            
            System.out.println("\n=== ERP集成流程完成 ===");
            
        } catch (Exception e) {
            System.err.println("ERP集成流程执行过程中发生错误: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    private void initializeErpConnector() {
        System.out.println("初始化ERP连接器配置...");
        
        // 设置当前组件（实际应用中应根据具体ERP系统类型设置）
        ErpConnector.setCurrentEngine(ErpConnector.ErpType.CUSTOM);
        ErpConnector.setCurrentSynchronizer(ErpConnector.OrderStatus.CREATED);
        ErpConnector.setCurrentReceiver(ErpConnector.PlanStatus.DRAFT);
        ErpConnector.setCurrentReporter(ErpConnector.CostType.CUSTOM);
        ErpConnector.setCurrentInventorySynchronizer(ErpConnector.InventoryType.RAW_MATERIAL);
        
        // 检查连接状态
        ErpConnector.ConnectionStatistics connectionStats = ErpConnector.getConnectionStatistics();
        System.out.println("连接状态: " + (connectionStats.isConnected() ? "已连接" : "未连接"));
        System.out.println("连接信息: " + connectionStats.getConnectionInfo());
        
        // 获取缓存统计信息
        ErpConnector.CacheStatistics cacheStats = ErpConnector.getCacheStatistics();
        System.out.println("缓存统计:");
        System.out.println("  订单缓存: " + cacheStats.getOrderCacheSize());
        System.out.println("  计划缓存: " + cacheStats.getPlanCacheSize());
        System.out.println("  成本缓存: " + cacheStats.getCostCacheSize());
        System.out.println("  库存缓存: " + cacheStats.getInventoryCacheSize());
    }
    
    private void syncOrderStatuses() {
        System.out.println("同步订单状态...");
        
        // 创建订单
        ErpConnector.Order order = ErpConnector.createOrder(
            "ORDER-20250821-001", 
            "CUST-001", 
            "客户A公司"
        );
        
        if (order != null) {
            // 同步订单状态变化
            boolean synced1 = ErpConnector.syncOrderStatus(order.getOrderId(), ErpConnector.OrderStatus.CONFIRMED);
            System.out.println("订单确认状态同步: " + (synced1 ? "成功" : "失败"));
            
            boolean synced2 = ErpConnector.syncOrderStatus(order.getOrderId(), ErpConnector.OrderStatus.IN_PRODUCTION);
            System.out.println("订单生产状态同步: " + (synced2 ? "成功" : "失败"));
        }
    }
    
    private void receiveProductionPlans() {
        System.out.println("接收生产计划...");
        
        // 创建ERP计划
        ErpConnector.ErpPlan erpPlan = ErpConnector.createErpPlan(
            "PLAN-20250821-001",
            "PROD-001",
            "产品A",
            1000
        );
        
        if (erpPlan != null) {
            erpPlan.setStatus(ErpConnector.PlanStatus.APPROVED);
            
            // 接收生产计划
            ErpConnector.ProductionPlan productionPlan = ErpConnector.receiveProductionPlan(erpPlan);
            System.out.println("生产计划接收: " + (productionPlan != null ? "成功" : "失败"));
        }
    }
    
    private void reportCostData() {
        System.out.println("上报成本数据...");
        
        // 创建成本数据
        ErpConnector.CostData costData = ErpConnector.createCostData(
            "PROD-001",
            ErpConnector.CostType.MATERIAL,
            new BigDecimal("5000.00")
        );
        
        if (costData != null) {
            boolean reported = ErpConnector.reportCostData(costData);
            System.out.println("成本数据上报: " + (reported ? "成功" : "失败"));
        }
    }
    
    private void syncInventoryData() {
        System.out.println("同步库存信息...");
        
        // 创建库存数据
        ErpConnector.InventoryData inventoryData = ErpConnector.createInventoryData(
            "MAT-001",
            "原材料A"
        );
        
        if (inventoryData != null) {
            inventoryData.setQuantity(5000)
                        .setAvailableQuantity(4000);
            
            boolean synced = ErpConnector.syncInventoryData(inventoryData);
            System.out.println("库存数据同步: " + (synced ? "成功" : "失败"));
        }
    }
    
    private void monitorSystemStatus() {
        System.out.println("监控系统状态...");
        
        // 获取缓存统计信息
        ErpConnector.CacheStatistics cacheStats = ErpConnector.getCacheStatistics();
        System.out.println("缓存状态:");
        System.out.println("  订单缓存数量: " + cacheStats.getOrderCacheSize());
        System.out.println("  计划缓存数量: " + cacheStats.getPlanCacheSize());
        System.out.println("  成本缓存数量: " + cacheStats.getCostCacheSize());
        System.out.println("  库存缓存数量: " + cacheStats.getInventoryCacheSize());
        
        // 获取连接统计信息
        ErpConnector.ConnectionStatistics connStats = ErpConnector.getConnectionStatistics();
        System.out.println("连接状态:");
        System.out.println("  是否连接: " + (connStats.isConnected() ? "是" : "否"));
        System.out.println("  连接信息: " + connStats.getConnectionInfo());
    }
}
```


### 5.2 ERP集成监控和分析

```java
public class ErpIntegrationMonitoring {
    public void monitorAndAnalyzeIntegration() {
        System.out.println("=== ERP集成监控和分析 ===");
        
        // 监控缓存状态
        monitorCacheStatus();
        
        // 监控连接状态
        monitorConnectionStatus();
        
        // 分析同步性能
        analyzeSyncPerformance();
        
        // 检查异常情况
        checkExceptionStatus();
        
        System.out.println("=== 监控和分析完成 ===");
    }
    
    private void monitorCacheStatus() {
        System.out.println("\n缓存状态监控:");
        
        ErpConnector.CacheStatistics cacheStats = ErpConnector.getCacheStatistics();
        
        System.out.println("缓存统计信息:");
        System.out.println("  订单缓存数量: " + cacheStats.getOrderCacheSize());
        System.out.println("  计划缓存数量: " + cacheStats.getPlanCacheSize());
        System.out.println("  成本缓存数量: " + cacheStats.getCostCacheSize());
        System.out.println("  库存缓存数量: " + cacheStats.getInventoryCacheSize());
        System.out.println("  缓存超时时间: " + cacheStats.getCacheTimeout() + "ms");
        
        // 评估缓存健康状况
        if (cacheStats.getOrderCacheSize() > 1000) {
            System.out.println("  警告: 订单缓存较大，可能需要清理");
        }
        
        if (cacheStats.getPlanCacheSize() > 500) {
            System.out.println("  警告: 计划缓存较大，可能需要清理");
        }
    }
    
    private void monitorConnectionStatus() {
        System.out.println("\n连接状态监控:");
        
        ErpConnector.ConnectionStatistics connStats = ErpConnector.getConnectionStatistics();
        
        System.out.println("连接统计信息:");
        System.out.println("  是否连接: " + (connStats.isConnected() ? "是" : "否"));
        System.out.println("  连接信息: " + connStats.getConnectionInfo());
        System.out.println("  连接超时: " + connStats.getConnectionTimeout() + "ms");
        
        if (!connStats.isConnected()) {
            System.out.println("  警告: ERP连接已断开，需要重新连接");
        }
    }
    
    private void analyzeSyncPerformance() {
        System.out.println("\n同步性能分析:");
        
        // 模拟性能分析（实际应用中可以从日志或监控系统获取数据）
        System.out.println("同步性能指标:");
        System.out.println("  订单状态同步平均耗时: 120ms");
        System.out.println("  订单状态同步成功率: 99.2%");
        System.out.println("  生产计划接收平均耗时: 250ms");
        System.out.println("  生产计划接收成功率: 98.8%");
        System.out.println("  成本数据上报平均耗时: 180ms");
        System.out.println("  成本数据上报成功率: 99.5%");
        System.out.println("  库存信息同步平均耗时: 150ms");
        System.out.println("  库存信息同步成功率: 99.0%");
        
        // 性能建议
        System.out.println("性能优化建议:");
        System.out.println("  1. 对于大批量数据，建议使用批量同步接口");
        System.out.println("  2. 定期清理过期缓存数据");
        System.out.println("  3. 监控网络延迟，优化通信参数");
    }
    
    private void checkExceptionStatus() {
        System.out.println("\n异常状态检查:");
        
        // 模拟异常检查（实际应用中应该查询异常日志或数据库）
        System.out.println("异常统计:");
        System.out.println("  今日异常总数: 2");
        System.out.println("  未处理异常: 0");
        System.out.println("  最常见异常类型: 通信错误");
        System.out.println("  平均异常处理时间: 3.2分钟");
        
        System.out.println("异常处理建议:");
        System.out.println("  1. 建立异常自动恢复机制");
        System.out.println("  2. 设置异常阈值告警");
        System.out.println("  3. 定期分析异常模式，优化系统稳定性");
    }
    
    public void generateIntegrationReport() {
        System.out.println("\n=== 生成ERP集成报告 ===");
        
        System.out.println("ERP集成系统报告");
        System.out.println("========================");
        System.out.println("报告生成时间: " + java.time.LocalDateTime.now());
        System.out.println();
        
        // 系统配置信息
        System.out.println("1. 系统配置信息");
        System.out.println("   当前ERP类型: " + ErpConnector.ErpType.CUSTOM.getChineseName());
        System.out.println("   支持的订单状态: " + ErpConnector.OrderStatus.values().length + " 种");
        System.out.println("   支持的成本类型: " + ErpConnector.CostType.values().length + " 种");
        System.out.println("   支持的库存类型: " + ErpConnector.InventoryType.values().length + " 种");
        System.out.println();
        
        // 运行状态信息
        System.out.println("2. 运行状态信息");
        ErpConnector.CacheStatistics cacheStats = ErpConnector.getCacheStatistics();
        ErpConnector.ConnectionStatistics connStats = ErpConnector.getConnectionStatistics();
        
        System.out.println("   缓存状态:");
        System.out.println("     订单缓存: " + cacheStats.getOrderCacheSize() + " 个");
        System.out.println("     计划缓存: " + cacheStats.getPlanCacheSize() + " 个");
        System.out.println("     成本缓存: " + cacheStats.getCostCacheSize() + " 个");
        System.out.println("     库存缓存: " + cacheStats.getInventoryCacheSize() + " 个");
        System.out.println("   连接状态:");
        System.out.println("     是否连接: " + (connStats.isConnected() ? "是" : "否"));
        System.out.println("     连接信息: " + connStats.getConnectionInfo());
        System.out.println();
        
        // 性能指标
        System.out.println("3. 性能指标");
        System.out.println("   订单状态同步:");
        System.out.println("     平均耗时: 120ms");
        System.out.println("     成功率: 99.2%");
        System.out.println("   生产计划接收:");
        System.out.println("     平均耗时: 250ms");
        System.out.println("     成功率: 98.8%");
        System.out.println("   成本数据上报:");
        System.out.println("     平均耗时: 180ms");
        System.out.println("     成功率: 99.5%");
        System.out.println("   库存信息同步:");
        System.out.println("     平均耗时: 150ms");
        System.out.println("     成功率: 99.0%");
        System.out.println();
        
        // 异常统计
        System.out.println("4. 异常统计");
        System.out.println("   今日异常: 2 次");
        System.out.println("     通信错误: 1 次");
        System.out.println("     超时错误: 1 次");
        System.out.println("   异常处理:");
        System.out.println("     已处理: 2 次");
        System.out.println("     未处理: 0 次");
        System.out.println();
        
        // 建议和改进
        System.out.println("5. 建议和改进");
        System.out.println("   性能优化:");
        System.out.println("     - 考虑增加批量处理以提高吞吐量");
        System.out.println("     - 优化网络通信参数");
        System.out.println("   稳定性提升:");
        System.out.println("     - 增强异常自动恢复机制");
        System.out.println("     - 完善监控告警体系");
        System.out.println("   功能扩展:");
        System.out.println("     - 增加更多ERP系统类型支持");
        System.out.println("     - 扩展成本类型和库存类型");
        
        System.out.println("========================");
        System.out.println("报告生成完成");
    }
}
```


## 6. 配置参数详解

### 6.1 系统级配置参数

```java
public class ErpConnectorConfig {
    // 缓存超时时间（毫秒）
    public static final long CACHE_TIMEOUT = 30 * 60 * 1000; // 30分钟
    
    // 最大重试次数
    public static final int MAX_RETRY_ATTEMPTS = 3;
    
    // 重试延迟（毫秒）
    public static final long RETRY_DELAY = 1000; // 1秒
    
    // 批量处理大小
    public static final int BATCH_SIZE = 100;
    
    // 数据同步间隔（毫秒）
    public static final long SYNC_INTERVAL = 5 * 60 * 1000; // 5分钟
    
    // 消息队列大小
    public static final int MESSAGE_QUEUE_SIZE = 10000;
    
    // 连接超时时间（毫秒）
    public static final long CONNECTION_TIMEOUT = 30000; // 30秒
    
    // 库存同步阈值
    public static final int INVENTORY_SYNC_THRESHOLD = 10;
}
```


### 6.2 组件配置

```java
// 配置不同的ERP连接组件
public class ComponentConfiguration {
    public void configureComponents() {
        // 配置SAP ERP连接器
        // ErpConnector.registerEngine(new SapErpConnectorEngine());
        // ErpConnector.setCurrentEngine(ErpConnector.ErpType.SAP);
        
        // 配置Oracle EBS订单同步器
        // ErpConnector.registerSynchronizer(new OracleOrderStatusSynchronizer());
        // ErpConnector.setCurrentSynchronizer(ErpConnector.OrderStatus.CUSTOM);
        
        // 配置金蝶云生产计划接收器
        // ErpConnector.registerReceiver(new KingdeeProductionPlanReceiver());
        // ErpConnector.setCurrentReceiver(ErpConnector.PlanStatus.CUSTOM);
        
        // 配置用友NC成本数据上报器
        // ErpConnector.registerReporter(new YonyouCostDataReporter());
        // ErpConnector.setCurrentReporter(ErpConnector.CostType.CUSTOM);
        
        // 配置自定义库存数据同步器
        // ErpConnector.registerInventorySynchronizer(new CustomInventoryDataSynchronizer());
        // ErpConnector.setCurrentInventorySynchronizer(ErpConnector.InventoryType.CUSTOM);
        
        System.out.println("组件配置完成");
    }
}
```


## 7. 错误处理

### 7.1 异常处理示例

```java
public class ErpConnectorErrorHandler {
    public void handleIntegrationErrors() {
        System.out.println("ERP集成错误处理示例");
        
        try {
            // 尝试同步订单状态
            boolean result = ErpConnector.syncOrderStatus("ORDER-20250821-001", ErpConnector.OrderStatus.IN_PRODUCTION);
            
            if (result) {
                System.out.println("订单状态同步成功");
            } else {
                System.err.println("订单状态同步失败");
            }
            
        } catch (Exception e) {
            System.err.println("订单状态同步过程中发生异常: " + e.getMessage());
            e.printStackTrace();
            
            // 记录异常并上报
            ErpConnector.ExceptionData exceptionData = new ErpConnector.ExceptionData(
                ErpConnector.ExceptionType.COMMUNICATION_ERROR,
                "LocalSystem",
                "ERP",
                "订单状态同步异常: " + e.getMessage()
            );
            
            boolean reported = ErpConnector.reportExceptionData(exceptionData);
            System.out.println("异常上报: " + (reported ? "成功" : "失败"));
        }
    }
    
    public boolean safeOrderStatusSync(String orderId, ErpConnector.OrderStatus status) {
        if (orderId == null || orderId.isEmpty()) {
            System.err.println("订单ID不能为空");
            return false;
        }
        
        if (status == null) {
            System.err.println("订单状态不能为空");
            return false;
        }
        
        int maxRetries = 3;
        int retryCount = 0;
        
        while (retryCount < maxRetries) {
            try {
                boolean result = ErpConnector.syncOrderStatus(orderId, status);
                
                if (result) {
                    System.out.println("订单状态同步成功");
                    return true;
                } else {
                    System.err.println("第" + (retryCount + 1) + "次同步失败");
                }
                
            } catch (Exception e) {
                System.err.println("第" + (retryCount + 1) + "次同步异常: " + e.getMessage());
            }
            
            retryCount++;
            
            // 重试前等待
            if (retryCount < maxRetries) {
                try {
                    Thread.sleep(1000 * retryCount); // 递增延迟
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
        
        System.err.println("订单状态同步最终失败，已重试 " + maxRetries + " 次");
        return false;
    }
}
```


## 8. 最佳实践

### 8.1 数据同步最佳实践

```java
public class DataSyncBestPractices {
    public void demonstrateBestPractices() {
        System.out.println("ERP数据同步最佳实践演示");
        
        // 1. 数据验证
        System.out.println("1. 数据验证");
        ErpConnector.Order order = createValidatedOrder();
        if (order == null) {
            System.err.println("订单验证失败");
            return;
        }
        
        // 2. 批量处理
        System.out.println("2. 批量处理");
        List<String> orderIds = createBatchOrderIds();
        if (orderIds.size() > 50) {
            // 分批处理大量订单
            processInBatches(orderIds);
        } else {
            // 直接处理小批量订单
            processBatchOrders(orderIds);
        }
        
        // 3. 异步处理
        System.out.println("3. 异步处理");
        processOrdersAsynchronously(orderIds);
        
        // 4. 错误处理和重试
        System.out.println("4. 错误处理和重试");
        handleWithRetry(order.getOrderId(), ErpConnector.OrderStatus.IN_PRODUCTION);
    }
    
    private ErpConnector.Order createValidatedOrder() {
        // 创建订单
        ErpConnector.Order order = ErpConnector.createOrder(
            "ORDER-20250821-001",
            "CUST-001",
            "客户A公司"
        );
        
        if (order == null) {
            return null;
        }
        
        // 验证必需字段
        if (order.getOrderId() == null || order.getOrderId().isEmpty()) {
            System.err.println("订单ID不能为空");
            return null;
        }
        
        if (order.getCustomerCode() == null || order.getCustomerCode().isEmpty()) {
            System.err.println("客户代码不能为空");
            return null;
        }
        
        System.out.println("订单验证通过");
        return order;
    }
    
    private List<String> createBatchOrderIds() {
        List<String> orderIds = new ArrayList<>();
        
        // 创建多个订单ID
        for (int i = 1; i <= 10; i++) {
            orderIds.add("ORDER-20250821-" + String.format("%03d", i));
        }
        
        return orderIds;
    }
    
    private void processInBatches(List<String> orderIds) {
        int batchSize = 50;
        
        for (int i = 0; i < orderIds.size(); i += batchSize) {
            int endIndex = Math.min(i + batchSize, orderIds.size());
            List<String> batch = orderIds.subList(i, endIndex);
            
            System.out.println("处理批次: " + (i/batchSize + 1) + ", 大小: " + batch.size());
            processBatchOrders(batch);
        }
    }
    
    private void processBatchOrders(List<String> orderIds) {
        Map<String, ErpConnector.OrderStatus> batchStatuses = new HashMap<>();
        for (String orderId : orderIds) {
            batchStatuses.put(orderId, ErpConnector.OrderStatus.IN_PRODUCTION);
        }
        
        Map<String, Boolean> results = ErpConnector.syncBatchOrderStatus(batchStatuses);
        
        int successCount = 0;
        for (Map.Entry<String, Boolean> entry : results.entrySet()) {
            if (entry.getValue()) {
                successCount++;
            } else {
                System.err.println("订单状态同步失败: " + entry.getKey());
            }
        }
        
        System.out.println("批量处理完成，成功: " + successCount + "/" + results.size());
    }
    
    private void processOrdersAsynchronously(List<String> orderIds) {
        // 使用异步方式处理订单状态同步
        ExecutorService executor = Executors.newFixedThreadPool(10);
        
        List<CompletableFuture<Boolean>> futures = new ArrayList<>();
        
        for (String orderId : orderIds) {
            CompletableFuture<Boolean> future = CompletableFuture.supplyAsync(() -> {
                try {
                    Thread.sleep(100 + (long) (Math.random() * 200));
                    return ErpConnector.syncOrderStatus(orderId, ErpConnector.OrderStatus.IN_PRODUCTION);
                } catch (Exception e) {
                    e.printStackTrace();
                    return false;
                }
            }, executor);
            
            futures.add(future);
        }
        
        // 等待所有任务完成
        CompletableFuture<Void> allDone = CompletableFuture.allOf(
            futures.toArray(new CompletableFuture[0])
        );
        
        try {
            allDone.get(30, TimeUnit.SECONDS);
            System.out.println("  所有异步任务完成");
        } catch (Exception e) {
            System.err.println("  异步任务执行超时或异常: " + e.getMessage());
        } finally {
            executor.shutdown();
        }
    }
    
    private void handleWithRetry(String orderId, ErpConnector.OrderStatus status) {
        int maxRetries = 3;
        int retryDelay = 1000; // 1秒
        
        for (int i = 0; i < maxRetries; i++) {
            try {
                boolean result = ErpConnector.syncOrderStatus(orderId, status);
                
                if (result) {
                    System.out.println("订单状态同步成功");
                    return;
                } else {
                    System.err.println("第" + (i + 1) + "次同步失败");
                }
                
            } catch (Exception e) {
                System.err.println("第" + (i + 1) + "次同步异常: " + e.getMessage());
            }
            
            // 重试前等待
            if (i < maxRetries - 1) {
                try {
                    Thread.sleep(retryDelay * (i + 1));
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
        
        System.err.println("订单状态同步最终失败");
    }
}
```


### 8.2 性能优化实践

```java
public class PerformanceOptimization {
    private final Map<String, ErpConnector.Order> localCache = new ConcurrentHashMap<>();
    private final long cacheTimeout = 10 * 60 * 1000; // 10分钟
    
    public void demonstratePerformanceOptimization() {
        System.out.println("ERP集成性能优化实践");
        
        // 1. 本地缓存
        System.out.println("1. 本地缓存优化");
        useLocalCaching();
        
        // 2. 连接池管理
        System.out.println("2. 连接管理优化");
        manageConnections();
        
        // 3. 批量操作
        System.out.println("3. 批量操作优化");
        optimizeBatchOperations();
        
        // 4. 异步处理
        System.out.println("4. 异步处理优化");
        useAsyncProcessing();
    }
    
    private void useLocalCaching() {
        // 检查本地缓存
        String cacheKey = "ORDER_20250821_001";
        CachedOrder cached = (CachedOrder) localCache.get(cacheKey);
        
        if (cached != null && !cached.isExpired()) {
            System.out.println("从本地缓存获取订单: " + cacheKey);
            return;
        }
        
        // 从ERP连接器获取
        // ErpConnector.Order order = ErpConnector.getOrder(orderId);
        // if (order != null) {
        //     localCache.put(cacheKey, new CachedOrder(order, System.currentTimeMillis() + cacheTimeout));
        // }
        
        System.out.println("本地缓存优化示例完成");
    }
    
    private void manageConnections() {
        System.out.println("连接管理优化:");
        
        // 获取连接统计信息
        ErpConnector.ConnectionStatistics stats = ErpConnector.getConnectionStatistics();
        
        if (stats.isConnected()) {
            System.out.println("  连接正常，无需重新连接");
        } else {
            System.out.println("  连接断开，尝试重新连接");
            // 实际应用中应该尝试重新连接
        }
        
        System.out.println("  连接超时设置: " + stats.getConnectionTimeout() + "ms");
    }
    
    private void optimizeBatchOperations() {
        System.out.println("批量操作优化:");
        
        // 创建批量订单ID
        List<String> orderIds = new ArrayList<>();
        for (int i = 0; i < 100; i++) {
            orderIds.add("ORDER-20250821-" + String.format("%03d", i));
        }
        
        // 使用批量同步方法
        long startTime = System.currentTimeMillis();
        Map<String, Boolean> results = new HashMap<>();
        for (String orderId : orderIds) {
            results.put(orderId, true); // 模拟结果
        }
        long endTime = System.currentTimeMillis();
        
        System.out.println("  批量同步 " + orderIds.size() + " 个订单状态");
        System.out.println("  耗时: " + (endTime - startTime) + "ms");
        System.out.println("  平均每个订单: " + (endTime - startTime) / (double) orderIds.size() + "ms");
    }
    
    private void useAsyncProcessing() {
        System.out.println("异步处理优化:");
        
        // 创建异步任务执行器
        ExecutorService executor = Executors.newFixedThreadPool(10);
        
        // 提交多个异步任务
        List<CompletableFuture<Boolean>> futures = new ArrayList<>();
        
        for (int i = 0; i < 20; i++) {
            final int taskId = i;
            CompletableFuture<Boolean> future = CompletableFuture.supplyAsync(() -> {
                // 模拟订单状态同步操作
                try {
                    Thread.sleep(100 + (long) (Math.random() * 200));
                    // return ErpConnector.syncOrderStatus("ORDER-20250821-" + String.format("%03d", taskId), ErpConnector.OrderStatus.IN_PRODUCTION);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                return true;
            }, executor);
            
            futures.add(future);
        }
        
        // 等待所有任务完成
        CompletableFuture<Void> allDone = CompletableFuture.allOf(
            futures.toArray(new CompletableFuture[0])
        );
        
        try {
            allDone.get(30, TimeUnit.SECONDS);
            System.out.println("  所有异步任务完成");
        } catch (Exception e) {
            System.err.println("  异步任务执行超时或异常: " + e.getMessage());
        } finally {
            executor.shutdown();
        }
    }
    
    // 缓存订单类
    private static class CachedOrder {
        private final ErpConnector.Order order;
        private final long expireTime;
        
        public CachedOrder(ErpConnector.Order order, long expireTime) {
            this.order = order;
            this.expireTime = expireTime;
        }
        
        public boolean isExpired() {
            return System.currentTimeMillis() > expireTime;
        }
        
        public ErpConnector.Order getOrder() {
            return order;
        }
    }
}
```


## 9. 系统集成

### 9.1 与Spring框架集成

```java
@Component
public class SpringErpIntegrationService {
    
    @Autowired
    private ErpConnector erpConnector; // 假设ErpConnector被Spring管理
    
    // 订单状态同步服务
    public boolean syncOrderStatus(String orderId, ErpConnector.OrderStatus status) {
        return ErpConnector.syncOrderStatus(orderId, status);
    }
    
    // 生产计划接收服务
    @Async
    public CompletableFuture<ErpConnector.ProductionPlan> receiveProductionPlanAsync(
            ErpConnector.ErpPlan erpPlan) {
        ErpConnector.ProductionPlan productionPlan = ErpConnector.receiveProductionPlan(erpPlan);
        return CompletableFuture.completedFuture(productionPlan);
    }
    
    // 成本数据上报服务
    @Scheduled(fixedRate = 300000) // 每5分钟上报一次
    public void reportCostDataPeriodically() {
        // 收集成本数据
        List<ErpConnector.CostData> costDataList = collectCostData();
        
        // 批量上报成本数据
        ErpConnector.reportBatchCostData(costDataList);
    }
    
    // 库存信息同步服务
    @EventListener
    public void handleInventoryUpdateEvent(InventoryUpdateEvent event) {
        ErpConnector.InventoryData inventoryData = convertToInventoryData(event);
        
        ErpConnector.syncInventoryData(inventoryData);
    }
    
    // 私有辅助方法
    private List<ErpConnector.CostData> collectCostData() {
        List<ErpConnector.CostData> costDataList = new ArrayList<>();
        // 实现成本数据收集逻辑
        return costDataList;
    }
    
    private ErpConnector.InventoryData convertToInventoryData(InventoryUpdateEvent event) {
        ErpConnector.InventoryData inventoryData = ErpConnector.createInventoryData(
            event.getProductId(),
            event.getProductName()
        );
        
        if (inventoryData != null) {
            inventoryData.setQuantity(event.getQuantity())
                        .setAvailableQuantity(event.getAvailableQuantity())
                        .setWarehouse(event.getWarehouse())
                        .setLocation(event.getLocation());
        }
        
        return inventoryData;
    }
}

// 库存更新事件
class InventoryUpdateEvent extends ApplicationEvent {
    private final String productId;
    private final String productName;
    private final int quantity;
    private final int availableQuantity;
    private final String warehouse;
    private final String location;
    
    public InventoryUpdateEvent(Object source, String productId, String productName, 
                              int quantity, int availableQuantity, 
                              String warehouse, String location) {
        super(source);
        this.productId = productId;
        this.productName = productName;
        this.quantity = quantity;
        this.availableQuantity = availableQuantity;
        this.warehouse = warehouse;
        this.location = location;
    }
    
    // Getters
    public String getProductId() { return productId; }
    public String getProductName() { return productName; }
    public int getQuantity() { return quantity; }
    public int getAvailableQuantity() { return availableQuantity; }
    public String getWarehouse() { return warehouse; }
    public String getLocation() { return location; }
}
```


### 9.2 与消息队列集成

```java
@Component
public class MessageQueueIntegration {
    
    // Kafka集成示例
    @KafkaListener(topics = "erp-orders", groupId = "erp-connector-group")
    public void handleOrderStatusUpdate(String orderJson) {
        try {
            // 解析JSON到订单状态更新对象
            OrderStatusUpdate update = parseOrderStatusUpdateFromJson(orderJson);
            
            // 同步订单状态到ERP
            boolean synced = ErpConnector.syncOrderStatus(update.getOrderId(), update.getStatus());
            
            if (!synced) {
                System.err.println("订单状态同步失败: " + update.getOrderId());
            }
            
        } catch (Exception e) {
            System.err.println("处理订单状态更新时发生错误: " + e.getMessage());
        }
    }
    
    @KafkaListener(topics = "erp-costs", groupId = "erp-connector-group")
    public void handleCostDataReport(String costDataJson) {
        try {
            // 解析JSON到成本数据对象
            ErpConnector.CostData costData = parseCostDataFromJson(costDataJson);
            
            // 上报成本数据到ERP
            boolean reported = ErpConnector.reportCostData(costData);
            
            if (!reported) {
                System.err.println("成本数据上报失败: " + costData.getCostId());
            }
            
        } catch (Exception e) {
            System.err.println("处理成本数据上报时发生错误: " + e.getMessage());
        }
    }
    
    // RabbitMQ集成示例
    @RabbitListener(queues = "erp-inventory-queue")
    public void handleInventorySync(InventorySyncMessage message) {
        try {
            // 同步库存数据到ERP
            boolean synced = ErpConnector.syncInventoryData(message.getInventoryData());
            
            if (!synced) {
                System.err.println("库存数据同步失败: " + message.getInventoryData().getInventoryId());
            }
            
        } catch (Exception e) {
            System.err.println("处理库存数据同步时发生错误: " + e.getMessage());
        }
    }
    
    // 私有辅助方法
    private OrderStatusUpdate parseOrderStatusUpdateFromJson(String json) {
        // 实现JSON到订单状态更新对象的解析
        return new OrderStatusUpdate("ORDER-001", ErpConnector.OrderStatus.IN_PRODUCTION);
    }
    
    private ErpConnector.CostData parseCostDataFromJson(String json) {
        // 实现JSON到成本数据对象的解析
        return ErpConnector.createCostData("PROD-001", ErpConnector.CostType.MATERIAL, new BigDecimal("1000"));
    }
}

// 订单状态更新类
class OrderStatusUpdate {
    private String orderId;
    private ErpConnector.OrderStatus status;
    
    public OrderStatusUpdate(String orderId, ErpConnector.OrderStatus status) {
        this.orderId = orderId;
        this.status = status;
    }
    
    // Getters and Setters
    public String getOrderId() { return orderId; }
    public void setOrderId(String orderId) { this.orderId = orderId; }
    
    public ErpConnector.OrderStatus getStatus() { return status; }
    public void setStatus(ErpConnector.OrderStatus status) { this.status = status; }
}

// 库存同步消息类
class InventorySyncMessage {
    private ErpConnector.InventoryData inventoryData;
    private long timestamp;
    
    // Getters and Setters
    public ErpConnector.InventoryData getInventoryData() { return inventoryData; }
    public void setInventoryData(ErpConnector.InventoryData inventoryData) { this.inventoryData = inventoryData; }
    
    public long getTimestamp() { return timestamp; }
    public void setTimestamp(long timestamp) { this.timestamp = timestamp; }
}
```


这个使用说明文档涵盖了 [ErpConnector](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\semiconductor\integration\erp\ErpConnector.java#L34-L1581) 的主要功能和使用方法，可以帮助开发者快速上手并正确使用该ERP集成工具类。