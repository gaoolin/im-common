# ProcessController 使用说明文档

## 1. 概述

[ProcessController](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\semiconductor\process\controller\ProcessController.java#L34-L1587) 是一个专业的半导体工艺过程控制工具类，专门用于半导体封测行业的工艺过程执行、参数调整、异常处理和过程追溯管理。该工具解决了工艺过程控制不精确、工艺参数调整不及时、工艺异常处理不规范和工艺过程追溯不完整等问题。

## 2. 核心功能

### 2.1 工艺步骤执行
- 支持多种类型的工艺步骤执行
- 实时监控步骤执行状态
- 步骤执行结果记录和分析

### 2.2 实时工艺参数调整
- 多种参数调整策略支持
- 参数调整历史记录
- 自动化和手动调整模式

### 2.3 工艺异常处理
- 多类型异常识别和处理
- 异常恢复策略执行
- 异常处理结果跟踪

### 2.4 工艺过程追溯
- 完整的过程执行轨迹记录
- 事件查询和分析
- 过程状态历史追踪

## 3. 支持的工艺类型和参数

### 3.1 工艺类型
```java
public enum ProcessType {
    WIRE_BONDING("引线键合工艺", "Wire Bonding Process"),      // 引线键合工艺
    DIE_ATTACH("芯片贴装工艺", "Die Attach Process"),         // 芯片贴装工艺
    PLASTIC_PACKAGING("塑封工艺", "Plastic Packaging Process"), // 塑封工艺
    METAL_PACKAGING("金属封装工艺", "Metal Packaging Process"), // 金属封装工艺
    CERAMIC_PACKAGING("陶瓷封装工艺", "Ceramic Packaging Process"), // 陶瓷封装工艺
    SOLDERING("焊接工艺", "Soldering Process"),              // 焊接工艺
    CLEANING("清洗工艺", "Cleaning Process"),                // 清洗工艺
    TESTING("测试工艺", "Testing Process"),                  // 测试工艺
    ASSEMBLY("组装工艺", "Assembly Process"),                // 组装工艺
    CUSTOM("自定义工艺", "Custom Process")                   // 自定义工艺
}
```


### 3.2 步骤类型
```java
public enum StepType {
    PREPARATION("准备步骤", "Preparation Step"),     // 准备步骤
    PROCESSING("处理步骤", "Processing Step"),       // 处理步骤
    QUALITY_CHECK("质量检查", "Quality Check"),      // 质量检查
    TRANSITION("过渡步骤", "Transition Step"),       // 过渡步骤
    CLEANUP("清理步骤", "Cleanup Step"),             // 清理步骤
    CUSTOM("自定义步骤", "Custom Step")              // 自定义步骤
}
```


### 3.3 工艺状态
```java
public enum ProcessStatus {
    INITIALIZED("已初始化", 1),    // 已初始化
    RUNNING("运行中", 2),          // 运行中
    PAUSED("已暂停", 3),           // 已暂停
    COMPLETED("已完成", 4),        // 已完成
    FAILED("已失败", 5),           // 已失败
    CANCELLED("已取消", 6),        // 已取消
    SUSPENDED("已挂起", 7)         // 已挂起
}
```


## 4. 基本使用方法

### 4.1 创建执行上下文

```java
// 创建工艺执行上下文
ProcessController.ExecutionContext context = ProcessController.createExecutionContext(
    "PROCESS_001",                                // 工艺ID
    ProcessController.ProcessType.WIRE_BONDING,   // 工艺类型
    "PRODUCT_X",                                 // 产品ID
    "BATCH_20250821"                            // 批次ID
);

if (context != null) {
    System.out.println("创建执行上下文成功:");
    System.out.println("  工艺ID: " + context.getProcessId());
    System.out.println("  工艺类型: " + context.getProcessType().getChineseName());
    System.out.println("  产品ID: " + context.getProductId());
    System.out.println("  批次ID: " + context.getBatchId());
    System.out.println("  当前状态: " + context.getStatus().getDescription());
    System.out.println("  创建时间: " + context.getStartTime());
    
    // 设置全局参数
    context.setGlobalParameter("operator", "张三")
           .setGlobalParameter("equipment_id", "WB-001")
           .setGlobalParameter("target_temperature", 280.0)
           .setGlobalParameter("bonding_force", 50.0);
    
    System.out.println("全局参数数量: " + context.getGlobalParameters().size());
} else {
    System.err.println("执行上下文创建失败");
}
```


### 4.2 创建和执行工艺步骤

```java
// 创建工艺步骤
ProcessController.ProcessStep step1 = new ProcessController.ProcessStep(
    "STEP_001", 
    "预热", 
    ProcessController.StepType.PREPARATION, 
    1
)
.setDescription("设备预热到工作温度")
.setParameter("target_temp", 280.0)
.setParameter("heating_rate", 5.0)
.setExpectedDuration(300000) // 5分钟
.setCondition("min_temp", 250.0)
.setCondition("max_temp", 320.0);

// 添加依赖步骤
step1.addDependency("STEP_INIT");

// 添加约束条件
ProcessController.ProcessConstraint constraint1 = new ProcessController.ProcessConstraint(
    "CONSTRAINT_001", 
    "温度范围约束", 
    "target_temp >= 250 AND target_temp <= 320"
)
.setDescription("确保目标温度在合理范围内")
.setEnabled(true);

step1.addConstraint(constraint1);

// 执行步骤
ProcessController.ProcessStepResult result1 = ProcessController.executeStep(step1, context);

if (result1 != null) {
    System.out.println("步骤执行结果:");
    System.out.println("  步骤ID: " + result1.getStepId());
    System.out.println("  工艺ID: " + result1.getProcessId());
    System.out.println("  执行成功: " + result1.isSuccess());
    System.out.println("  消息: " + result1.getMessage());
    System.out.println("  执行时间: " + result1.getExecutionTime() + "ms");
    System.out.println("  开始时间: " + result1.getStartTime());
    System.out.println("  结束时间: " + result1.getEndTime());
    
    // 显示输出数据
    System.out.println("  输出数据:");
    result1.getOutputData().forEach((key, value) -> 
        System.out.println("    " + key + ": " + value));
    
    // 显示统计信息
    System.out.println("  统计信息:");
    result1.getStatistics().forEach((key, value) -> 
        System.out.println("    " + key + ": " + value));
} else {
    System.err.println("步骤执行失败");
}

// 创建处理步骤
ProcessController.ProcessStep step2 = new ProcessController.ProcessStep(
    "STEP_002", 
    "键合", 
    ProcessController.StepType.PROCESSING, 
    2
)
.setDescription("执行引线键合工艺")
.setParameter("bond_force", 50.0)
.setParameter("ultrasonic_power", 75.0)
.setParameter("bond_time", 30.0)
.setExpectedDuration(10000) // 10秒
.addDependency("STEP_001");

// 执行处理步骤
ProcessController.ProcessStepResult result2 = ProcessController.executeStep(step2, context);

if (result2 != null && result2.isSuccess()) {
    System.out.println("键合步骤执行成功");
} else {
    System.err.println("键合步骤执行失败: " + (result2 != null ? result2.getMessage() : "未知错误"));
}
```


### 4.3 实时参数调整

```java
// 创建参数调整请求
ProcessController.ParameterAdjustment adjustment = new ProcessController.ParameterAdjustment(
    "target_temperature",     // 参数名称
    280.0,                   // 旧值
    285.0,                   // 新值
    ProcessController.AdjustmentType.AUTOMATIC, // 调整类型
    "根据实时质量反馈调整温度"      // 调整原因
)
.setOperator("系统自动");

// 执行参数调整
boolean adjusted = ProcessController.adjustParameters(context.getProcessId(), adjustment);

if (adjusted) {
    System.out.println("参数调整成功:");
    System.out.println("  参数名称: " + adjustment.getParameterName());
    System.out.println("  旧值: " + adjustment.getOldValue());
    System.out.println("  新值: " + adjustment.getNewValue());
    System.out.println("  调整类型: " + adjustment.getAdjustmentType().getChineseName());
    System.out.println("  调整原因: " + adjustment.getReason());
    System.out.println("  调整时间: " + adjustment.getAdjustmentTime());
    System.out.println("  操作员: " + adjustment.getOperator());
} else {
    System.err.println("参数调整失败");
}

// 手动参数调整示例
ProcessController.ParameterAdjustment manualAdjustment = new ProcessController.ParameterAdjustment(
    "bonding_force",
    50.0,
    55.0,
    ProcessController.AdjustmentType.MANUAL,
    "操作员根据经验调整键合力"
)
.setOperator("李四");

boolean manualAdjusted = ProcessController.adjustParameters(context.getProcessId(), manualAdjustment);

if (manualAdjusted) {
    System.out.println("手动参数调整成功");
} else {
    System.err.println("手动参数调整失败");
}
```


### 4.4 工艺异常处理

```java
// 模拟工艺异常
ProcessController.ProcessException exception = new ProcessController.ProcessException(
    ProcessController.ExceptionType.PARAMETER_OUT_OF_RANGE,  // 异常类型
    "键合温度超出设定范围: 350°C",                           // 异常消息
    context.getProcessId(),                                 // 工艺ID
    "STEP_002"                                             // 步骤ID
)
.setEquipmentId("WB-001")
.setSeverity(8)  // 严重性等级(1-10)
.setRecoverable(true)
.setContextData("current_temp", 350.0)
.setContextData("target_temp", 280.0)
.setContextData("temp_limit", 320.0);

// 处理异常
ProcessController.ExceptionHandlingResult handlingResult = ProcessController.handleProcessException(exception);

if (handlingResult != null) {
    System.out.println("异常处理结果:");
    System.out.println("  异常ID: " + handlingResult.getExceptionId());
    System.out.println("  处理成功: " + handlingResult.isHandled());
    System.out.println("  处理动作: " + handlingResult.getActionTaken());
    System.out.println("  过程继续: " + handlingResult.isProcessContinued());
    System.out.println("  处理时间: " + handlingResult.getHandlingTime());
    System.out.println("  处理者: " + handlingResult.getHandler());
    
    // 显示恢复动作
    System.out.println("  恢复动作:");
    for (ProcessController.RecoveryAction action : handlingResult.getRecoveryActions()) {
        System.out.println("    - " + action.getActionName() + ": " + action.getDescription());
        System.out.println("      预估耗时: " + action.getEstimatedDuration() + "ms");
        System.out.println("      需要人工干预: " + action.isRequiresManualIntervention());
    }
    
    // 显示元数据
    System.out.println("  元数据:");
    handlingResult.getMetadata().forEach((key, value) -> 
        System.out.println("    " + key + ": " + value));
} else {
    System.err.println("异常处理失败");
}

// 设备故障异常处理示例
ProcessController.ProcessException equipmentException = new ProcessController.ProcessException(
    ProcessController.ExceptionType.EQUIPMENT_FAILURE,
    "键合头传感器故障",
    context.getProcessId(),
    "STEP_002"
)
.setEquipmentId("WB-001")
.setSeverity(9)
.setRecoverable(false)
.setContextData("error_code", "E1001")
.setContextData("last_operation", "BOND_WIRE");

ProcessController.ExceptionHandlingResult equipmentHandlingResult = 
    ProcessController.handleProcessException(equipmentException);

if (equipmentHandlingResult != null) {
    System.out.println("设备故障处理结果:");
    System.out.println("  处理成功: " + equipmentHandlingResult.isHandled());
    System.out.println("  过程继续: " + equipmentHandlingResult.isProcessContinued());
    
    for (ProcessController.RecoveryAction action : equipmentHandlingResult.getRecoveryActions()) {
        System.out.println("  恢复动作: " + action.getActionName() + " - " + action.getDescription());
    }
} else {
    System.err.println("设备故障处理失败");
}
```


### 4.5 工艺过程追溯

```java
// 生成工艺过程追溯
ProcessController.ProcessTrace trace = ProcessController.generateProcessTrace(context.getProcessId());

if (trace != null) {
    System.out.println("工艺过程追溯:");
    System.out.println("  追溯ID: " + trace.getTraceId());
    System.out.println("  工艺ID: " + trace.getProcessId());
    System.out.println("  事件数量: " + trace.getTraceEvents().size());
    System.out.println("  开始时间: " + trace.getStartTime());
    System.out.println("  是否完整: " + trace.isComplete());
    
    if (trace.getEndTime() != null) {
        System.out.println("  结束时间: " + trace.getEndTime());
    }
    
    // 显示摘要信息
    System.out.println("  摘要信息:");
    trace.getSummary().forEach((key, value) -> 
        System.out.println("    " + key + ": " + value));
    
    // 显示事件详情
    System.out.println("  追溯事件详情:");
    for (ProcessController.TraceEvent event : trace.getTraceEvents()) {
        System.out.println("    时间: " + event.getTimestamp());
        System.out.println("      类型: " + event.getEventType());
        System.out.println("      操作员: " + event.getOperator());
        System.out.println("      属性:");
        event.getAttributes().forEach((key, value) -> 
            System.out.println("        " + key + ": " + value));
        System.out.println();
    }
} else {
    System.err.println("生成工艺过程追溯失败");
}

// 添加自定义追溯事件
ProcessController.TraceEvent customEvent = new ProcessController.TraceEvent("CUSTOM_EVENT", "张三") {
    // 匿名内部类实现
};
customEvent.setAttribute("custom_data", "自定义数据")
          .setAttribute("process_stage", "中间检查");

boolean eventAdded = ProcessController.addTraceEvent(context.getProcessId(), customEvent);

if (eventAdded) {
    System.out.println("自定义追溯事件添加成功");
} else {
    System.err.println("自定义追溯事件添加失败");
}

// 查询追溯事件
ProcessController.TraceQuery query = new ProcessController.TraceQuery()
    .setStartDate(LocalDateTime.now().minusHours(1))
    .setEventType("STEP_EXECUTION")
    .setOperator("系统")
    .setLimit(50);

List<ProcessController.TraceEvent> events = ProcessController.queryTraceEvents(context.getProcessId(), query);

System.out.println("查询到 " + events.size() + " 个追溯事件:");
for (ProcessController.TraceEvent event : events) {
    System.out.println("  - " + event.getEventType() + " at " + event.getTimestamp());
}
```


## 5. 高级使用示例

### 5.1 完整的工艺控制流程

```java
public class CompleteProcessControl {
    public void controlCompleteProcess() {
        try {
            System.out.println("=== 开始完整工艺控制流程 ===");
            
            // 1. 创建执行上下文
            System.out.println("步骤1: 创建执行上下文");
            ProcessController.ExecutionContext context = createContext();
            
            if (context == null) {
                System.err.println("执行上下文创建失败");
                return;
            }
            
            // 2. 执行准备步骤
            System.out.println("\n步骤2: 执行准备步骤");
            executePreparationSteps(context);
            
            // 3. 执行处理步骤
            System.out.println("\n步骤3: 执行处理步骤");
            executeProcessingSteps(context);
            
            // 4. 实时参数调整
            System.out.println("\n步骤4: 实时参数调整");
            performParameterAdjustments(context);
            
            // 5. 处理可能的异常
            System.out.println("\n步骤5: 处理可能的异常");
            handlePotentialExceptions(context);
            
            // 6. 生成过程追溯
            System.out.println("\n步骤6: 生成过程追溯");
            generateProcessTrace(context);
            
            System.out.println("\n=== 工艺控制流程完成 ===");
            
        } catch (Exception e) {
            System.err.println("工艺控制流程中发生错误: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    private ProcessController.ExecutionContext createContext() {
        // 创建引线键合工艺执行上下文
        ProcessController.ExecutionContext context = ProcessController.createExecutionContext(
            "WB_PROCESS_" + System.currentTimeMillis(),
            ProcessController.ProcessType.WIRE_BONDING,
            "IC_PRODUCT_X",
            "BATCH_" + LocalDateTime.now().format(java.time.format.DateTimeFormatter.ofPattern("yyyyMMddHHmmss"))
        );
        
        if (context != null) {
            // 设置全局参数
            context.setGlobalParameter("operator", "张三")
                   .setGlobalParameter("equipment_id", "WB_MACHINE_001")
                   .setGlobalParameter("target_temperature", 280.0)
                   .setGlobalParameter("bonding_force", 50.0)
                   .setGlobalParameter("ultrasonic_power", 75.0)
                   .setGlobalParameter("bonding_time", 30.0)
                   .setMetadata("product_spec", "高性能处理器")
                   .setMetadata("customer", "客户A");
            
            System.out.println("执行上下文创建成功: " + context.getProcessId());
        }
        
        return context;
    }
    
    private void executePreparationSteps(ProcessController.ExecutionContext context) {
        // 创建准备步骤
        ProcessController.ProcessStep prepStep = new ProcessController.ProcessStep(
            "PREP_" + System.currentTimeMillis(), 
            "设备预热", 
            ProcessController.StepType.PREPARATION, 
            1
        )
        .setDescription("将键合设备预热到工作温度")
        .setParameter("target_temp", 280.0)
        .setParameter("heating_rate", 5.0)
        .setExpectedDuration(300000) // 5分钟
        .setMetadata("safety_check_required", true);
        
        // 添加约束
        prepStep.addConstraint(new ProcessController.ProcessConstraint(
            "TEMP_CONSTRAINT", 
            "温度约束", 
            "target_temp >= 250 AND target_temp <= 320"
        ).setDescription("确保目标温度在安全范围内"));
        
        // 执行准备步骤
        ProcessController.ProcessStepResult result = ProcessController.executeStep(prepStep, context);
        
        if (result != null) {
            System.out.println("准备步骤执行" + (result.isSuccess() ? "成功" : "失败"));
            System.out.println("  执行时间: " + result.getExecutionTime() + "ms");
            System.out.println("  消息: " + result.getMessage());
            
            if (result.isSuccess()) {
                // 更新上下文状态
                context.setStatus(ProcessController.ProcessStatus.RUNNING);
                ProcessController.updateExecutionContext(context);
            }
        } else {
            System.err.println("准备步骤执行失败");
        }
    }
    
    private void executeProcessingSteps(ProcessController.ExecutionContext context) {
        // 创建键合步骤
        ProcessController.ProcessStep bondStep = new ProcessController.ProcessStep(
            "BOND_" + System.currentTimeMillis(), 
            "引线键合", 
            ProcessController.StepType.PROCESSING, 
            2
        )
        .setDescription("执行引线键合工艺")
        .setParameter("bond_force", 50.0)
        .setParameter("ultrasonic_power", 75.0)
        .setParameter("bond_time", 30.0)
        .setExpectedDuration(10000) // 10秒
        .setMetadata("quality_check_points", 5);
        
        // 执行键合步骤
        ProcessController.ProcessStepResult result = ProcessController.executeStep(bondStep, context);
        
        if (result != null) {
            System.out.println("键合步骤执行" + (result.isSuccess() ? "成功" : "失败"));
            System.out.println("  执行时间: " + result.getExecutionTime() + "ms");
            
            if (result.isSuccess()) {
                // 模拟质量检查
                simulateQualityCheck(context, bondStep);
            }
        } else {
            System.err.println("键合步骤执行失败");
        }
    }
    
    private void simulateQualityCheck(ProcessController.ExecutionContext context, 
                                   ProcessController.ProcessStep bondStep) {
        // 模拟质量检查步骤
        ProcessController.ProcessStep qcStep = new ProcessController.ProcessStep(
            "QC_" + System.currentTimeMillis(), 
            "质量检查", 
            ProcessController.StepType.QUALITY_CHECK, 
            3
        )
        .setDescription("检查键合质量")
        .setParameter("acceptance_criteria", "bond_strength >= 10g")
        .setParameter("sample_size", 5)
        .setExpectedDuration(5000) // 5秒
        .addDependency(bondStep.getStepId());
        
        ProcessController.ProcessStepResult result = ProcessController.executeStep(qcStep, context);
        
        if (result != null) {
            System.out.println("质量检查步骤执行" + (result.isSuccess() ? "成功" : "失败"));
            System.out.println("  检查结果: " + (Math.random() > 0.1 ? "合格" : "不合格"));
        }
    }
    
    private void performParameterAdjustments(ProcessController.ExecutionContext context) {
        // 模拟根据实时反馈调整参数
        double currentTemp = (Double) context.getGlobalParameter("target_temperature");
        double newTemp = currentTemp + (Math.random() > 0.5 ? 2.0 : -2.0); // 随机调整±2度
        
        ProcessController.ParameterAdjustment adjustment = new ProcessController.ParameterAdjustment(
            "target_temperature",
            currentTemp,
            newTemp,
            ProcessController.AdjustmentType.AUTOMATIC,
            "根据实时质量反馈调整温度"
        )
        .setOperator("系统自动")
        .setMetadata("adjustment_reason", "优化键合质量");
        
        boolean adjusted = ProcessController.adjustParameters(context.getProcessId(), adjustment);
        
        if (adjusted) {
            System.out.println("参数调整成功: " + currentTemp + "°C -> " + newTemp + "°C");
        } else {
            System.err.println("参数调整失败");
        }
    }
    
    private void handlePotentialExceptions(ProcessController.ExecutionContext context) {
        // 模拟5%概率发生参数超限异常
        if (Math.random() < 0.05) {
            ProcessController.ProcessException exception = new ProcessController.ProcessException(
                ProcessController.ExceptionType.PARAMETER_OUT_OF_RANGE,
                "键合温度超出设定范围: 350°C",
                context.getProcessId(),
                "BOND_" + System.currentTimeMillis()
            )
            .setEquipmentId("WB_MACHINE_001")
            .setSeverity(7)
            .setRecoverable(true)
            .setContextData("current_temp", 350.0)
            .setContextData("target_temp", 280.0)
            .setContextData("temp_limit", 320.0);
            
            ProcessController.ExceptionHandlingResult result = 
                ProcessController.handleProcessException(exception);
            
            if (result != null) {
                System.out.println("异常处理" + (result.isHandled() ? "成功" : "失败"));
                System.out.println("  处理动作: " + result.getActionTaken());
                System.out.println("  恢复动作数量: " + result.getRecoveryActions().size());
            }
        } else {
            System.out.println("未发生异常，工艺正常进行");
        }
    }
    
    private void generateProcessTrace(ProcessController.ExecutionContext context) {
        // 生成工艺过程追溯
        ProcessController.ProcessTrace trace = ProcessController.generateProcessTrace(context.getProcessId());
        
        if (trace != null) {
            System.out.println("工艺过程追溯生成成功:");
            System.out.println("  追溯ID: " + trace.getTraceId());
            System.out.println("  事件数量: " + trace.getTraceEvents().size());
            
            // 显示摘要
            System.out.println("  摘要:");
            trace.getSummary().forEach((key, value) -> 
                System.out.println("    " + key + ": " + value));
        } else {
            System.err.println("工艺过程追溯生成失败");
        }
    }
}
```


### 5.2 工艺监控和分析

```java
public class ProcessMonitoringAndAnalysis {
    public void monitorAndAnalyzeProcesses() {
        try {
            System.out.println("=== 工艺监控和分析 ===");
            
            // 模拟监控多个工艺过程
            List<String> processIds = Arrays.asList(
                "PROCESS_001", "PROCESS_002", "PROCESS_003", "PROCESS_004", "PROCESS_005"
            );
            
            for (String processId : processIds) {
                analyzeProcess(processId);
            }
            
            // 统计分析
            performStatisticalAnalysis(processIds);
            
        } catch (Exception e) {
            System.err.println("工艺监控和分析过程中发生错误: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    private void analyzeProcess(String processId) {
        System.out.println("\n分析工艺过程: " + processId);
        
        // 生成追溯信息
        ProcessController.ProcessTrace trace = ProcessController.generateProcessTrace(processId);
        
        if (trace != null) {
            System.out.println("  事件数量: " + trace.getTraceEvents().size());
            System.out.println("  追溯开始时间: " + trace.getStartTime());
            
            if (trace.getEndTime() != null) {
                System.out.println("  追溯结束时间: " + trace.getEndTime());
            }
            
            // 分析事件类型分布
            Map<String, Long> eventTypeCount = trace.getTraceEvents().stream()
                .collect(Collectors.groupingBy(
                    ProcessController.TraceEvent::getEventType,
                    Collectors.counting()
                ));
            
            System.out.println("  事件类型分布:");
            eventTypeCount.forEach((type, count) -> 
                System.out.println("    " + type + ": " + count));
            
            // 查找异常事件
            List<ProcessController.TraceEvent> exceptionEvents = trace.getTraceEvents().stream()
                .filter(event -> "EXCEPTION".equals(event.getEventType()))
                .collect(Collectors.toList());
            
            if (!exceptionEvents.isEmpty()) {
                System.out.println("  发现 " + exceptionEvents.size() + " 个异常事件:");
                for (ProcessController.TraceEvent event : exceptionEvents) {
                    System.out.println("    - 时间: " + event.getTimestamp());
                    System.out.println("      操作员: " + event.getOperator());
                    event.getAttributes().forEach((key, value) -> 
                        System.out.println("        " + key + ": " + value));
                }
            }
        } else {
            System.out.println("  未找到工艺过程追溯信息");
        }
    }
    
    private void performStatisticalAnalysis(List<String> processIds) {
        System.out.println("\n统计分析结果:");
        
        int totalEvents = 0;
        Map<String, Integer> eventTypeStats = new HashMap<>();
        int exceptionCount = 0;
        
        for (String processId : processIds) {
            ProcessController.ProcessTrace trace = ProcessController.generateProcessTrace(processId);
            if (trace != null) {
                totalEvents += trace.getTraceEvents().size();
                
                // 统计事件类型
                for (ProcessController.TraceEvent event : trace.getTraceEvents()) {
                    String eventType = event.getEventType();
                    eventTypeStats.put(eventType, eventTypeStats.getOrDefault(eventType, 0) + 1);
                    
                    if ("EXCEPTION".equals(eventType)) {
                        exceptionCount++;
                    }
                }
            }
        }
        
        System.out.println("  总事件数: " + totalEvents);
        System.out.println("  平均每个工艺事件数: " + (totalEvents / (double) processIds.size()));
        System.out.println("  总异常数: " + exceptionCount);
        System.out.println("  异常率: " + String.format("%.2f%%", (exceptionCount / (double) totalEvents) * 100));
        
        System.out.println("  事件类型统计:");
        eventTypeStats.forEach((type, count) -> 
            System.out.println("    " + type + ": " + count));
    }
    
    public void queryProcessEvents(String processId) {
        try {
            System.out.println("=== 查询工艺事件: " + processId + " ===");
            
            // 创建查询条件
            ProcessController.TraceQuery query = new ProcessController.TraceQuery()
                .setStartDate(LocalDateTime.now().minusHours(24)) // 最近24小时
                .setLimit(100);
            
            List<ProcessController.TraceEvent> events = ProcessController.queryTraceEvents(processId, query);
            
            System.out.println("查询到 " + events.size() + " 个事件:");
            
            // 按时间排序显示
            events.stream()
                .sorted(Comparator.comparing(ProcessController.TraceEvent::getTimestamp))
                .forEach(event -> {
                    System.out.println("  时间: " + event.getTimestamp());
                    System.out.println("    类型: " + event.getEventType());
                    System.out.println("    操作员: " + event.getOperator());
                    
                    if (!event.getAttributes().isEmpty()) {
                        System.out.println("    属性:");
                        event.getAttributes().forEach((key, value) -> 
                            System.out.println("      " + key + ": " + value));
                    }
                    
                    System.out.println();
                });
                
        } catch (Exception e) {
            System.err.println("查询工艺事件过程中发生错误: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```


## 6. 配置参数详解

### 6.1 系统级配置参数

```java
public class ProcessControllerConfig {
    // 缓存超时时间（毫秒）
    public static final long CACHE_TIMEOUT = 30 * 60 * 1000; // 30分钟
    
    // 最大重试次数
    public static final int MAX_RETRY_ATTEMPTS = 3;
    
    // 重试延迟（毫秒）
    public static final long RETRY_DELAY = 1000; // 1秒
    
    // 追溯缓冲区大小
    public static final int TRACE_BUFFER_SIZE = 1000;
    
    // 工艺超时时间（毫秒）
    public static final long PROCESS_TIMEOUT = 24 * 60 * 60 * 1000; // 24小时
}
```


### 6.2 追溯查询配置

```java
ProcessController.TraceQuery query = new ProcessController.TraceQuery()
    .setStartDate(LocalDateTime.now().minusDays(1))    // 开始时间
    .setEndDate(LocalDateTime.now())                   // 结束时间
    .setEventType("STEP_EXECUTION")                    // 事件类型
    .setOperator("张三")                                // 操作员
    .setLimit(100);                                    // 限制数量
```


### 6.3 调整类型配置

```java
// 支持的调整类型
ProcessController.AdjustmentType[] adjustmentTypes = {
    ProcessController.AdjustmentType.AUTOMATIC,      // 自动调整
    ProcessController.AdjustmentType.MANUAL,         // 手动调整
    ProcessController.AdjustmentType.PREDICTIVE,     // 预测调整
    ProcessController.AdjustmentType.CORRECTIVE      // 纠正调整
};

// 设置当前调整器
ProcessController.setCurrentAdjuster(ProcessController.AdjustmentType.AUTOMATIC);
```


## 7. 错误处理

### 7.1 异常处理示例

```java
public class ProcessControllerErrorHandler {
    public void handleProcessOperations() {
        try {
            // 创建执行上下文
            ProcessController.ExecutionContext context = ProcessController.createExecutionContext(
                "TEST_PROCESS_001",
                ProcessController.ProcessType.CUSTOM,
                "PRODUCT_X",
                "BATCH_001"
            );
            
            if (context == null) {
                System.err.println("执行上下文创建失败");
                return;
            }
            
            // 创建并执行步骤
            ProcessController.ProcessStep step = new ProcessController.ProcessStep(
                "STEP_001", "测试步骤", ProcessController.StepType.CUSTOM, 1
            );
            
            ProcessController.ProcessStepResult result = ProcessController.executeStep(step, context);
            
            if (result == null || !result.isSuccess()) {
                System.err.println("步骤执行失败: " + (result != null ? result.getMessage() : "未知错误"));
                
                // 创建异常并处理
                ProcessController.ProcessException exception = new ProcessController.ProcessException(
                    ProcessController.ExceptionType.CUSTOM,
                    "步骤执行失败",
                    context.getProcessId(),
                    step.getStepId()
                );
                
                ProcessController.ExceptionHandlingResult handlingResult = 
                    ProcessController.handleProcessException(exception);
                
                if (handlingResult != null && handlingResult.isHandled()) {
                    System.out.println("异常处理成功: " + handlingResult.getActionTaken());
                }
            } else {
                System.out.println("所有工艺操作成功完成");
            }
            
        } catch (Exception e) {
            System.err.println("工艺操作过程中发生异常: " + e.getMessage());
            
            // 根据异常类型进行不同处理
            if (e instanceof IllegalArgumentException) {
                System.err.println("输入参数错误");
            } else if (e instanceof IllegalStateException) {
                System.err.println("状态错误");
            } else {
                System.err.println("未知错误，请联系技术支持");
            }
            
            // 记录详细错误信息
            e.printStackTrace();
        }
    }
    
    public boolean safeProcessOperation(String processId, ProcessController.ProcessStep step) {
        try {
            ProcessController.ExecutionContext context = ProcessController.getExecutionContext(processId);
            if (context == null) {
                System.err.println("工艺执行上下文未找到: " + processId);
                return false;
            }
            
            // 执行操作
            ProcessController.ProcessStepResult result = ProcessController.executeStep(step, context);
            return result != null && result.isSuccess();
        } catch (Exception e) {
            System.err.println("安全工艺操作失败: " + e.getMessage());
            return false;
        }
    }
}
```


## 8. 最佳实践

### 8.1 工艺数据管理最佳实践

```java
public class ProcessDataManager {
    public boolean validateAndCreateProcess(String processId, 
                                         ProcessController.ProcessType processType, 
                                         String productId,
                                         String batchId,
                                         Map<String, Object> attributes) {
        // 1. 输入验证
        if (processId == null || processId.trim().isEmpty()) {
            System.err.println("工艺ID不能为空");
            return false;
        }
        
        if (processType == null) {
            System.err.println("工艺类型不能为空");
            return false;
        }
        
        if (productId == null || productId.trim().isEmpty()) {
            System.err.println("产品ID不能为空");
            return false;
        }
        
        // 2. 创建执行上下文
        ProcessController.ExecutionContext context = ProcessController.createExecutionContext(
            processId, processType, productId, batchId
        );
        
        if (context == null) {
            System.err.println("执行上下文创建失败");
            return false;
        }
        
        // 3. 设置属性
        if (attributes != null) {
            attributes.forEach((key, value) -> {
                if (key != null && value != null) {
                    context.setMetadata(key, value);
                }
            });
        }
        
        System.out.println("工艺执行上下文创建成功: " + context.getProcessId());
        return true;
    }
    
    public List<ProcessController.ExecutionContext> batchCreateProcesses(
            List<ProcessCreationRequest> requests) {
        List<ProcessController.ExecutionContext> createdContexts = new ArrayList<>();
        
        for (ProcessCreationRequest request : requests) {
            try {
                ProcessController.ExecutionContext context = ProcessController.createExecutionContext(
                    request.getProcessId(),
                    request.getProcessType(),
                    request.getProductId(),
                    request.getBatchId()
                );
                
                if (context != null) {
                    // 设置属性
                    if (request.getAttributes() != null) {
                        request.getAttributes().forEach(context::setMetadata);
                    }
                    
                    // 设置全局参数
                    if (request.getGlobalParameters() != null) {
                        request.getGlobalParameters().forEach(context::setGlobalParameter);
                    }
                    
                    createdContexts.add(context);
                    System.out.println("批量创建工艺成功: " + context.getProcessId());
                } else {
                    System.err.println("批量创建工艺失败: " + request.getProcessId());
                }
            } catch (Exception e) {
                System.err.println("创建工艺时发生错误: " + e.getMessage());
            }
        }
        
        return createdContexts;
    }
    
    // 工艺创建请求类
    public static class ProcessCreationRequest {
        private String processId;
        private ProcessController.ProcessType processType;
        private String productId;
        private String batchId;
        private Map<String, Object> attributes;
        private Map<String, Object> globalParameters;
        
        public ProcessCreationRequest(String processId, 
                                   ProcessController.ProcessType processType, 
                                   String productId, 
                                   String batchId) {
            this.processId = processId;
            this.processType = processType;
            this.productId = productId;
            this.batchId = batchId;
            this.attributes = new HashMap<>();
            this.globalParameters = new HashMap<>();
        }
        
        // Getters and Setters
        public String getProcessId() { return processId; }
        public void setProcessId(String processId) { this.processId = processId; }
        
        public ProcessController.ProcessType getProcessType() { return processType; }
        public void setProcessType(ProcessController.ProcessType processType) { this.processType = processType; }
        
        public String getProductId() { return productId; }
        public void setProductId(String productId) { this.productId = productId; }
        
        public String getBatchId() { return batchId; }
        public void setBatchId(String batchId) { this.batchId = batchId; }
        
        public Map<String, Object> getAttributes() { return attributes; }
        public void setAttribute(String key, Object value) { this.attributes.put(key, value); }
        
        public Map<String, Object> getGlobalParameters() { return globalParameters; }
        public void setGlobalParameter(String key, Object value) { this.globalParameters.put(key, value); }
    }
}
```


### 8.2 性能优化实践

```java
public class ProcessControllerPerformanceOptimizer {
    private final Map<String, ProcessController.ExecutionContext> contextCache = new ConcurrentHashMap<>();
    private final long cacheTimeout = 600000; // 10分钟
    
    public ProcessController.ExecutionContext getCachedContext(String processId) {
        // 检查本地缓存
        CachedContext cached = (CachedContext) contextCache.get(processId);
        
        if (cached != null && !cached.isExpired()) {
            System.out.println("从本地缓存获取执行上下文: " + processId);
            return cached.getContext();
        }
        
        // 从管理器获取
        ProcessController.ExecutionContext context = ProcessController.getExecutionContext(processId);
        
        // 更新本地缓存
        if (context != null) {
            contextCache.put(processId, new CachedContext(context, System.currentTimeMillis() + cacheTimeout));
        }
        
        return context;
    }
    
    public void batchUpdateProcessStatus(List<String> processIds, 
                                      ProcessController.ProcessStatus newStatus,
                                      String description) {
        ExecutorService executor = Executors.newFixedThreadPool(10);
        List<Future<Boolean>> futures = new ArrayList<>();
        
        for (String processId : processIds) {
            Future<Boolean> future = executor.submit(() -> {
                try {
                    ProcessController.ExecutionContext context = ProcessController.getExecutionContext(processId);
                    if (context != null) {
                        context.setStatus(newStatus);
                        return ProcessController.updateExecutionContext(context);
                    }
                    return false;
                } catch (Exception e) {
                    System.err.println("更新工艺状态时发生错误: " + e.getMessage());
                    return false;
                }
            });
            futures.add(future);
        }
        
        // 等待所有更新完成
        int successCount = 0;
        for (int i = 0; i < futures.size(); i++) {
            try {
                if (futures.get(i).get(30, TimeUnit.SECONDS)) {
                    successCount++;
                }
            } catch (Exception e) {
                System.err.println("更新工艺 " + processIds.get(i) + " 状态时发生错误: " + e.getMessage());
            }
        }
        
        executor.shutdown();
        System.out.println("批量状态更新完成: " + successCount + "/" + processIds.size() + " 成功");
    }
    
    // 缓存上下文类
    private static class CachedContext {
        private final ProcessController.ExecutionContext context;
        private final long expireTime;
        
        public CachedContext(ProcessController.ExecutionContext context, long expireTime) {
            this.context = context;
            this.expireTime = expireTime;
        }
        
        public ProcessController.ExecutionContext getContext() { return context; }
        public boolean isExpired() { return System.currentTimeMillis() > expireTime; }
    }
}
```


## 9. 系统集成

### 9.1 与Web服务集成

```java
@RestController
@RequestMapping("/api/processes")
public class ProcessControllerWebService {
    
    @PostMapping("/context/create")
    public ResponseEntity<?> createContext(@RequestBody ProcessCreationRequest request) {
        try {
            ProcessController.ExecutionContext context = ProcessController.createExecutionContext(
                request.getProcessId(),
                ProcessController.ProcessType.valueOf(request.getProcessType()),
                request.getProductId(),
                request.getBatchId()
            );
            
            if (context != null) {
                // 设置属性
                if (request.getAttributes() != null) {
                    request.getAttributes().forEach((key, value) -> {
                        if (key != null && value != null) {
                            context.setMetadata(key, value.toString());
                        }
                    });
                }
                
                // 设置全局参数
                if (request.getGlobalParameters() != null) {
                    request.getGlobalParameters().forEach((key, value) -> {
                        if (key != null && value != null) {
                            context.setGlobalParameter(key, value);
                        }
                    });
                }
                
                return ResponseEntity.ok(convertToResponse(context));
            } else {
                return ResponseEntity.badRequest().body("执行上下文创建失败");
            }
        } catch (Exception e) {
            return ResponseEntity.status(500).body("服务器内部错误: " + e.getMessage());
        }
    }
    
    @PostMapping("/{processId}/steps/execute")
    public ResponseEntity<?> executeStep(@PathVariable String processId,
                                       @RequestBody StepExecutionRequest request) {
        try {
            ProcessController.ExecutionContext context = ProcessController.getExecutionContext(processId);
            if (context == null) {
                return ResponseEntity.notFound().build();
            }
            
            ProcessController.ProcessStep step = convertToProcessStep(request.getStep());
            ProcessController.ProcessStepResult result = ProcessController.executeStep(step, context);
            
            if (result != null) {
                return ResponseEntity.ok(convertToResponse(result));
            } else {
                return ResponseEntity.badRequest().body("步骤执行失败");
            }
        } catch (Exception e) {
            return ResponseEntity.status(500).body("步骤执行失败: " + e.getMessage());
        }
    }
    
    @PostMapping("/{processId}/parameters/adjust")
    public ResponseEntity<?> adjustParameters(@PathVariable String processId,
                                            @RequestBody ParameterAdjustmentRequest request) {
        try {
            ProcessController.ParameterAdjustment adjustment = new ProcessController.ParameterAdjustment(
                request.getParameterName(),
                request.getOldValue(),
                request.getNewValue(),
                ProcessController.AdjustmentType.valueOf(request.getAdjustmentType()),
                request.getReason()
            )
            .setOperator(request.getOperator());
            
            boolean adjusted = ProcessController.adjustParameters(processId, adjustment);
            
            if (adjusted) {
                return ResponseEntity.ok("参数调整成功");
            } else {
                return ResponseEntity.badRequest().body("参数调整失败");
            }
        } catch (Exception e) {
            return ResponseEntity.status(500).body("参数调整失败: " + e.getMessage());
        }
    }
    
    @PostMapping("/exceptions/handle")
    public ResponseEntity<?> handleException(@RequestBody ExceptionHandlingRequest request) {
        try {
            ProcessController.ProcessException exception = new ProcessController.ProcessException(
                ProcessController.ExceptionType.valueOf(request.getExceptionType()),
                request.getMessage(),
                request.getProcessId(),
                request.getStepId()
            )
            .setEquipmentId(request.getEquipmentId())
            .setSeverity(request.getSeverity())
            .setRecoverable(request.isRecoverable());
            
            if (request.getContextData() != null) {
                request.getContextData().forEach(exception::setContextData);
            }
            
            ProcessController.ExceptionHandlingResult result = ProcessController.handleProcessException(exception);
            
            if (result != null) {
                return ResponseEntity.ok(convertToResponse(result));
            } else {
                return ResponseEntity.badRequest().body("异常处理失败");
            }
        } catch (Exception e) {
            return ResponseEntity.status(500).body("异常处理失败: " + e.getMessage());
        }
    }
    
    @GetMapping("/{processId}/trace")
    public ResponseEntity<?> generateProcessTrace(@PathVariable String processId) {
        try {
            ProcessController.ProcessTrace trace = ProcessController.generateProcessTrace(processId);
            
            if (trace != null) {
                return ResponseEntity.ok(convertToResponse(trace));
            } else {
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            return ResponseEntity.status(500).body("生成工艺追溯失败: " + e.getMessage());
        }
    }
    
    // 请求和响应类
    public static class ProcessCreationRequest {
        private String processId;
        private String processType;
        private String productId;
        private String batchId;
        private Map<String, Object> attributes;
        private Map<String, Object> globalParameters;
        
        // Getters and Setters
        public String getProcessId() { return processId; }
        public void setProcessId(String processId) { this.processId = processId; }
        
        public String getProcessType() { return processType; }
        public void setProcessType(String processType) { this.processType = processType; }
        
        public String getProductId() { return productId; }
        public void setProductId(String productId) { this.productId = productId; }
        
        public String getBatchId() { return batchId; }
        public void setBatchId(String batchId) { this.batchId = batchId; }
        
        public Map<String, Object> getAttributes() { return attributes; }
        public void setAttributes(Map<String, Object> attributes) { this.attributes = attributes; }
        
        public Map<String, Object> getGlobalParameters() { return globalParameters; }
        public void setGlobalParameters(Map<String, Object> globalParameters) { this.globalParameters = globalParameters; }
    }
    
    public static class StepExecutionRequest {
        private ProcessStepRequest step;
        
        // Getters and Setters
        public ProcessStepRequest getStep() { return step; }
        public void setStep(ProcessStepRequest step) { this.step = step; }
    }
    
    public static class ProcessStepRequest {
        private String stepId;
        private String stepName;
        private String stepType;
        private int stepNumber;
        private String description;
        private Map<String, Object> parameters;
        private long expectedDuration;
        private Map<String, Object> conditions;
        private List<String> dependencies;
        
        // Getters and Setters
        public String getStepId() { return stepId; }
        public void setStepId(String stepId) { this.stepId = stepId; }
        
        public String getStepName() { return stepName; }
        public void setStepName(String stepName) { this.stepName = stepName; }
        
        public String getStepType() { return stepType; }
        public void setStepType(String stepType) { this.stepType = stepType; }
        
        public int getStepNumber() { return stepNumber; }
        public void setStepNumber(int stepNumber) { this.stepNumber = stepNumber; }
        
        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }
        
        public Map<String, Object> getParameters() { return parameters; }
        public void setParameters(Map<String, Object> parameters) { this.parameters = parameters; }
        
        public long getExpectedDuration() { return expectedDuration; }
        public void setExpectedDuration(long expectedDuration) { this.expectedDuration = expectedDuration; }
        
        public Map<String, Object> getConditions() { return conditions; }
        public void setConditions(Map<String, Object> conditions) { this.conditions = conditions; }
        
        public List<String> getDependencies() { return dependencies; }
        public void setDependencies(List<String> dependencies) { this.dependencies = dependencies; }
    }
    
    public static class ParameterAdjustmentRequest {
        private String parameterName;
        private Object oldValue;
        private Object newValue;
        private String adjustmentType;
        private String reason;
        private String operator;
        
        // Getters and Setters
        public String getParameterName() { return parameterName; }
        public void setParameterName(String parameterName) { this.parameterName = parameterName; }
        
        public Object getOldValue() { return oldValue; }
        public void setOldValue(Object oldValue) { this.oldValue = oldValue; }
        
        public Object getNewValue() { return newValue; }
        public void setNewValue(Object newValue) { this.newValue = newValue; }
        
        public String getAdjustmentType() { return adjustmentType; }
        public void setAdjustmentType(String adjustmentType) { this.adjustmentType = adjustmentType; }
        
        public String getReason() { return reason; }
        public void setReason(String reason) { this.reason = reason; }
        
        public String getOperator() { return operator; }
        public void setOperator(String operator) { this.operator = operator; }
    }
    
    public static class ExceptionHandlingRequest {
        private String exceptionType;
        private String message;
        private String processId;
        private String stepId;
        private String equipmentId;
        private int severity;
        private boolean recoverable;
        private Map<String, Object> contextData;
        
        // Getters and Setters
        public String getExceptionType() { return exceptionType; }
        public void setExceptionType(String exceptionType) { this.exceptionType = exceptionType; }
        
        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }
        
        public String getProcessId() { return processId; }
        public void setProcessId(String processId) { this.processId = processId; }
        
        public String getStepId() { return stepId; }
        public void setStepId(String stepId) { this.stepId = stepId; }
        
        public String getEquipmentId() { return equipmentId; }
        public void setEquipmentId(String equipmentId) { this.equipmentId = equipmentId; }
        
        public int getSeverity() { return severity; }
        public void setSeverity(int severity) { this.severity = severity; }
        
        public boolean isRecoverable() { return recoverable; }
        public void setRecoverable(boolean recoverable) { this.recoverable = recoverable; }
        
        public Map<String, Object> getContextData() { return contextData; }
        public void setContextData(Map<String, Object> contextData) { this.contextData = contextData; }
    }
    
    // 转换方法
    private Object convertToResponse(ProcessController.ExecutionContext context) {
        // 实现执行上下文到响应对象的转换
        return new Object();
    }
    
    private Object convertToResponse(ProcessController.ProcessStepResult result) {
        // 实现步骤结果到响应对象的转换
        return new Object();
    }
    
    private Object convertToResponse(ProcessController.ExceptionHandlingResult result) {
        // 实现异常处理结果到响应对象的转换
        return new Object();
    }
    
    private Object convertToResponse(ProcessController.ProcessTrace trace) {
        // 实现工艺追溯到响应对象的转换
        return new Object();
    }
    
    private ProcessController.ProcessStep convertToProcessStep(ProcessStepRequest request) {
        // 实现请求到ProcessStep对象的转换
        ProcessController.ProcessStep step = new ProcessController.ProcessStep(
            request.getStepId(),
            request.getStepName(),
            ProcessController.StepType.valueOf(request.getStepType()),
            request.getStepNumber()
        )
        .setDescription(request.getDescription())
        .setExpectedDuration(request.getExpectedDuration());
        
        if (request.getParameters() != null) {
            request.getParameters().forEach(step::setParameter);
        }
        
        if (request.getConditions() != null) {
            request.getConditions().forEach(step::setCondition);
        }
        
        if (request.getDependencies() != null) {
            request.getDependencies().forEach(step::addDependency);
        }
        
        return step;
    }
}
```


### 9.2 与调度系统集成

```java
@Component
public class ScheduledProcessTasks {
    
    // 每小时检查长时间运行的工艺
    @Scheduled(fixedRate = 3600000) // 1小时
    public void checkLongRunningProcesses() {
        System.out.println("开始检查长时间运行的工艺...");
        
        try {
            // 这里应该查询所有运行中的工艺，检查是否有超时的
            // 由于示例中没有实际的存储机制，这里只是演示
            
            LocalDateTime timeoutThreshold = LocalDateTime.now().minusHours(2); // 2小时超时
            
            System.out.println("检查时间阈值: " + timeoutThreshold);
            System.out.println("长时间运行工艺检查完成");
        } catch (Exception e) {
            System.err.println("长时间运行工艺检查失败: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    // 每天凌晨清理过期缓存
    @Scheduled(cron = "0 0 2 * * ?")
    public void cleanupExpiredCache() {
        System.out.println("开始清理过期缓存...");
        
        try {
            // 获取缓存统计信息
            ProcessController.CacheStatistics stats = ProcessController.getCacheStatistics();
            
            System.out.println("清理前缓存统计:");
            System.out.println("  上下文缓存大小: " + stats.getContextCacheSize());
            System.out.println("  追溯缓存大小: " + stats.getTraceCacheSize());
            
            // ProcessController内部会自动清理过期缓存
            System.out.println("过期缓存清理完成");
        } catch (Exception e) {
            System.err.println("过期缓存清理失败: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    // 每周生成工艺统计报告
    @Scheduled(cron = "0 0 3 * * MON") // 每周一凌晨3点
    public void generateWeeklyProcessReport() {
        System.out.println("开始生成周工艺统计报告...");
        
        try {
            LocalDateTime weekAgo = LocalDateTime.now().minusWeeks(1);
            
            // 这里应该查询上周的工艺数据并生成报告
            // 由于示例中没有实际的存储机制，这里只是演示
            
            System.out.println("统计时间范围: " + weekAgo + " 到 " + LocalDateTime.now());
            System.out.println("周工艺统计报告生成完成");
        } catch (Exception e) {
            System.err.println("周工艺统计报告生成失败: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```


这个使用说明文档涵盖了 [ProcessController](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\semiconductor\process\controller\ProcessController.java#L34-L1587) 的主要功能和使用方法，可以帮助开发者快速上手并正确使用该工艺过程控制工具类。