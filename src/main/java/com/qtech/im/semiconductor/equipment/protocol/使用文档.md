# SecsGemKit 使用说明文档

## 1. 概述

[SecsGemKit](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\semiconductor\equipment\protocol\SecsGemKit.java#L26-L136) 是一个专业的SECS/GEM协议工具类，专门用于半导体封测设备与工厂自动化系统之间的通信。该工具解决了SECS-I和HSMS协议通信复杂、消息格式处理困难、连接管理不完善和错误处理不统一等问题。

## 2. 核心功能

### 2.1 SECS消息解析
- 解析原始字节数据为SECS消息对象
- 支持SECS-I和HSMS协议消息格式
- 提供完整的消息头和消息体解析

### 2.2 SECS消息构建
- 构建符合SEMI标准的SECS消息
- 支持自定义Stream、Function和设备ID
- 灵活的消息体数据封装

### 2.3 SECS消息发送
- 通过连接对象发送SECS消息
- 支持自定义超时时间
- 完善的响应处理机制

### 2.4 连接管理
- 抽象的连接接口设计
- 支持多种通信协议实现
- 完善的连接状态管理

## 3. 支持的协议和消息类型

### 3.1 支持的协议
```java
// SECS-I 和 HSMS 协议
// 通过 SecsConnection 接口支持多种连接实现
```


### 3.2 消息结构
```java
// SECS消息结构
public static class SecsMessage {
    private final byte[] header;  // 10字节消息头
    private final byte[] body;    // 可变长度消息体
}
```


## 4. 基本使用方法

### 4.1 消息解析

```java
// 解析SECS消息
public class SecsMessageParsingExample {
    public void parseSecsMessages() {
        System.out.println("开始SECS消息解析示例...");
        
        // 模拟原始SECS消息数据
        byte[] rawData = createSampleSecsMessageData();
        
        // 解析SECS消息
        SecsGemKit.SecsMessage message = SecsGemKit.parseSecsMessage(rawData);
        
        if (message != null) {
            System.out.println("SECS消息解析成功:");
            System.out.println("  消息头: " + bytesToHex(message.getHeader()));
            System.out.println("  消息体长度: " + message.getBody().length + " 字节");
            System.out.println("  完整消息长度: " + message.toByteArray().length + " 字节");
            
            // 解析消息头信息
            parseMessageHeader(message.getHeader());
        } else {
            System.err.println("SECS消息解析失败");
        }
    }
    
    private byte[] createSampleSecsMessageData() {
        // 创建一个模拟的SECS消息数据
        ByteBuffer buffer = ByteBuffer.allocate(20);
        
        // 消息头 (10字节)
        buffer.putShort((short) 123);        // 设备ID
        buffer.put((byte) 1);                // Stream
        buffer.put((byte) 1);                // Function
        buffer.put((byte) 0x80);             // P-Type = 1 (SECS-II)
        buffer.put((byte) 0x00);             // unused
        buffer.putInt(10);                   // 数据长度
        
        // 消息体 (10字节)
        buffer.put("Hello SEC".getBytes());
        
        return buffer.array();
    }
    
    private void parseMessageHeader(byte[] header) {
        if (header.length >= 10) {
            ByteBuffer buffer = ByteBuffer.wrap(header);
            int deviceId = buffer.getShort();
            int stream = buffer.get() & 0x7F;
            int function = buffer.get() & 0x7F;
            int pType = buffer.get() & 0x80;
            int dataLength = buffer.getInt();
            
            System.out.println("  解析的消息头信息:");
            System.out.println("    设备ID: " + deviceId);
            System.out.println("    Stream: " + stream);
            System.out.println("    Function: " + function);
            System.out.println("    P-Type: " + (pType == 0x80 ? "SECS-II" : "Unknown"));
            System.out.println("    数据长度: " + dataLength);
        }
    }
    
    private String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format("%02X ", b));
        }
        return sb.toString().trim();
    }
}
```


### 4.2 消息构建

```java
// 构建SECS消息
public class SecsMessageBuildingExample {
    public void buildSecsMessages() {
        System.out.println("开始SECS消息构建示例...");
        
        // 1. 构建S1F1消息 (设备状态请求)
        SecsGemKit.SecsMessage s1f1Message = SecsGemKit.buildSecsMessage(
            1, 1, 
            SecsGemKit.DEFAULT_DEVICE_ID, 
            "Are You Online?".getBytes()
        );
        
        if (s1f1Message != null) {
            System.out.println("S1F1消息构建成功:");
            System.out.println("  Stream: 1, Function: 1");
            System.out.println("  设备ID: " + SecsGemKit.DEFAULT_DEVICE_ID);
            System.out.println("  消息体: " + new String(s1f1Message.getBody()));
        }
        
        // 2. 构建S2F17消息 (日期时间请求)
        SecsGemKit.SecsMessage s2f17Message = SecsGemKit.buildSecsMessage(
            2, 17, 
            SecsGemKit.DEFAULT_DEVICE_ID, 
            null  // 无消息体
        );
        
        if (s2f17Message != null) {
            System.out.println("\nS2F17消息构建成功:");
            System.out.println("  Stream: 2, Function: 17");
            System.out.println("  设备ID: " + SecsGemKit.DEFAULT_DEVICE_ID);
            System.out.println("  消息体长度: " + s2f17Message.getBody().length);
        }
        
        // 3. 构建S6F11消息 (数据收集)
        byte[] dataCollectionBody = createDataCollectionBody();
        SecsGemKit.SecsMessage s6f11Message = SecsGemKit.buildSecsMessage(
            6, 11, 
            456,  // 自定义设备ID
            dataCollectionBody
        );
        
        if (s6f11Message != null) {
            System.out.println("\nS6F11消息构建成功:");
            System.out.println("  Stream: 6, Function: 11");
            System.out.println("  设备ID: 456");
            System.out.println("  消息体长度: " + s6f11Message.getBody().length);
        }
        
        // 4. 构建自定义消息
        SecsGemKit.SecsMessage customMessage = SecsGemKit.buildSecsMessage(
            10, 5, 
            789,  // 自定义设备ID
            "Custom Message Data".getBytes()
        );
        
        if (customMessage != null) {
            System.out.println("\n自定义消息构建成功:");
            System.out.println("  Stream: 10, Function: 5");
            System.out.println("  设备ID: 789");
            System.out.println("  消息体: " + new String(customMessage.getBody()));
        }
    }
    
    private byte[] createDataCollectionBody() {
        // 创建模拟的数据收集消息体
        ByteBuffer buffer = ByteBuffer.allocate(20);
        buffer.putLong(System.currentTimeMillis());  // 时间戳
        buffer.putInt(1001);  // 数据ID
        buffer.putDouble(98.5);  // 数据值
        return buffer.array();
    }
}
```


### 4.3 消息发送

```java
// 发送SECS消息
public class SecsMessageSendingExample {
    public void sendSecsMessages() {
        System.out.println("开始SECS消息发送示例...");
        
        // 创建模拟连接对象
        SecsGemKit.SecsConnection connection = new MockSecsConnection();
        
        // 1. 发送S1F1消息
        SecsGemKit.SecsMessage s1f1Message = SecsGemKit.buildSecsMessage(
            1, 1, 
            SecsGemKit.DEFAULT_DEVICE_ID, 
            "Are You Online?".getBytes()
        );
        
        if (s1f1Message != null) {
            System.out.println("发送S1F1消息...");
            SecsGemKit.SecsMessage response = SecsGemKit.sendSecsMessage(
                connection, 
                s1f1Message, 
                SecsGemKit.DEFAULT_TIMEOUT
            );
            
            if (response != null) {
                System.out.println("收到响应消息:");
                System.out.println("  响应体: " + new String(response.getBody()));
            } else {
                System.err.println("发送S1F1消息失败或超时");
            }
        }
        
        // 2. 发送S2F17消息
        SecsGemKit.SecsMessage s2f17Message = SecsGemKit.buildSecsMessage(
            2, 17, 
            SecsGemKit.DEFAULT_DEVICE_ID, 
            null
        );
        
        if (s2f17Message != null) {
            System.out.println("\n发送S2F17消息...");
            SecsGemKit.SecsMessage response = SecsGemKit.sendSecsMessage(
                connection, 
                s2f17Message, 
                3000  // 3秒超时
            );
            
            if (response != null) {
                System.out.println("收到响应消息:");
                System.out.println("  响应体长度: " + response.getBody().length + " 字节");
            } else {
                System.err.println("发送S2F17消息失败或超时");
            }
        }
        
        // 3. 发送带自定义设备ID的消息
        SecsGemKit.SecsMessage customMessage = SecsGemKit.buildSecsMessage(
            5, 10, 
            123, 
            "Equipment Data".getBytes()
        );
        
        if (customMessage != null) {
            System.out.println("\n发送自定义消息...");
            SecsGemKit.SecsMessage response = SecsGemKit.sendSecsMessage(
                connection, 
                customMessage, 
                SecsGemKit.DEFAULT_TIMEOUT
            );
            
            if (response != null) {
                System.out.println("收到响应消息:");
                System.out.println("  响应体: " + new String(response.getBody()));
            } else {
                System.err.println("发送自定义消息失败或超时");
            }
        }
    }
    
    // 模拟SECS连接实现
    private static class MockSecsConnection implements SecsGemKit.SecsConnection {
        @Override
        public byte[] send(byte[] message, int timeout) throws Exception {
            System.out.println("  模拟发送消息，长度: " + message.length + " 字节，超时: " + timeout + "ms");
            
            // 模拟网络延迟
            Thread.sleep(100 + (long) (Math.random() * 200));
            
            // 创建模拟响应
            if (message.length >= 10) {
                ByteBuffer buffer = ByteBuffer.wrap(message);
                buffer.position(2); // 跳过设备ID
                int stream = buffer.get() & 0x7F;
                int function = buffer.get() & 0x7F;
                
                // 根据请求消息创建响应
                String responseText;
                if (stream == 1 && function == 1) {
                    responseText = "Online";
                } else if (stream == 2 && function == 17) {
                    responseText = "2025-08-21 10:30:00";
                } else {
                    responseText = "ACK";
                }
                
                return responseText.getBytes();
            }
            
            return "OK".getBytes();
        }
        
        @Override
        public void close() {
            System.out.println("  模拟关闭连接");
        }
        
        @Override
        public boolean isConnected() {
            // 模拟95%的连接成功率
            return Math.random() > 0.05;
        }
    }
}
```


## 5. 高级使用示例

### 5.1 完整的SECS/GEM通信流程

```java
public class CompleteSecsGemCommunication {
    public void executeCompleteCommunication() {
        try {
            System.out.println("=== 开始完整的SECS/GEM通信流程 ===");
            
            // 步骤1: 建立连接
            System.out.println("\n步骤1: 建立SECS连接");
            SecsGemKit.SecsConnection connection = establishConnection();
            
            if (connection == null || !connection.isConnected()) {
                System.err.println("无法建立SECS连接");
                return;
            }
            
            // 步骤2: 发送设备状态查询
            System.out.println("\n步骤2: 查询设备状态");
            queryEquipmentStatus(connection);
            
            // 步骤3: 获取设备时间
            System.out.println("\n步骤3: 获取设备时间");
            getEquipmentTime(connection);
            
            // 步骤4: 发送数据收集消息
            System.out.println("\n步骤4: 发送数据收集");
            sendDataCollection(connection);
            
            // 步骤5: 发送控制命令
            System.out.println("\n步骤5: 发送控制命令");
            sendControlCommand(connection);
            
            // 步骤6: 关闭连接
            System.out.println("\n步骤6: 关闭连接");
            closeConnection(connection);
            
            System.out.println("\n=== SECS/GEM通信流程完成 ===");
            
        } catch (Exception e) {
            System.err.println("SECS/GEM通信流程执行过程中发生错误: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    private SecsGemKit.SecsConnection establishConnection() {
        System.out.println("建立SECS连接...");
        
        // 在实际应用中，这里应该创建真实的连接对象
        // 例如: new HsmsConnection(host, port) 或 new SecsIConnection(port)
        SecsGemKit.SecsConnection connection = new MockConnection();
        
        if (connection.isConnected()) {
            System.out.println("SECS连接建立成功");
        } else {
            System.err.println("SECS连接建立失败");
        }
        
        return connection;
    }
    
    private void queryEquipmentStatus(SecsGemKit.SecsConnection connection) {
        System.out.println("查询设备状态...");
        
        // 构建S1F1消息 (设备状态请求)
        SecsGemKit.SecsMessage message = SecsGemKit.buildSecsMessage(
            1, 1, 
            SecsGemKit.DEFAULT_DEVICE_ID, 
            "Are You Online?".getBytes()
        );
        
        if (message != null) {
            SecsGemKit.SecsMessage response = SecsGemKit.sendSecsMessage(
                connection, 
                message, 
                SecsGemKit.DEFAULT_TIMEOUT
            );
            
            if (response != null) {
                String status = new String(response.getBody());
                System.out.println("设备状态: " + status);
            } else {
                System.err.println("设备状态查询失败");
            }
        }
    }
    
    private void getEquipmentTime(SecsGemKit.SecsConnection connection) {
        System.out.println("获取设备时间...");
        
        // 构建S2F17消息 (日期时间请求)
        SecsGemKit.SecsMessage message = SecsGemKit.buildSecsMessage(
            2, 17, 
            SecsGemKit.DEFAULT_DEVICE_ID, 
            null
        );
        
        if (message != null) {
            SecsGemKit.SecsMessage response = SecsGemKit.sendSecsMessage(
                connection, 
                message, 
                SecsGemKit.DEFAULT_TIMEOUT
            );
            
            if (response != null) {
                String time = new String(response.getBody());
                System.out.println("设备时间: " + time);
            } else {
                System.err.println("获取设备时间失败");
            }
        }
    }
    
    private void sendDataCollection(SecsGemKit.SecsConnection connection) {
        System.out.println("发送数据收集消息...");
        
        // 构建S6F11消息 (数据收集)
        byte[] body = createDataCollectionBody();
        SecsGemKit.SecsMessage message = SecsGemKit.buildSecsMessage(
            6, 11, 
            101,  // 设备ID
            body
        );
        
        if (message != null) {
            SecsGemKit.SecsMessage response = SecsGemKit.sendSecsMessage(
                connection, 
                message, 
                SecsGemKit.DEFAULT_TIMEOUT
            );
            
            if (response != null) {
                System.out.println("数据收集发送成功");
            } else {
                System.err.println("数据收集发送失败");
            }
        }
    }
    
    private void sendControlCommand(SecsGemKit.SecsConnection connection) {
        System.out.println("发送控制命令...");
        
        // 构建控制命令消息
        SecsGemKit.SecsMessage message = SecsGemKit.buildSecsMessage(
            7, 5, 
            101,  // 设备ID
            "START_PROCESS".getBytes()
        );
        
        if (message != null) {
            SecsGemKit.SecsMessage response = SecsGemKit.sendSecsMessage(
                connection, 
                message, 
                SecsGemKit.DEFAULT_TIMEOUT
            );
            
            if (response != null) {
                String ack = new String(response.getBody());
                System.out.println("控制命令响应: " + ack);
            } else {
                System.err.println("控制命令发送失败");
            }
        }
    }
    
    private void closeConnection(SecsGemKit.SecsConnection connection) {
        System.out.println("关闭SECS连接...");
        connection.close();
        System.out.println("SECS连接已关闭");
    }
    
    private byte[] createDataCollectionBody() {
        ByteBuffer buffer = ByteBuffer.allocate(30);
        buffer.putLong(System.currentTimeMillis());
        buffer.putInt(2001);  // 数据点ID
        buffer.putDouble(99.2);  // 温度值
        buffer.putDouble(45.5);  // 湿度值
        return buffer.array();
    }
    
    // 模拟连接实现
    private static class MockConnection implements SecsGemKit.SecsConnection {
        private boolean connected = true;
        
        @Override
        public byte[] send(byte[] message, int timeout) throws Exception {
            // 模拟网络延迟
            Thread.sleep(50 + (long) (Math.random() * 150));
            
            // 根据消息类型创建响应
            if (message.length >= 10) {
                ByteBuffer buffer = ByteBuffer.wrap(message);
                buffer.position(2);
                int stream = buffer.get() & 0x7F;
                int function = buffer.get() & 0x7F;
                
                String response;
                switch (stream) {
                    case 1:
                        if (function == 1) response = "ONLINE";
                        else response = "ACK";
                        break;
                    case 2:
                        if (function == 17) response = "2025-08-21 10:30:00";
                        else response = "ACK";
                        break;
                    case 6:
                        if (function == 11) response = "DATA_RECEIVED";
                        else response = "ACK";
                        break;
                    case 7:
                        if (function == 5) response = "COMMAND_ACCEPTED";
                        else response = "ACK";
                        break;
                    default:
                        response = "OK";
                }
                
                return response.getBytes();
            }
            
            return "OK".getBytes();
        }
        
        @Override
        public void close() {
            connected = false;
        }
        
        @Override
        public boolean isConnected() {
            return connected;
        }
    }
}
```


### 5.2 SECS/GEM消息处理和分析

```java
public class SecsGemMessageAnalysis {
    public void analyzeSecsMessages() {
        System.out.println("=== SECS/GEM消息分析 ===");
        
        // 分析不同类型的消息
        analyzeS1F1Message();
        analyzeS2F17Message();
        analyzeS6F11Message();
        analyzeCustomMessage();
        
        System.out.println("=== 消息分析完成 ===");
    }
    
    private void analyzeS1F1Message() {
        System.out.println("\n分析S1F1消息 (设备状态请求):");
        
        // 构建S1F1消息
        SecsGemKit.SecsMessage message = SecsGemKit.buildSecsMessage(
            1, 1, 
            SecsGemKit.DEFAULT_DEVICE_ID, 
            "Are You Online?".getBytes()
        );
        
        if (message != null) {
            System.out.println("  消息构建成功");
            System.out.println("    Stream: 1");
            System.out.println("    Function: 1");
            System.out.println("    设备ID: " + SecsGemKit.DEFAULT_DEVICE_ID);
            System.out.println("    消息体: " + new String(message.getBody()));
            
            // 分析消息结构
            analyzeMessageStructure(message);
        }
    }
    
    private void analyzeS2F17Message() {
        System.out.println("\n分析S2F17消息 (日期时间请求):");
        
        // 构建S2F17消息
        SecsGemKit.SecsMessage message = SecsGemKit.buildSecsMessage(
            2, 17, 
            SecsGemKit.DEFAULT_DEVICE_ID, 
            null
        );
        
        if (message != null) {
            System.out.println("  消息构建成功");
            System.out.println("    Stream: 2");
            System.out.println("    Function: 17");
            System.out.println("    设备ID: " + SecsGemKit.DEFAULT_DEVICE_ID);
            System.out.println("    消息体长度: " + message.getBody().length);
            
            // 分析消息结构
            analyzeMessageStructure(message);
        }
    }
    
    private void analyzeS6F11Message() {
        System.out.println("\n分析S6F11消息 (数据收集):");
        
        // 构建S6F11消息
        byte[] body = createSampleDataBody();
        SecsGemKit.SecsMessage message = SecsGemKit.buildSecsMessage(
            6, 11, 
            123, 
            body
        );
        
        if (message != null) {
            System.out.println("  消息构建成功");
            System.out.println("    Stream: 6");
            System.out.println("    Function: 11");
            System.out.println("    设备ID: 123");
            System.out.println("    消息体长度: " + message.getBody().length);
            
            // 分析消息结构
            analyzeMessageStructure(message);
            
            // 分析消息体内容
            analyzeMessageBody(message.getBody());
        }
    }
    
    private void analyzeCustomMessage() {
        System.out.println("\n分析自定义消息:");
        
        // 构建自定义消息
        SecsGemKit.SecsMessage message = SecsGemKit.buildSecsMessage(
            10, 5, 
            456, 
            "Custom Equipment Data".getBytes()
        );
        
        if (message != null) {
            System.out.println("  消息构建成功");
            System.out.println("    Stream: 10");
            System.out.println("    Function: 5");
            System.out.println("    设备ID: 456");
            System.out.println("    消息体: " + new String(message.getBody()));
            
            // 分析消息结构
            analyzeMessageStructure(message);
        }
    }
    
    private void analyzeMessageStructure(SecsGemKit.SecsMessage message) {
        byte[] header = message.getHeader();
        if (header.length >= 10) {
            ByteBuffer buffer = ByteBuffer.wrap(header);
            int deviceId = buffer.getShort();
            int stream = buffer.get() & 0x7F;
            int function = buffer.get() & 0x7F;
            int pType = buffer.get();
            buffer.get(); // Skip unused byte
            int dataLength = buffer.getInt();
            
            System.out.println("    消息头分析:");
            System.out.println("      设备ID: " + deviceId);
            System.out.println("      Stream: " + stream);
            System.out.println("      Function: " + function);
            System.out.println("      P-Type: " + (pType == (byte)0x80 ? "SECS-II" : "Unknown"));
            System.out.println("      数据长度: " + dataLength);
        }
    }
    
    private void analyzeMessageBody(byte[] body) {
        System.out.println("    消息体分析:");
        System.out.println("      原始数据长度: " + body.length + " 字节");
        
        // 尝试解析为数值数据
        if (body.length >= 16) {
            ByteBuffer buffer = ByteBuffer.wrap(body);
            try {
                long timestamp = buffer.getLong();
                int dataId = buffer.getInt();
                double value1 = buffer.getDouble();
                
                System.out.println("      解析的数据:");
                System.out.println("        时间戳: " + timestamp);
                System.out.println("        数据ID: " + dataId);
                System.out.println("        值1: " + value1);
                
                if (buffer.remaining() >= 8) {
                    double value2 = buffer.getDouble();
                    System.out.println("        值2: " + value2);
                }
            } catch (Exception e) {
                System.out.println("      无法解析为数值数据: " + e.getMessage());
            }
        }
    }
    
    private byte[] createSampleDataBody() {
        ByteBuffer buffer = ByteBuffer.allocate(24);
        buffer.putLong(System.currentTimeMillis());
        buffer.putInt(3001);
        buffer.putDouble(25.6);
        buffer.putDouble(60.2);
        return buffer.array();
    }
}
```


## 6. 配置参数详解

### 6.1 系统级配置参数

```java
public class SecsGemKitConfig {
    // 默认设备ID
    public static final int DEFAULT_DEVICE_ID = 0;
    
    // 默认超时时间（毫秒）
    public static final int DEFAULT_TIMEOUT = 5000;
    
    // 消息头长度（字节）
    public static final int MESSAGE_HEADER_LENGTH = 10;
    
    // 最大消息体长度（字节）
    public static final int MAX_MESSAGE_BODY_LENGTH = 1024 * 1024; // 1MB
    
    // 连接重试次数
    public static final int CONNECTION_RETRY_COUNT = 3;
    
    // 连接重试间隔（毫秒）
    public static final int CONNECTION_RETRY_INTERVAL = 1000;
}
```


### 6.2 消息格式规范

```java
// SECS消息头格式说明
public class SecsMessageHeaderFormat {
    /*
     * SECS消息头结构 (10字节):
     * 
     * 字节 0-1: 设备ID (Device ID) - 16位
     * 字节 2:   Stream号 - 7位 (最高位保留)
     * 字节 3:   Function号 - 7位 (最高位保留)
     * 字节 4:   P-Type和其它标志位
     *           Bit 7: P-Type (0=SECS-I, 1=SECS-II)
     *           Bits 6-0: 保留
     * 字节 5:   保留
     * 字节 6-9: 消息体长度 (Message Length) - 32位
     */
    
    public static void explainHeaderFormat() {
        System.out.println("SECS消息头格式说明:");
        System.out.println("字节 0-1: 设备ID (Device ID) - 16位");
        System.out.println("字节 2:   Stream号 - 7位 (最高位保留)");
        System.out.println("字节 3:   Function号 - 7位 (最高位保留)");
        System.out.println("字节 4:   P-Type和其它标志位");
        System.out.println("          Bit 7: P-Type (0=SECS-I, 1=SECS-II)");
        System.out.println("          Bits 6-0: 保留");
        System.out.println("字节 5:   保留");
        System.out.println("字节 6-9: 消息体长度 (Message Length) - 32位");
    }
}
```


## 7. 错误处理

### 7.1 异常处理示例

```java
public class SecsGemErrorHandler {
    public void handleCommunicationErrors() {
        System.out.println("SECS/GEM通信错误处理示例");
        
        try {
            // 创建模拟连接
            SecsGemKit.SecsConnection connection = new FaultyConnection();
            
            // 构建消息
            SecsGemKit.SecsMessage message = SecsGemKit.buildSecsMessage(
                1, 1, 
                SecsGemKit.DEFAULT_DEVICE_ID, 
                "Test Message".getBytes()
            );
            
            if (message != null) {
                // 发送消息并处理可能的异常
                SecsGemKit.SecsMessage response = SecsGemKit.sendSecsMessage(
                    connection, 
                    message, 
                    SecsGemKit.DEFAULT_TIMEOUT
                );
                
                if (response != null) {
                    System.out.println("消息发送成功");
                } else {
                    System.err.println("消息发送失败或超时");
                }
            }
            
        } catch (Exception e) {
            System.err.println("SECS通信过程中发生异常: " + e.getMessage());
            e.printStackTrace();
            
            // 根据异常类型采取不同处理措施
            handleSpecificException(e);
        }
    }
    
    private void handleSpecificException(Exception e) {
        if (e instanceof java.net.ConnectException) {
            System.err.println("连接异常，检查网络连接和设备状态");
        } else if (e instanceof java.util.concurrent.TimeoutException) {
            System.err.println("通信超时，可能设备无响应");
        } else if (e instanceof java.io.IOException) {
            System.err.println("IO异常，检查通信线路");
        } else {
            System.err.println("未知异常类型: " + e.getClass().getName());
        }
    }
    
    // 模拟故障连接
    private static class FaultyConnection implements SecsGemKit.SecsConnection {
        private int failureCount = 0;
        
        @Override
        public byte[] send(byte[] message, int timeout) throws Exception {
            failureCount++;
            
            // 模拟不同类型的故障
            if (failureCount == 1) {
                throw new java.net.ConnectException("无法连接到设备");
            } else if (failureCount == 2) {
                throw new java.util.concurrent.TimeoutException("通信超时");
            } else if (failureCount == 3) {
                throw new java.io.IOException("IO错误");
            }
            
            // 第四次及以后成功
            return "SUCCESS".getBytes();
        }
        
        @Override
        public void close() {
            System.out.println("关闭连接");
        }
        
        @Override
        public boolean isConnected() {
            return failureCount >= 4;
        }
    }
    
    public boolean safeMessageSend(SecsGemKit.SecsConnection connection, 
                                  SecsGemKit.SecsMessage message) {
        if (connection == null || message == null) {
            System.err.println("连接或消息不能为空");
            return false;
        }
        
        int maxRetries = 3;
        int retryCount = 0;
        
        while (retryCount < maxRetries) {
            try {
                SecsGemKit.SecsMessage response = SecsGemKit.sendSecsMessage(
                    connection, 
                    message, 
                    SecsGemKit.DEFAULT_TIMEOUT
                );
                
                if (response != null) {
                    System.out.println("消息发送成功");
                    return true;
                } else {
                    System.err.println("第" + (retryCount + 1) + "次发送失败");
                }
                
            } catch (Exception e) {
                System.err.println("第" + (retryCount + 1) + "次发送异常: " + e.getMessage());
            }
            
            retryCount++;
            
            // 重试前等待
            if (retryCount < maxRetries) {
                try {
                    Thread.sleep(1000 * retryCount); // 递增延迟
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
        
        System.err.println("消息发送最终失败，已重试 " + maxRetries + " 次");
        return false;
    }
}
```


## 8. 最佳实践

### 8.1 消息处理最佳实践

```java
public class SecsGemBestPractices {
    public void demonstrateBestPractices() {
        System.out.println("SECS/GEM最佳实践演示");
        
        // 1. 消息验证
        System.out.println("1. 消息验证");
        validateMessages();
        
        // 2. 连接管理
        System.out.println("2. 连接管理");
        manageConnections();
        
        // 3. 超时处理
        System.out.println("3. 超时处理");
        handleTimeouts();
        
        // 4. 错误恢复
        System.out.println("4. 错误恢复");
        implementErrorRecovery();
    }
    
    private void validateMessages() {
        System.out.println("消息验证实践:");
        
        // 验证输入参数
        byte[] validData = "Valid Data".getBytes();
        SecsGemKit.SecsMessage message = SecsGemKit.buildSecsMessage(
            1, 1, 
            SecsGemKit.DEFAULT_DEVICE_ID, 
            validData
        );
        
        if (message != null) {
            System.out.println("  消息构建成功");
            
            // 验证消息结构
            if (message.getHeader().length == 10) {
                System.out.println("  消息头长度正确");
            }
            
            if (message.getBody().length <= 1024 * 1024) { // 1MB限制
                System.out.println("  消息体长度在允许范围内");
            }
        }
        
        // 验证无效输入
        SecsGemKit.SecsMessage invalidMessage = SecsGemKit.buildSecsMessage(
            1, 1, 
            SecsGemKit.DEFAULT_DEVICE_ID, 
            null
        );
        
        if (invalidMessage != null) {
            System.out.println("  无效输入处理正确");
        }
    }
    
    private void manageConnections() {
        System.out.println("连接管理实践:");
        
        // 使用连接池或单例模式管理连接
        SecsGemKit.SecsConnection connection = getConnection();
        
        if (connection != null) {
            if (connection.isConnected()) {
                System.out.println("  连接状态正常");
            } else {
                System.out.println("  连接已断开，尝试重新连接");
                // 实际应用中应该尝试重新连接
            }
        }
    }
    
    private void handleTimeouts() {
        System.out.println("超时处理实践:");
        
        // 根据消息类型设置不同的超时时间
        int shortTimeout = 2000;   // 2秒，用于快速响应消息
        int mediumTimeout = 5000;  // 5秒，用于一般消息
        int longTimeout = 30000;   // 30秒，用于大数据传输
        
        System.out.println("  短超时: " + shortTimeout + "ms");
        System.out.println("  中等超时: " + mediumTimeout + "ms");
        System.out.println("  长超时: " + longTimeout + "ms");
    }
    
    private void implementErrorRecovery() {
        System.out.println("错误恢复实践:");
        
        // 实现重试机制
        int maxRetries = 3;
        int retryDelay = 1000; // 1秒
        
        System.out.println("  最大重试次数: " + maxRetries);
        System.out.println("  重试延迟: " + retryDelay + "ms");
        
        // 实现断线重连
        System.out.println("  实现断线自动重连机制");
        
        // 实现消息队列，防止消息丢失
        System.out.println("  使用消息队列保证消息不丢失");
    }
    
    // 获取连接的示例方法
    private SecsGemKit.SecsConnection getConnection() {
        // 在实际应用中，这里应该从连接池获取或创建新连接
        return new MockConnection();
    }
    
    // 模拟连接
    private static class MockConnection implements SecsGemKit.SecsConnection {
        @Override
        public byte[] send(byte[] message, int timeout) throws Exception {
            return "ACK".getBytes();
        }
        
        @Override
        public void close() {
            System.out.println("  关闭连接");
        }
        
        @Override
        public boolean isConnected() {
            return true;
        }
    }
}
```


### 8.2 性能优化实践

```java
public class PerformanceOptimization {
    private final Map<String, SecsGemKit.SecsMessage> messageCache = new ConcurrentHashMap<>();
    private final long cacheTimeout = 5 * 60 * 1000; // 5分钟
    
    public void demonstratePerformanceOptimization() {
        System.out.println("SECS/GEM性能优化实践");
        
        // 1. 消息缓存
        System.out.println("1. 消息缓存优化");
        useMessageCaching();
        
        // 2. 批量处理
        System.out.println("2. 批量处理优化");
        optimizeBatchProcessing();
        
        // 3. 异步处理
        System.out.println("3. 异步处理优化");
        useAsyncProcessing();
        
        // 4. 连接复用
        System.out.println("4. 连接复用优化");
        reuseConnections();
    }
    
    private void useMessageCaching() {
        System.out.println("消息缓存优化:");
        
        // 缓存常用消息
        String cacheKey = "S1F1_ONLINE_QUERY";
        SecsGemKit.SecsMessage cachedMessage = messageCache.get(cacheKey);
        
        if (cachedMessage != null) {
            System.out.println("  从缓存获取消息: " + cacheKey);
        } else {
            // 创建并缓存消息
            SecsGemKit.SecsMessage message = SecsGemKit.buildSecsMessage(
                1, 1, 
                SecsGemKit.DEFAULT_DEVICE_ID, 
                "Are You Online?".getBytes()
            );
            
            if (message != null) {
                messageCache.put(cacheKey, message);
                System.out.println("  创建并缓存消息: " + cacheKey);
            }
        }
        
        System.out.println("  缓存消息数量: " + messageCache.size());
    }
    
    private void optimizeBatchProcessing() {
        System.out.println("批量处理优化:");
        
        // 创建多个消息进行批量处理
        List<SecsGemKit.SecsMessage> messages = new ArrayList<>();
        for (int i = 1; i <= 10; i++) {
            SecsGemKit.SecsMessage message = SecsGemKit.buildSecsMessage(
                6, 11, 
                i, 
                ("Data " + i).getBytes()
            );
            if (message != null) {
                messages.add(message);
            }
        }
        
        System.out.println("  批量处理消息数: " + messages.size());
        System.out.println("  减少连接建立次数，提高处理效率");
    }
    
    private void useAsyncProcessing() {
        System.out.println("异步处理优化:");
        
        // 使用异步方式处理消息发送
        ExecutorService executor = Executors.newFixedThreadPool(5);
        
        List<CompletableFuture<String>> futures = new ArrayList<>();
        
        for (int i = 1; i <= 5; i++) {
            final int taskId = i;
            CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
                try {
                    // 模拟消息发送
                    Thread.sleep(100 + (long) (Math.random() * 200));
                    return "Task " + taskId + " completed";
                } catch (Exception e) {
                    return "Task " + taskId + " failed: " + e.getMessage();
                }
            }, executor);
            
            futures.add(future);
        }
        
        // 等待所有任务完成
        CompletableFuture<Void> allDone = CompletableFuture.allOf(
            futures.toArray(new CompletableFuture[0])
        );
        
        try {
            allDone.get(10, TimeUnit.SECONDS);
            System.out.println("  所有异步任务完成");
        } catch (Exception e) {
            System.err.println("  异步任务执行超时或异常: " + e.getMessage());
        } finally {
            executor.shutdown();
        }
    }
    
    private void reuseConnections() {
        System.out.println("连接复用优化:");
        
        // 使用单例或连接池复用连接
        SecsGemKit.SecsConnection connection = getConnection();
        
        if (connection != null && connection.isConnected()) {
            System.out.println("  复用现有连接");
            System.out.println("  避免频繁建立和关闭连接的开销");
        }
    }
    
    // 获取连接的示例方法
    private SecsGemKit.SecsConnection getConnection() {
        // 在实际应用中，这里应该从连接池获取连接
        return new MockConnection();
    }
    
    // 模拟连接
    private static class MockConnection implements SecsGemKit.SecsConnection {
        @Override
        public byte[] send(byte[] message, int timeout) throws Exception {
            return "ACK".getBytes();
        }
        
        @Override
        public void close() {
            System.out.println("  关闭连接");
        }
        
        @Override
        public boolean isConnected() {
            return true;
        }
    }
}
```


## 9. 系统集成

### 9.1 与Spring框架集成

```java
@Component
public class SpringSecsGemIntegrationService {
    
    @Autowired
    private SecsGemKit secsGemKit; // 假设SecsGemKit被Spring管理
    
    // 设备状态查询服务
    public String queryEquipmentStatus(int deviceId) {
        try {
            // 构建S1F1消息
            SecsGemKit.SecsMessage message = SecsGemKit.buildSecsMessage(
                1, 1, 
                deviceId, 
                "Are You Online?".getBytes()
            );
            
            if (message != null) {
                // 发送消息（需要注入实际的连接对象）
                // SecsGemKit.SecsMessage response = SecsGemKit.sendSecsMessage(connection, message, 5000);
                // if (response != null) {
                //     return new String(response.getBody());
                // }
                return "ONLINE"; // 模拟响应
            }
        } catch (Exception e) {
            System.err.println("查询设备状态时发生错误: " + e.getMessage());
        }
        
        return "UNKNOWN";
    }
    
    // 数据收集服务
    @Async
    public CompletableFuture<Boolean> collectEquipmentDataAsync(int deviceId, byte[] data) {
        try {
            // 构建S6F11消息
            SecsGemKit.SecsMessage message = SecsGemKit.buildSecsMessage(
                6, 11, 
                deviceId, 
                data
            );
            
            if (message != null) {
                // 发送消息（需要注入实际的连接对象）
                // SecsGemKit.SecsMessage response = SecsGemKit.sendSecsMessage(connection, message, 5000);
                // return CompletableFuture.completedFuture(response != null);
                return CompletableFuture.completedFuture(true); // 模拟成功
            }
        } catch (Exception e) {
            System.err.println("收集设备数据时发生错误: " + e.getMessage());
        }
        
        return CompletableFuture.completedFuture(false);
    }
    
    // 定时数据收集服务
    @Scheduled(fixedRate = 30000) // 每30秒收集一次
    public void collectPeriodicData() {
        // 收集周期性数据
        System.out.println("定时收集设备数据");
        // 实现具体的数据收集逻辑
    }
    
    // 设备事件监听服务
    @EventListener
    public void handleEquipmentEvent(EquipmentEvent event) {
        // 处理设备事件
        System.out.println("处理设备事件: " + event.getEventType());
        // 实现具体的事件处理逻辑
    }
}

// 设备事件类
class EquipmentEvent extends ApplicationEvent {
    private final String eventType;
    private final int deviceId;
    private final Object eventData;
    
    public EquipmentEvent(Object source, String eventType, int deviceId, Object eventData) {
        super(source);
        this.eventType = eventType;
        this.deviceId = deviceId;
        this.eventData = eventData;
    }
    
    // Getters
    public String getEventType() { return eventType; }
    public int getDeviceId() { return deviceId; }
    public Object getEventData() { return eventData; }
}
```


### 9.2 与消息队列集成

```java
@Component
public class MessageQueueIntegration {
    
    // Kafka集成示例
    @KafkaListener(topics = "secs-messages", groupId = "secs-gem-processor")
    public void handleSecsMessage(String messageJson) {
        try {
            // 解析JSON到SECS消息对象
            SecsMessageWrapper messageWrapper = parseMessageFromJson(messageJson);
            
            // 处理SECS消息
            processSecsMessage(messageWrapper);
            
        } catch (Exception e) {
            System.err.println("处理SECS消息时发生错误: " + e.getMessage());
        }
    }
    
    @KafkaListener(topics = "equipment-events", groupId = "secs-gem-processor")
    public void handleEquipmentEvent(String eventJson) {
        try {
            // 解析JSON到设备事件对象
            EquipmentEvent event = parseEventFromJson(eventJson);
            
            // 处理设备事件
            handleEquipmentEvent(event);
            
        } catch (Exception e) {
            System.err.println("处理设备事件时发生错误: " + e.getMessage());
        }
    }
    
    // RabbitMQ集成示例
    @RabbitListener(queues = "secs-entity-queue")
    public void handleSecsCommand(SecsCommandMessage commandMessage) {
        try {
            // 执行SECS命令
            executeSecsCommand(commandMessage);
            
        } catch (Exception e) {
            System.err.println("执行SECS命令时发生错误: " + e.getMessage());
        }
    }
    
    // 私有辅助方法
    private SecsMessageWrapper parseMessageFromJson(String json) {
        // 实现JSON到SECS消息对象的解析
        return new SecsMessageWrapper(1, 1, "Test Data".getBytes());
    }
    
    private EquipmentEvent parseEventFromJson(String json) {
        // 实现JSON到设备事件对象的解析
        return new EquipmentEvent("SOURCE", "ALARM", 123, "HIGH_TEMPERATURE");
    }
    
    private void processSecsMessage(SecsMessageWrapper messageWrapper) {
        System.out.println("处理SECS消息: Stream=" + messageWrapper.getStream() + 
                          ", Function=" + messageWrapper.getFunction());
        // 实现具体的SECS消息处理逻辑
    }
    
    private void handleEquipmentEvent(EquipmentEvent event) {
        System.out.println("处理设备事件: Type=" + event.getEventType() + 
                          ", Device=" + event.getDeviceId());
        // 实现具体的设备事件处理逻辑
    }
    
    private void executeSecsCommand(SecsCommandMessage commandMessage) {
        System.out.println("执行SECS命令: " + commandMessage.getCommand());
        // 实现具体的SECS命令执行逻辑
    }
}

// SECS消息包装类
class SecsMessageWrapper {
    private int stream;
    private int function;
    private byte[] data;
    
    public SecsMessageWrapper(int stream, int function, byte[] data) {
        this.stream = stream;
        this.function = function;
        this.data = data;
    }
    
    // Getters and Setters
    public int getStream() { return stream; }
    public void setStream(int stream) { this.stream = stream; }
    
    public int getFunction() { return function; }
    public void setFunction(int function) { this.function = function; }
    
    public byte[] getData() { return data; }
    public void setData(byte[] data) { this.data = data; }
}

// SECS命令消息类
class SecsCommandMessage {
    private String command;
    private int deviceId;
    private Map<String, Object> parameters;
    private long timestamp;
    
    // Getters and Setters
    public String getCommand() { return command; }
    public void setCommand(String command) { this.command = command; }
    
    public int getDeviceId() { return deviceId; }
    public void setDeviceId(int deviceId) { this.deviceId = deviceId; }
    
    public Map<String, Object> getParameters() { return parameters; }
    public void setParameters(Map<String, Object> parameters) { this.parameters = parameters; }
    
    public long getTimestamp() { return timestamp; }
    public void setTimestamp(long timestamp) { this.timestamp = timestamp; }
}
```


这个使用说明文档涵盖了 [SecsGemKit](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\semiconductor\equipment\protocol\SecsGemKit.java#L26-L136) 的主要功能和使用方法，可以帮助开发者快速上手并正确使用该SECS/GEM协议工具类。