# EquipmentMonitor 使用说明文档

## 1. 概述

[EquipmentMonitor](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\semiconductor\equipment\monitor\EquipmentMonitor.java#L29-L548) 是一个专业的设备状态监控工具类，专门为半导体封测设备的状态监控和分析设计。该工具解决了设备状态监控复杂、监控策略不统一、故障预测不准确、利用率分析不完善等问题。

## 2. 核心功能

### 2.1 设备状态监控
- 实时监控设备运行状态
- 支持多种设备类型监控
- 可配置的监控间隔和策略

### 2.2 健康度评分
- 计算设备健康度评分
- 基于历史数据分析设备健康状况
- 提供健康度评分说明

### 2.3 故障预测
- 预测设备潜在故障
- 支持自定义预测窗口
- 提供故障概率和原因分析

### 2.4 利用率分析
- 生成设备利用率报告
- 分析设备各状态持续时间
- 提供时间范围内的利用率统计

## 3. 支持的设备状态类型

### 3.1 设备状态枚举
```java
public enum EquipmentState {
    UNKNOWN,    // 未知状态
    RUNNING,    // 运行中
    IDLE,       // 空闲
    SETUP,      // 设置中
    MAINTENANCE,// 维护中
    ERROR,      // 错误
    OFFLINE     // 离线
}
```


## 4. 基本使用方法

### 4.1 设备状态监控

```java
// 设备状态监控示例
public class EquipmentMonitoringExample {
    public void startEquipmentMonitoring() {
        System.out.println("开始设备状态监控示例...");
        
        // 1. 创建监控配置
        EquipmentMonitor.MonitorConfig config = new EquipmentMonitor.MonitorConfig()
                .setInterval(3000)  // 3秒监控间隔
                .setEnablePrediction(true)
                .setPredictionWindow(300000)  // 5分钟预测窗口
                .setMaxRetries(3)
                .setRetryDelay(1000);
        
        // 2. 创建状态监听器
        EquipmentMonitor.StatusListener listener = new EquipmentMonitor.StatusListener() {
            @Override
            public void onStatusUpdate(EquipmentMonitor.EquipmentStatus status) {
                System.out.println("设备状态更新: " + status.getEquipmentId() + 
                                 " - " + status.getState() + 
                                 " (" + new Date(status.getTimestamp()) + ")");
                
                // 输出设备属性
                if (!status.getAttributes().isEmpty()) {
                    System.out.println("  属性: " + status.getAttributes());
                }
            }
            
            @Override
            public void onError(EquipmentMonitor.EquipmentMonitoringException exception) {
                System.err.println("设备监控错误: " + exception.getMessage());
            }
        };
        
        // 3. 开始监控设备
        String equipmentId1 = "EQ-20250820-001";
        boolean started1 = EquipmentMonitor.startMonitoring(equipmentId1, listener, config);
        System.out.println("设备 " + equipmentId1 + " 监控启动: " + (started1 ? "成功" : "失败"));
        
        String equipmentId2 = "EQ-20250820-002";
        boolean started2 = EquipmentMonitor.startMonitoring(equipmentId2, listener, config);
        System.out.println("设备 " + equipmentId2 + " 监控启动: " + (started2 ? "成功" : "失败"));
        
        // 4. 模拟设备状态变化
        simulateEquipmentStatusChanges();
        
        // 5. 等待一段时间查看监控效果
        try {
            Thread.sleep(10000);  // 等待10秒
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // 6. 停止监控
        boolean stopped1 = EquipmentMonitor.stopMonitoring(equipmentId1);
        System.out.println("设备 " + equipmentId1 + " 监控停止: " + (stopped1 ? "成功" : "失败"));
        
        boolean stopped2 = EquipmentMonitor.stopMonitoring(equipmentId2);
        System.out.println("设备 " + equipmentId2 + " 监控停止: " + (stopped2 ? "成功" : "失败"));
    }
    
    private void simulateEquipmentStatusChanges() {
        // 模拟设备状态变化（实际应用中这些状态会由设备通信获取）
        System.out.println("模拟设备状态变化...");
        
        // 在实际应用中，这些状态会通过设备通信实时获取
        // 这里仅用于演示目的
    }
}
```


### 4.2 设备状态查询

```java
// 设备状态查询示例
public class EquipmentStatusQueryExample {
    public void queryEquipmentStatus() {
        System.out.println("开始设备状态查询示例...");
        
        // 1. 查询单个设备状态
        String equipmentId = "EQ-20250820-001";
        EquipmentMonitor.EquipmentStatus status = EquipmentMonitor.getCurrentStatus(equipmentId);
        
        if (status != null) {
            System.out.println("设备状态查询结果:");
            System.out.println("  设备ID: " + status.getEquipmentId());
            System.out.println("  状态: " + status.getState());
            System.out.println("  时间戳: " + new Date(status.getTimestamp()));
            System.out.println("  属性数量: " + status.getAttributes().size());
            
            // 添加一些属性用于演示
            EquipmentMonitor.EquipmentStatus statusWithAttributes = new EquipmentMonitor.EquipmentStatus(
                equipmentId, EquipmentMonitor.EquipmentState.RUNNING, System.currentTimeMillis()
            );
            statusWithAttributes.setAttribute("temperature", 25.6);
            statusWithAttributes.setAttribute("pressure", 1.2);
            statusWithAttributes.setAttribute("speed", 1200);
            
            System.out.println("  温度: " + statusWithAttributes.getAttribute("temperature"));
            System.out.println("  压力: " + statusWithAttributes.getAttribute("pressure"));
            System.out.println("  速度: " + statusWithAttributes.getAttribute("speed"));
        } else {
            System.err.println("设备状态查询失败: " + equipmentId);
        }
        
        // 2. 查询多个设备状态
        String[] equipmentIds = {"EQ-20250820-001", "EQ-20250820-002", "EQ-20250820-003"};
        
        System.out.println("\n批量设备状态查询:");
        for (String eqId : equipmentIds) {
            EquipmentMonitor.EquipmentStatus eqStatus = EquipmentMonitor.getCurrentStatus(eqId);
            if (eqStatus != null) {
                System.out.println("  " + eqId + ": " + eqStatus.getState());
            } else {
                System.out.println("  " + eqId + ": 查询失败");
            }
        }
    }
}
```


### 4.3 健康度评分

```java
// 设备健康度评分示例
public class EquipmentHealthScoreExample {
    public void calculateHealthScores() {
        System.out.println("开始设备健康度评分示例...");
        
        // 1. 计算单个设备健康度评分
        String equipmentId = "EQ-20250820-001";
        EquipmentMonitor.HealthScore healthScore = EquipmentMonitor.calculateHealthScore(equipmentId);
        
        if (healthScore != null) {
            System.out.println("设备健康度评分结果:");
            System.out.println("  设备ID: " + healthScore.getEquipmentId());
            System.out.println("  健康度: " + String.format("%.2f", healthScore.getScore() * 100) + "%");
            System.out.println("  描述: " + healthScore.getDescription());
        } else {
            System.err.println("设备健康度评分失败: " + equipmentId);
        }
        
        // 2. 批量计算设备健康度评分
        String[] equipmentIds = {"EQ-20250820-001", "EQ-20250820-002", "EQ-20250820-003"};
        
        System.out.println("\n批量设备健康度评分:");
        for (String eqId : equipmentIds) {
            EquipmentMonitor.HealthScore score = EquipmentMonitor.calculateHealthScore(eqId);
            if (score != null) {
                String healthLevel = getHealthLevel(score.getScore());
                System.out.println("  " + eqId + ": " + 
                                 String.format("%.1f", score.getScore() * 100) + "% " + 
                                 "(" + healthLevel + ") - " + score.getDescription());
            } else {
                System.out.println("  " + eqId + ": 评分失败");
            }
        }
        
        // 3. 健康度分级显示
        System.out.println("\n健康度分级标准:");
        System.out.println("  优秀 (90-100%): 设备运行状态良好");
        System.out.println("  良好 (70-89%):  设备运行基本正常");
        System.out.println("  一般 (50-69%):  设备存在轻微问题");
        System.out.println("  较差 (30-49%):  设备存在较多问题");
        System.out.println("  很差 (0-29%):   设备存在严重问题");
    }
    
    private String getHealthLevel(double score) {
        if (score >= 0.9) return "优秀";
        if (score >= 0.7) return "良好";
        if (score >= 0.5) return "一般";
        if (score >= 0.3) return "较差";
        return "很差";
    }
}
```


### 4.4 故障预测

```java
// 设备故障预测示例
public class EquipmentFaultPredictionExample {
    public void predictEquipmentFaults() {
        System.out.println("开始设备故障预测示例...");
        
        // 1. 创建预测配置
        EquipmentMonitor.MonitorConfig config = new EquipmentMonitor.MonitorConfig()
                .setEnablePrediction(true)
                .setPredictionWindow(600000);  // 10分钟预测窗口
        
        // 2. 对单个设备进行故障预测
        String equipmentId = "EQ-20250820-001";
        List<EquipmentMonitor.FaultPrediction> predictions = 
            EquipmentMonitor.predictFaults(equipmentId, config);
        
        System.out.println("设备故障预测结果:");
        System.out.println("  设备ID: " + equipmentId);
        System.out.println("  预测数量: " + predictions.size());
        
        if (!predictions.isEmpty()) {
            for (int i = 0; i < predictions.size(); i++) {
                EquipmentMonitor.FaultPrediction prediction = predictions.get(i);
                String riskLevel = getRiskLevel(prediction.getProbability());
                
                System.out.println("  预测 " + (i + 1) + ":");
                System.out.println("    故障类型: " + prediction.getFaultType());
                System.out.println("    发生概率: " + String.format("%.1f", prediction.getProbability() * 100) + "% (" + riskLevel + ")");
                System.out.println("    原因: " + prediction.getReason());
                System.out.println("    预计时间: " + new Date(prediction.getPredictedTime()));
            }
        } else {
            System.out.println("  暂无故障预测");
        }
        
        // 3. 批量设备故障预测
        String[] equipmentIds = {"EQ-20250820-001", "EQ-20250820-002", "EQ-20250820-003"};
        
        System.out.println("\n批量设备故障预测:");
        for (String eqId : equipmentIds) {
            List<EquipmentMonitor.FaultPrediction> eqPredictions = 
                EquipmentMonitor.predictFaults(eqId, config);
            
            System.out.println("  " + eqId + ": " + eqPredictions.size() + " 个预测");
            for (EquipmentMonitor.FaultPrediction prediction : eqPredictions) {
                String riskLevel = getRiskLevel(prediction.getProbability());
                System.out.println("    - " + prediction.getFaultType() + 
                                 " (" + String.format("%.0f", prediction.getProbability() * 100) + "% " + riskLevel + ")");
            }
        }
        
        // 4. 风险等级说明
        System.out.println("\n风险等级说明:");
        System.out.println("  高风险 (80-100%): 需要立即处理");
        System.out.println("  中风险 (50-79%):  需要关注并制定处理计划");
        System.out.println("  低风险 (20-49%):  可以继续观察");
        System.out.println("  极低风险 (0-19%): 暂时无需处理");
    }
    
    private String getRiskLevel(double probability) {
        if (probability >= 0.8) return "高风险";
        if (probability >= 0.5) return "中风险";
        if (probability >= 0.2) return "低风险";
        return "极低风险";
    }
}
```


### 4.5 利用率分析

```java
// 设备利用率分析示例
public class EquipmentUtilizationAnalysisExample {
    public void analyzeEquipmentUtilization() {
        System.out.println("开始设备利用率分析示例...");
        
        // 1. 创建时间范围（过去24小时）
        long now = System.currentTimeMillis();
        EquipmentMonitor.TimeRange timeRange = new EquipmentMonitor.TimeRange(
            now - 24 * 60 * 60 * 1000,  // 24小时前
            now
        );
        
        // 2. 生成单个设备利用率报告
        String equipmentId = "EQ-20250820-001";
        EquipmentMonitor.UtilizationReport report = 
            EquipmentMonitor.generateUtilizationReport(equipmentId, timeRange);
        
        if (report != null) {
            System.out.println("设备利用率报告:");
            System.out.println("  设备ID: " + report.getEquipmentId());
            System.out.println("  时间范围: " + report.getTimeRange());
            System.out.println("  总体利用率: " + String.format("%.2f", report.getOverallUtilization() * 100) + "%");
            
            // 显示各状态持续时间
            System.out.println("  各状态持续时间:");
            Map<EquipmentMonitor.EquipmentState, Long> stateDurations = report.getStateDurations();
            for (Map.Entry<EquipmentMonitor.EquipmentState, Long> entry : stateDurations.entrySet()) {
                double hours = entry.getValue() / (1000.0 * 60 * 60);
                System.out.println("    " + entry.getKey() + ": " + String.format("%.2f", hours) + " 小时");
            }
        } else {
            System.err.println("设备利用率报告生成失败: " + equipmentId);
        }
        
        // 3. 批量设备利用率分析
        String[] equipmentIds = {"EQ-20250820-001", "EQ-20250820-002", "EQ-20250820-003"};
        
        System.out.println("\n批量设备利用率分析 (过去24小时):");
        for (String eqId : equipmentIds) {
            EquipmentMonitor.UtilizationReport eqReport = 
                EquipmentMonitor.generateUtilizationReport(eqId, timeRange);
            
            if (eqReport != null) {
                System.out.println("  " + eqId + ": " + 
                                 String.format("%.1f", eqReport.getOverallUtilization() * 100) + "% 利用率");
                
                // 显示主要运行时间
                Long runningTime = eqReport.getStateDurations().get(EquipmentMonitor.EquipmentState.RUNNING);
                if (runningTime != null) {
                    double runningHours = runningTime / (1000.0 * 60 * 60);
                    System.out.println("    运行时间: " + String.format("%.1f", runningHours) + " 小时");
                }
            } else {
                System.out.println("  " + eqId + ": 报告生成失败");
            }
        }
        
        // 4. 不同时间范围的利用率分析
        System.out.println("\n不同时间范围的利用率分析 (" + equipmentId + "):");
        
        // 过去1小时
        EquipmentMonitor.TimeRange lastHour = new EquipmentMonitor.TimeRange(
            now - 60 * 60 * 1000, now
        );
        EquipmentMonitor.UtilizationReport hourReport = 
            EquipmentMonitor.generateUtilizationReport(equipmentId, lastHour);
        if (hourReport != null) {
            System.out.println("  过去1小时: " + String.format("%.1f", hourReport.getOverallUtilization() * 100) + "%");
        }
        
        // 过去7天
        EquipmentMonitor.TimeRange lastWeek = new EquipmentMonitor.TimeRange(
            now - 7 * 24 * 60 * 60 * 1000, now
        );
        EquipmentMonitor.UtilizationReport weekReport = 
            EquipmentMonitor.generateUtilizationReport(equipmentId, lastWeek);
        if (weekReport != null) {
            System.out.println("  过去7天: " + String.format("%.1f", weekReport.getOverallUtilization() * 100) + "%");
        }
        
        // 过去30天
        EquipmentMonitor.TimeRange lastMonth = new EquipmentMonitor.TimeRange(
            now - 30 * 24 * 60 * 60 * 1000, now
        );
        EquipmentMonitor.UtilizationReport monthReport = 
            EquipmentMonitor.generateUtilizationReport(equipmentId, lastMonth);
        if (monthReport != null) {
            System.out.println("  过去30天: " + String.format("%.1f", monthReport.getOverallUtilization() * 100) + "%");
        }
    }
}
```


## 5. 高级使用示例

### 5.1 完整的设备监控流程

```java
public class CompleteEquipmentMonitoringProcess {
    public void executeCompleteMonitoringProcess() {
        try {
            System.out.println("=== 开始完整的设备监控流程 ===");
            
            // 步骤1: 初始化监控配置
            System.out.println("\n步骤1: 初始化监控配置");
            initializeMonitoringConfiguration();
            
            // 步骤2: 启动设备监控
            System.out.println("\n步骤2: 启动设备监控");
            startEquipmentMonitoring();
            
            // 步骤3: 实时状态查询
            System.out.println("\n步骤3: 实时状态查询");
            queryRealTimeStatus();
            
            // 步骤4: 健康度评分
            System.out.println("\n步骤4: 设备健康度评分");
            calculateHealthScores();
            
            // 步骤5: 故障预测
            System.out.println("\n步骤5: 设备故障预测");
            predictEquipmentFaults();
            
            // 步骤6: 利用率分析
            System.out.println("\n步骤6: 设备利用率分析");
            analyzeUtilization();
            
            // 步骤7: 停止监控
            System.out.println("\n步骤7: 停止设备监控");
            stopEquipmentMonitoring();
            
            System.out.println("\n=== 设备监控流程完成 ===");
            
        } catch (Exception e) {
            System.err.println("设备监控流程执行过程中发生错误: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    private void initializeMonitoringConfiguration() {
        System.out.println("初始化监控配置...");
        
        // 创建默认监控配置
        EquipmentMonitor.MonitorConfig defaultConfig = new EquipmentMonitor.MonitorConfig();
        System.out.println("  默认监控间隔: " + defaultConfig.getInterval() + "ms");
        System.out.println("  默认预测窗口: " + defaultConfig.getPredictionWindow() + "ms");
        System.out.println("  预测功能启用: " + defaultConfig.isEnablePrediction());
        System.out.println("  最大重试次数: " + defaultConfig.getMaxRetries());
        System.out.println("  重试延迟: " + defaultConfig.getRetryDelay() + "ms");
        
        // 创建自定义监控配置
        EquipmentMonitor.MonitorConfig customConfig = new EquipmentMonitor.MonitorConfig()
                .setInterval(2000)           // 2秒
                .setPredictionWindow(600000) // 10分钟
                .setEnablePrediction(true)
                .setMaxRetries(5)
                .setRetryDelay(2000);
        
        System.out.println("  自定义监控配置:");
        System.out.println("    监控间隔: " + customConfig.getInterval() + "ms");
        System.out.println("    预测窗口: " + customConfig.getPredictionWindow() + "ms");
        System.out.println("    预测启用: " + customConfig.isEnablePrediction());
    }
    
    private void startEquipmentMonitoring() {
        System.out.println("启动设备监控...");
        
        // 创建状态监听器
        EquipmentMonitor.StatusListener listener = new EquipmentMonitor.StatusListener() {
            @Override
            public void onStatusUpdate(EquipmentMonitor.EquipmentStatus status) {
                System.out.println("  [" + new Date(status.getTimestamp()) + "] " + 
                                 status.getEquipmentId() + " 状态更新为: " + status.getState());
            }
            
            @Override
            public void onError(EquipmentMonitor.EquipmentMonitoringException exception) {
                System.err.println("  监控错误: " + exception.getMessage());
            }
        };
        
        // 启动多个设备的监控
        String[] equipmentIds = {"EQ-001", "EQ-002", "EQ-003"};
        EquipmentMonitor.MonitorConfig config = new EquipmentMonitor.MonitorConfig()
                .setInterval(3000);
        
        for (String equipmentId : equipmentIds) {
            boolean started = EquipmentMonitor.startMonitoring(equipmentId, listener, config);
            System.out.println("  设备 " + equipmentId + " 监控启动: " + (started ? "成功" : "失败"));
        }
        
        // 等待一段时间让监控运行
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    private void queryRealTimeStatus() {
        System.out.println("查询实时设备状态...");
        
        String[] equipmentIds = {"EQ-001", "EQ-002", "EQ-003"};
        
        for (String equipmentId : equipmentIds) {
            EquipmentMonitor.EquipmentStatus status = EquipmentMonitor.getCurrentStatus(equipmentId);
            if (status != null) {
                System.out.println("  " + equipmentId + ": " + status.getState() + 
                                 " (" + new Date(status.getTimestamp()) + ")");
                
                // 添加一些模拟属性
                status.setAttribute("temperature", 25.0 + Math.random() * 10);
                status.setAttribute("pressure", 1.0 + Math.random() * 0.5);
                System.out.println("    温度: " + status.getAttribute("temperature"));
                System.out.println("    压力: " + status.getAttribute("pressure"));
            } else {
                System.out.println("  " + equipmentId + ": 状态查询失败");
            }
        }
    }
    
    private void calculateHealthScores() {
        System.out.println("计算设备健康度评分...");
        
        String[] equipmentIds = {"EQ-001", "EQ-002", "EQ-003"};
        
        for (String equipmentId : equipmentIds) {
            EquipmentMonitor.HealthScore score = EquipmentMonitor.calculateHealthScore(equipmentId);
            if (score != null) {
                String healthLevel = getHealthLevel(score.getScore());
                System.out.println("  " + equipmentId + ": " + 
                                 String.format("%.1f", score.getScore() * 100) + "% " + 
                                 "(" + healthLevel + ") - " + score.getDescription());
            } else {
                System.out.println("  " + equipmentId + ": 健康度评分失败");
            }
        }
    }
    
    private void predictEquipmentFaults() {
        System.out.println("进行设备故障预测...");
        
        EquipmentMonitor.MonitorConfig config = new EquipmentMonitor.MonitorConfig()
                .setEnablePrediction(true);
        
        String[] equipmentIds = {"EQ-001", "EQ-002", "EQ-003"};
        
        for (String equipmentId : equipmentIds) {
            List<EquipmentMonitor.FaultPrediction> predictions = 
                EquipmentMonitor.predictFaults(equipmentId, config);
            
            System.out.println("  " + equipmentId + ": " + predictions.size() + " 个预测");
            for (EquipmentMonitor.FaultPrediction prediction : predictions) {
                String riskLevel = getRiskLevel(prediction.getProbability());
                System.out.println("    - " + prediction.getFaultType() + 
                                 " (" + String.format("%.0f", prediction.getProbability() * 100) + "% " + riskLevel + ")" +
                                 " 预计时间: " + new Date(prediction.getPredictedTime()));
            }
        }
    }
    
    private void analyzeUtilization() {
        System.out.println("分析设备利用率...");
        
        long now = System.currentTimeMillis();
        EquipmentMonitor.TimeRange timeRange = new EquipmentMonitor.TimeRange(
            now - 24 * 60 * 60 * 1000,  // 过去24小时
            now
        );
        
        String[] equipmentIds = {"EQ-001", "EQ-002", "EQ-003"};
        
        for (String equipmentId : equipmentIds) {
            EquipmentMonitor.UtilizationReport report = 
                EquipmentMonitor.generateUtilizationReport(equipmentId, timeRange);
            
            if (report != null) {
                System.out.println("  " + equipmentId + ": " + 
                                 String.format("%.1f", report.getOverallUtilization() * 100) + "% 利用率");
                
                Long runningTime = report.getStateDurations().get(EquipmentMonitor.EquipmentState.RUNNING);
                if (runningTime != null) {
                    double runningHours = runningTime / (1000.0 * 60 * 60);
                    System.out.println("    运行时间: " + String.format("%.1f", runningHours) + " 小时");
                }
            } else {
                System.out.println("  " + equipmentId + ": 利用率报告生成失败");
            }
        }
    }
    
    private void stopEquipmentMonitoring() {
        System.out.println("停止设备监控...");
        
        String[] equipmentIds = {"EQ-001", "EQ-002", "EQ-003"};
        
        for (String equipmentId : equipmentIds) {
            boolean stopped = EquipmentMonitor.stopMonitoring(equipmentId);
            System.out.println("  设备 " + equipmentId + " 监控停止: " + (stopped ? "成功" : "失败"));
        }
    }
    
    private String getHealthLevel(double score) {
        if (score >= 0.9) return "优秀";
        if (score >= 0.7) return "良好";
        if (score >= 0.5) return "一般";
        if (score >= 0.3) return "较差";
        return "很差";
    }
    
    private String getRiskLevel(double probability) {
        if (probability >= 0.8) return "高风险";
        if (probability >= 0.5) return "中风险";
        if (probability >= 0.2) return "低风险";
        return "极低风险";
    }
}
```


### 5.2 设备监控数据分析

```java
public class EquipmentMonitoringDataAnalysis {
    public void analyzeMonitoringData() {
        System.out.println("=== 设备监控数据分析 ===");
        
        // 分析不同设备状态
        analyzeEquipmentStates();
        
        // 分析健康度趋势
        analyzeHealthTrends();
        
        // 分析故障模式
        analyzeFaultPatterns();
        
        // 分析利用率分布
        analyzeUtilizationDistribution();
        
        System.out.println("=== 数据分析完成 ===");
    }
    
    private void analyzeEquipmentStates() {
        System.out.println("\n分析设备状态分布:");
        
        // 模拟获取多个设备的状态
        Map<EquipmentMonitor.EquipmentState, Integer> stateCount = new EnumMap<>(EquipmentMonitor.EquipmentState.class);
        
        // 初始化计数器
        for (EquipmentMonitor.EquipmentState state : EquipmentMonitor.EquipmentState.values()) {
            stateCount.put(state, 0);
        }
        
        // 模拟设备状态数据
        EquipmentMonitor.EquipmentState[] states = {
            EquipmentMonitor.EquipmentState.RUNNING,
            EquipmentMonitor.EquipmentState.RUNNING,
            EquipmentMonitor.EquipmentState.RUNNING,
            EquipmentMonitor.EquipmentState.IDLE,
            EquipmentMonitor.EquipmentState.IDLE,
            EquipmentMonitor.EquipmentState.SETUP,
            EquipmentMonitor.EquipmentState.MAINTENANCE,
            EquipmentMonitor.EquipmentState.ERROR,
            EquipmentMonitor.EquipmentState.OFFLINE,
            EquipmentMonitor.EquipmentState.UNKNOWN
        };
        
        // 统计状态分布
        for (EquipmentMonitor.EquipmentState state : states) {
            stateCount.merge(state, 1, Integer::sum);
        }
        
        int total = states.length;
        System.out.println("  总设备数: " + total);
        System.out.println("  状态分布:");
        for (Map.Entry<EquipmentMonitor.EquipmentState, Integer> entry : stateCount.entrySet()) {
            double percentage = (double) entry.getValue() / total * 100;
            System.out.println("    " + entry.getKey() + ": " + entry.getValue() + 
                             " (" + String.format("%.1f", percentage) + "%)");
        }
    }
    
    private void analyzeHealthTrends() {
        System.out.println("\n分析设备健康度趋势:");
        
        // 模拟设备健康度数据
        String[] equipmentIds = {"EQ-001", "EQ-002", "EQ-003", "EQ-004", "EQ-005"};
        double[] healthScores = {0.95, 0.87, 0.76, 0.65, 0.45};
        
        double avgHealth = Arrays.stream(healthScores).average().orElse(0.0);
        double maxHealth = Arrays.stream(healthScores).max().orElse(0.0);
        double minHealth = Arrays.stream(healthScores).min().orElse(0.0);
        
        System.out.println("  设备健康度统计:");
        System.out.println("    平均健康度: " + String.format("%.1f", avgHealth * 100) + "%");
        System.out.println("    最高健康度: " + String.format("%.1f", maxHealth * 100) + "%");
        System.out.println("    最低健康度: " + String.format("%.1f", minHealth * 100) + "%");
        
        System.out.println("  健康度分级:");
        long excellent = Arrays.stream(healthScores).filter(score -> score >= 0.9).count();
        long good = Arrays.stream(healthScores).filter(score -> score >= 0.7 && score < 0.9).count();
        long fair = Arrays.stream(healthScores).filter(score -> score >= 0.5 && score < 0.7).count();
        long poor = Arrays.stream(healthScores).filter(score -> score < 0.5).count();
        
        System.out.println("    优秀 (90-100%): " + excellent + " 台");
        System.out.println("    良好 (70-89%):  " + good + " 台");
        System.out.println("    一般 (50-69%):  " + fair + " 台");
        System.out.println("    较差 (0-49%):   " + poor + " 台");
    }
    
    private void analyzeFaultPatterns() {
        System.out.println("\n分析故障模式:");
        
        // 模拟故障预测数据
        String[] faultTypes = {"机械故障", "电气故障", "软件故障", "传感器故障", "机械故障", "电气故障"};
        double[] probabilities = {0.85, 0.72, 0.65, 0.58, 0.92, 0.78};
        
        Map<String, Long> faultTypeCount = Arrays.stream(faultTypes)
                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
        
        System.out.println("  故障类型分布:");
        faultTypeCount.forEach((type, count) -> 
            System.out.println("    " + type + ": " + count + " 次"));
        
        DoubleSummaryStatistics probabilityStats = Arrays.stream(probabilities)
                .summaryStatistics();
        
        System.out.println("  故障概率统计:");
        System.out.println("    平均概率: " + String.format("%.1f", probabilityStats.getAverage() * 100) + "%");
        System.out.println("    最高概率: " + String.format("%.1f", probabilityStats.getMax() * 100) + "%");
        System.out.println("    最低概率: " + String.format("%.1f", probabilityStats.getMin() * 100) + "%");
    }
    
    private void analyzeUtilizationDistribution() {
        System.out.println("\n分析设备利用率分布:");
        
        // 模拟利用率数据
        double[] utilizations = {0.85, 0.92, 0.78, 0.65, 0.95, 0.72, 0.88, 0.81, 0.76, 0.89};
        
        DoubleSummaryStatistics utilizationStats = Arrays.stream(utilizations)
                .summaryStatistics();
        
        System.out.println("  利用率统计:");
        System.out.println("    平均利用率: " + String.format("%.1f", utilizationStats.getAverage() * 100) + "%");
        System.out.println("    最高利用率: " + String.format("%.1f", utilizationStats.getMax() * 100) + "%");
        System.out.println("    最低利用率: " + String.format("%.1f", utilizationStats.getMin() * 100) + "%");
        
        System.out.println("  利用率分级:");
        long high = Arrays.stream(utilizations).filter(u -> u >= 0.9).count();
        long medium = Arrays.stream(utilizations).filter(u -> u >= 0.7 && u < 0.9).count();
        long low = Arrays.stream(utilizations).filter(u -> u < 0.7).count();
        
        System.out.println("    高利用率 (90-100%): " + high + " 台");
        System.out.println("    中利用率 (70-89%):  " + medium + " 台");
        System.out.println("    低利用率 (0-69%):   " + low + " 台");
    }
}
```


## 6. 配置参数详解

### 6.1 系统级配置参数

```java
public class EquipmentMonitorConfig {
    // 默认监控间隔（毫秒）
    public static final long DEFAULT_MONITOR_INTERVAL = 5000;
    
    // 默认预测窗口（毫秒）
    public static final long DEFAULT_PREDICTION_WINDOW = 300000; // 5分钟
    
    // 最大重试次数
    public static final int MAX_RETRIES = 3;
    
    // 重试延迟（毫秒）
    public static final long RETRY_DELAY = 1000;
    
    // 健康度评分时间窗口（毫秒）
    public static final long HEALTH_SCORE_WINDOW = 3600000; // 1小时
    
    // 缓存超时时间（毫秒）
    public static final long CACHE_TIMEOUT = 30 * 60 * 1000; // 30分钟
}
```


### 6.2 监控配置类详解

```java
public class MonitorConfigDetails {
    /*
     * MonitorConfig 配置参数详解:
     * 
     * interval: 监控间隔（毫秒）
     *   - 默认值: 5000 (5秒)
     *   - 建议范围: 1000-60000 (1秒-1分钟)
     *   - 过小的值会增加系统负载
     *   - 过大的值会降低监控实时性
     * 
     * predictionWindow: 预测窗口（毫秒）
     *   - 默认值: 300000 (5分钟)
     *   - 建议范围: 60000-3600000 (1分钟-1小时)
     *   - 影响故障预测的准确性
     * 
     * enablePrediction: 是否启用预测功能
     *   - 默认值: true
     *   - 可根据需要开启或关闭
     * 
     * maxRetries: 最大重试次数
     *   - 默认值: 3
     *   - 建议范围: 1-10
     *   - 防止网络波动导致监控中断
     * 
     * retryDelay: 重试延迟（毫秒）
     *   - 默认值: 1000 (1秒)
     *   - 建议范围: 500-10000 (0.5秒-10秒)
     *   - 递增延迟可避免重试风暴
     */
    
    public static void explainConfigParameters() {
        System.out.println("MonitorConfig 参数详解:");
        System.out.println("interval: 监控间隔，影响监控实时性和系统负载");
        System.out.println("predictionWindow: 预测时间窗口，影响预测准确性");
        System.out.println("enablePrediction: 预测功能开关，可根据需要启用/禁用");
        System.out.println("maxRetries: 最大重试次数，提高监控可靠性");
        System.out.println("retryDelay: 重试延迟，避免重试风暴");
    }
}
```


## 7. 错误处理

### 7.1 异常处理示例

```java
public class EquipmentMonitorErrorHandler {
    public void handleMonitoringErrors() {
        System.out.println("设备监控错误处理示例");
        
        try {
            // 创建状态监听器
            EquipmentMonitor.StatusListener listener = new EquipmentMonitor.StatusListener() {
                @Override
                public void onStatusUpdate(EquipmentMonitor.EquipmentStatus status) {
                    System.out.println("设备状态更新: " + status.getEquipmentId() + " - " + status.getState());
                }
                
                @Override
                public void onError(EquipmentMonitor.EquipmentMonitoringException exception) {
                    System.err.println("监控错误: " + exception.getMessage());
                    // 根据错误类型采取不同处理措施
                    handleSpecificError(exception);
                }
            };
            
            // 启动监控
            String equipmentId = "EQ-ERROR-TEST";
            EquipmentMonitor.MonitorConfig config = new EquipmentMonitor.MonitorConfig();
            
            boolean started = EquipmentMonitor.startMonitoring(equipmentId, listener, config);
            System.out.println("监控启动: " + (started ? "成功" : "失败"));
            
            // 等待一段时间
            Thread.sleep(5000);
            
            // 停止监控
            EquipmentMonitor.stopMonitoring(equipmentId);
            
        } catch (Exception e) {
            System.err.println("监控过程中发生异常: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    private void handleSpecificError(EquipmentMonitor.EquipmentMonitoringException exception) {
        String message = exception.getMessage();
        
        if (message.contains("connection")) {
            System.err.println("  连接错误，检查网络连接");
        } else if (message.contains("timeout")) {
            System.err.println("  超时错误，设备无响应");
        } else if (message.contains("authentication")) {
            System.err.println("  认证错误，检查设备凭证");
        } else {
            System.err.println("  未知错误类型");
        }
        
        // 记录错误日志
        System.err.println("  错误时间: " + new Date());
        System.err.println("  错误详情: " + message);
    }
    
    public boolean safeMonitoringOperation(String equipmentId) {
        if (equipmentId == null || equipmentId.isEmpty()) {
            System.err.println("设备ID不能为空");
            return false;
        }
        
        int maxRetries = 3;
        int retryCount = 0;
        
        while (retryCount < maxRetries) {
            try {
                EquipmentMonitor.EquipmentStatus status = EquipmentMonitor.getCurrentStatus(equipmentId);
                
                if (status != null) {
                    System.out.println("设备状态查询成功: " + status.getState());
                    return true;
                } else {
                    System.err.println("第" + (retryCount + 1) + "次查询失败");
                }
                
            } catch (Exception e) {
                System.err.println("第" + (retryCount + 1) + "次查询异常: " + e.getMessage());
            }
            
            retryCount++;
            
            // 重试前等待
            if (retryCount < maxRetries) {
                try {
                    Thread.sleep(1000 * retryCount); // 递增延迟
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
        
        System.err.println("设备状态查询最终失败，已重试 " + maxRetries + " 次");
        return false;
    }
}
```


## 8. 最佳实践

### 8.1 监控策略最佳实践

```java
public class MonitoringBestPractices {
    public void demonstrateBestPractices() {
        System.out.println("设备监控最佳实践演示");
        
        // 1. 配置管理
        System.out.println("1. 配置管理");
        manageConfigurations();
        
        // 2. 状态监听
        System.out.println("2. 状态监听");
        implementStatusListeners();
        
        // 3. 错误处理
        System.out.println("3. 错误处理");
        handleErrorsGracefully();
        
        // 4. 资源管理
        System.out.println("4. 资源管理");
        manageResourcesProperly();
    }
    
    private void manageConfigurations() {
        System.out.println("配置管理实践:");
        
        // 根据设备重要性设置不同监控间隔
        EquipmentMonitor.MonitorConfig criticalConfig = new EquipmentMonitor.MonitorConfig()
                .setInterval(1000)  // 关键设备每秒监控
                .setEnablePrediction(true)
                .setPredictionWindow(300000);  // 5分钟预测窗口
        
        EquipmentMonitor.MonitorConfig normalConfig = new EquipmentMonitor.MonitorConfig()
                .setInterval(5000)  // 普通设备每5秒监控
                .setEnablePrediction(true)
                .setPredictionWindow(600000);  // 10分钟预测窗口
        
        EquipmentMonitor.MonitorConfig lowPriorityConfig = new EquipmentMonitor.MonitorConfig()
                .setInterval(30000)  // 低优先级设备每30秒监控
                .setEnablePrediction(false);  // 不启用预测
        
        System.out.println("  关键设备配置: " + criticalConfig.getInterval() + "ms 间隔");
        System.out.println("  普通设备配置: " + normalConfig.getInterval() + "ms 间隔");
        System.out.println("  低优先级设备配置: " + lowPriorityConfig.getInterval() + "ms 间隔");
    }
    
    private void implementStatusListeners() {
        System.out.println("状态监听实践:");
        
        EquipmentMonitor.StatusListener listener = new EquipmentMonitor.StatusListener() {
            @Override
            public void onStatusUpdate(EquipmentMonitor.EquipmentStatus status) {
                // 记录状态变化
                logStatusChange(status);
                
                // 根据状态采取行动
                handleStatusChange(status);
            }
            
            @Override
            public void onError(EquipmentMonitor.EquipmentMonitoringException exception) {
                // 记录错误
                logError(exception);
                
                // 发送告警
                sendAlert(exception);
            }
        };
        
        System.out.println("  实现了完整的状态监听机制");
        System.out.println("  包含状态变化处理和错误处理");
    }
    
    private void handleErrorsGracefully() {
        System.out.println("错误处理实践:");
        
        // 实现重试机制
        System.out.println("  实现了重试机制");
        
        // 实现降级策略
        System.out.println("  实现了降级策略");
        
        // 实现告警机制
        System.out.println("  实现了告警机制");
    }
    
    private void manageResourcesProperly() {
        System.out.println("资源管理实践:");
        
        // 合理使用线程池
        System.out.println("  使用共享线程池减少资源消耗");
        
        // 及时释放资源
        System.out.println("  及时停止监控任务释放资源");
        
        // 避免内存泄漏
        System.out.println("  正确管理监听器引用避免内存泄漏");
    }
    
    private void logStatusChange(EquipmentMonitor.EquipmentStatus status) {
        // 实现状态变化日志记录
        System.out.println("    记录状态变化: " + status.getEquipmentId() + " -> " + status.getState());
    }
    
    private void handleStatusChange(EquipmentMonitor.EquipmentStatus status) {
        // 根据状态变化采取相应行动
        switch (status.getState()) {
            case ERROR:
                System.err.println("    设备错误，需要处理: " + status.getEquipmentId());
                break;
            case OFFLINE:
                System.err.println("    设备离线，检查连接: " + status.getEquipmentId());
                break;
            case MAINTENANCE:
                System.out.println("    设备维护中: " + status.getEquipmentId());
                break;
            default:
                System.out.println("    设备状态正常: " + status.getEquipmentId() + " -> " + status.getState());
        }
    }
    
    private void logError(EquipmentMonitor.EquipmentMonitoringException exception) {
        // 记录错误日志
        System.err.println("    记录监控错误: " + exception.getMessage());
    }
    
    private void sendAlert(EquipmentMonitor.EquipmentMonitoringException exception) {
        // 发送告警通知
        System.err.println("    发送告警通知: " + exception.getMessage());
    }
}
```


### 8.2 性能优化实践

```java
public class PerformanceOptimization {
    private final Map<String, EquipmentMonitor.EquipmentStatus> statusCache = new ConcurrentHashMap<>();
    private final long cacheTimeout = 10 * 1000; // 10秒
    
    public void demonstratePerformanceOptimization() {
        System.out.println("设备监控性能优化实践");
        
        // 1. 状态缓存
        System.out.println("1. 状态缓存优化");
        useStatusCaching();
        
        // 2. 批量处理
        System.out.println("2. 批量处理优化");
        optimizeBatchProcessing();
        
        // 3. 异步处理
        System.out.println("3. 异步处理优化");
        useAsyncProcessing();
        
        // 4. 连接复用
        System.out.println("4. 连接复用优化");
        reuseConnections();
    }
    
    private void useStatusCaching() {
        System.out.println("状态缓存优化:");
        
        // 缓存设备状态以减少重复查询
        String equipmentId = "EQ-PERFORMANCE-TEST";
        EquipmentMonitor.EquipmentStatus cachedStatus = statusCache.get(equipmentId);
        
        if (cachedStatus != null && 
            (System.currentTimeMillis() - cachedStatus.getTimestamp()) < cacheTimeout) {
            System.out.println("  从缓存获取状态: " + cachedStatus.getState());
        } else {
            // 从监控系统获取最新状态
            EquipmentMonitor.EquipmentStatus freshStatus = EquipmentMonitor.getCurrentStatus(equipmentId);
            if (freshStatus != null) {
                statusCache.put(equipmentId, freshStatus);
                System.out.println("  获取并缓存最新状态: " + freshStatus.getState());
            }
        }
        
        System.out.println("  缓存状态数量: " + statusCache.size());
    }
    
    private void optimizeBatchProcessing() {
        System.out.println("批量处理优化:");
        
        // 批量查询多个设备状态
        String[] equipmentIds = {"EQ-001", "EQ-002", "EQ-003", "EQ-004", "EQ-005"};
        
        System.out.println("  批量查询 " + equipmentIds.length + " 个设备状态");
        
        List<EquipmentMonitor.EquipmentStatus> statuses = new ArrayList<>();
        for (String equipmentId : equipmentIds) {
            EquipmentMonitor.EquipmentStatus status = EquipmentMonitor.getCurrentStatus(equipmentId);
            if (status != null) {
                statuses.add(status);
            }
        }
        
        System.out.println("  成功获取 " + statuses.size() + " 个设备状态");
        
        // 批量计算健康度评分
        System.out.println("  批量计算健康度评分");
        for (String equipmentId : equipmentIds) {
            EquipmentMonitor.HealthScore score = EquipmentMonitor.calculateHealthScore(equipmentId);
            if (score != null) {
                System.out.println("    " + equipmentId + ": " + 
                                 String.format("%.1f", score.getScore() * 100) + "%");
            }
        }
    }
    
    private void useAsyncProcessing() {
        System.out.println("异步处理优化:");
        
        // 使用异步方式处理监控任务
        ExecutorService executor = Executors.newFixedThreadPool(5);
        
        List<CompletableFuture<String>> futures = new ArrayList<>();
        
        for (int i = 1; i <= 5; i++) {
            final int taskId = i;
            CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
                try {
                    // 模拟设备状态查询
                    Thread.sleep(100 + (long) (Math.random() * 200));
                    return "Task " + taskId + " completed: EQ-ASYNC-" + taskId + " status OK";
                } catch (Exception e) {
                    return "Task " + taskId + " failed: " + e.getMessage();
                }
            }, executor);
            
            futures.add(future);
        }
        
        // 等待所有任务完成
        CompletableFuture<Void> allDone = CompletableFuture.allOf(
            futures.toArray(new CompletableFuture[0])
        );
        
        try {
            allDone.get(10, TimeUnit.SECONDS);
            System.out.println("  所有异步任务完成");
        } catch (Exception e) {
            System.err.println("  异步任务执行超时或异常: " + e.getMessage());
        } finally {
            executor.shutdown();
        }
    }
    
    private void reuseConnections() {
        System.out.println("连接复用优化:");
        
        // 复用监控连接减少建立/关闭开销
        System.out.println("  复用现有的监控连接");
        System.out.println("  避免频繁建立和关闭连接");
        System.out.println("  使用连接池管理连接资源");
    }
}
```


## 9. 系统集成

### 9.1 与Spring框架集成

```java
@Component
public class SpringEquipmentMonitoringService {
    
    @Autowired
    private EquipmentMonitor equipmentMonitor; // 假设EquipmentMonitor被Spring管理
    
    // 设备状态监控服务
    public boolean startEquipmentMonitoring(String equipmentId, EquipmentMonitor.StatusListener listener) {
        EquipmentMonitor.MonitorConfig config = new EquipmentMonitor.MonitorConfig()
                .setInterval(5000)
                .setEnablePrediction(true);
        
        return EquipmentMonitor.startMonitoring(equipmentId, listener, config);
    }
    
    // 设备状态查询服务
    @Async
    public CompletableFuture<EquipmentMonitor.EquipmentStatus> getEquipmentStatusAsync(String equipmentId) {
        EquipmentMonitor.EquipmentStatus status = EquipmentMonitor.getCurrentStatus(equipmentId);
        return CompletableFuture.completedFuture(status);
    }
    
    // 设备健康度评分服务
    @Scheduled(fixedRate = 3600000) // 每小时计算一次
    public void calculatePeriodicHealthScores() {
        // 获取所有监控的设备
        // List<String> equipmentIds = getAllMonitoredEquipment();
        
        // for (String equipmentId : equipmentIds) {
        //     EquipmentMonitor.HealthScore score = EquipmentMonitor.calculateHealthScore(equipmentId);
        //     if (score != null) {
        //         // 保存或发送健康度评分
        //         saveHealthScore(score);
        //     }
        // }
        
        System.out.println("定时计算设备健康度评分");
    }
    
    // 设备故障预测服务
    @EventListener
    public void handleEquipmentEvent(EquipmentEvent event) {
        // 处理设备事件并进行故障预测
        // List<EquipmentMonitor.FaultPrediction> predictions = 
        //     EquipmentMonitor.predictFaults(event.getEquipmentId(), new EquipmentMonitor.MonitorConfig());
        
        System.out.println("处理设备事件并进行故障预测: " + event.getEquipmentId());
    }
    
    // 设备利用率报告服务
    public EquipmentMonitor.UtilizationReport getEquipmentUtilizationReport(
            String equipmentId, 
            EquipmentMonitor.TimeRange timeRange) {
        return EquipmentMonitor.generateUtilizationReport(equipmentId, timeRange);
    }
}

// 设备事件类
class EquipmentEvent extends ApplicationEvent {
    private final String equipmentId;
    private final EquipmentMonitor.EquipmentState state;
    private final long timestamp;
    
    public EquipmentEvent(Object source, String equipmentId, EquipmentMonitor.EquipmentState state) {
        super(source);
        this.equipmentId = equipmentId;
        this.state = state;
        this.timestamp = System.currentTimeMillis();
    }
    
    // Getters
    public String getEquipmentId() { return equipmentId; }
    public EquipmentMonitor.EquipmentState getState() { return state; }
    public long getTimestamp() { return timestamp; }
}
```


### 9.2 与消息队列集成

```java
@Component
public class MessageQueueIntegration {
    
    // Kafka集成示例
    @KafkaListener(topics = "equipment-status", groupId = "equipment-monitor-processor")
    public void handleEquipmentStatus(String statusJson) {
        try {
            // 解析JSON到设备状态对象
            EquipmentStatusMessage statusMessage = parseStatusFromJson(statusJson);
            
            // 处理设备状态更新
            processEquipmentStatus(statusMessage);
            
        } catch (Exception e) {
            System.err.println("处理设备状态时发生错误: " + e.getMessage());
        }
    }
    
    @KafkaListener(topics = "equipment-alerts", groupId = "equipment-monitor-processor")
    public void handleEquipmentAlert(String alertJson) {
        try {
            // 解析JSON到设备告警对象
            EquipmentAlertMessage alertMessage = parseAlertFromJson(alertJson);
            
            // 处理设备告警
            handleEquipmentAlert(alertMessage);
            
        } catch (Exception e) {
            System.err.println("处理设备告警时发生错误: " + e.getMessage());
        }
    }
    
    // RabbitMQ集成示例
    @RabbitListener(queues = "equipment-entity-queue")
    public void handleEquipmentCommand(EquipmentCommandMessage commandMessage) {
        try {
            // 执行设备命令
            executeEquipmentCommand(commandMessage);
            
        } catch (Exception e) {
            System.err.println("执行设备命令时发生错误: " + e.getMessage());
        }
    }
    
    // 私有辅助方法
    private EquipmentStatusMessage parseStatusFromJson(String json) {
        // 实现JSON到设备状态对象的解析
        return new EquipmentStatusMessage("EQ-001", "RUNNING", System.currentTimeMillis());
    }
    
    private EquipmentAlertMessage parseAlertFromJson(String json) {
        // 实现JSON到设备告警对象的解析
        return new EquipmentAlertMessage("EQ-001", "HIGH_TEMPERATURE", "Temperature exceeded threshold");
    }
    
    private void processEquipmentStatus(EquipmentStatusMessage statusMessage) {
        System.out.println("处理设备状态更新: " + statusMessage.getEquipmentId() + 
                          " -> " + statusMessage.getState());
        // 实现具体的设备状态处理逻辑
    }
    
    private void handleEquipmentAlert(EquipmentAlertMessage alertMessage) {
        System.out.println("处理设备告警: " + alertMessage.getEquipmentId() + 
                          " - " + alertMessage.getAlertType() + 
                          ": " + alertMessage.getMessage());
        // 实现具体的设备告警处理逻辑
    }
    
    private void executeEquipmentCommand(EquipmentCommandMessage commandMessage) {
        System.out.println("执行设备命令: " + commandMessage.getEquipmentId() + 
                          " - " + commandMessage.getCommand());
        // 实现具体的设备命令执行逻辑
    }
}

// 设备状态消息类
class EquipmentStatusMessage {
    private String equipmentId;
    private String state;
    private long timestamp;
    
    public EquipmentStatusMessage(String equipmentId, String state, long timestamp) {
        this.equipmentId = equipmentId;
        this.state = state;
        this.timestamp = timestamp;
    }
    
    // Getters and Setters
    public String getEquipmentId() { return equipmentId; }
    public void setEquipmentId(String equipmentId) { this.equipmentId = equipmentId; }
    
    public String getState() { return state; }
    public void setState(String state) { this.state = state; }
    
    public long getTimestamp() { return timestamp; }
    public void setTimestamp(long timestamp) { this.timestamp = timestamp; }
}

// 设备告警消息类
class EquipmentAlertMessage {
    private String equipmentId;
    private String alertType;
    private String message;
    private long timestamp;
    
    public EquipmentAlertMessage(String equipmentId, String alertType, String message) {
        this.equipmentId = equipmentId;
        this.alertType = alertType;
        this.message = message;
        this.timestamp = System.currentTimeMillis();
    }
    
    // Getters and Setters
    public String getEquipmentId() { return equipmentId; }
    public void setEquipmentId(String equipmentId) { this.equipmentId = equipmentId; }
    
    public String getAlertType() { return alertType; }
    public void setAlertType(String alertType) { this.alertType = alertType; }
    
    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
    
    public long getTimestamp() { return timestamp; }
    public void setTimestamp(long timestamp) { this.timestamp = timestamp; }
}

// 设备命令消息类
class EquipmentCommandMessage {
    private String equipmentId;
    private String command;
    private Map<String, Object> parameters;
    private long timestamp;
    
    // Getters and Setters
    public String getEquipmentId() { return equipmentId; }
    public void setEquipmentId(String equipmentId) { this.equipmentId = equipmentId; }
    
    public String getCommand() { return command; }
    public void setCommand(String command) { this.command = command; }
    
    public Map<String, Object> getParameters() { return parameters; }
    public void setParameters(Map<String, Object> parameters) { this.parameters = parameters; }
    
    public long getTimestamp() { return timestamp; }
    public void setTimestamp(long timestamp) { this.timestamp = timestamp; }
}
```


这个使用说明文档涵盖了 [EquipmentMonitor](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\semiconductor\equipment\monitor\EquipmentMonitor.java#L29-L548) 的主要功能和使用方法，可以帮助开发者快速上手并正确使用该设备监控工具类。