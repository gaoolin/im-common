# TestDataParser 使用说明文档

## 1. 概述

[TestDataParser](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\semiconductor\test\data\TestDataParser.java#L30-L582) 是一个专业的测试数据解析工具类，专门用于处理半导体封测行业中的各种测试数据格式。该工具支持多种数据格式的解析、标准化转换、统计分析和异常检测，能够有效解决测试数据处理中的常见问题。

## 2. 核心功能

### 2.1 多格式测试数据解析
支持 STDF、CSV、JSON、XML 等多种测试数据格式的解析

### 2.2 测试数据标准化转换
将不同格式的原始测试数据转换为统一的标准格式

### 2.3 测试数据统计分析
提供全面的测试数据统计分析功能

### 2.4 测试数据异常检测
自动检测测试数据中的异常情况

## 3. 支持的数据格式

```java
public enum TestFormat {
    STDF("stdf", "Standard Test Data Format"),
    CSV("csv", "Comma-Separated Values"),
    JSON("json", "JavaScript Object Notation"),
    XML("xml", "eXtensible Markup Language"),
    TXT("txt", "Plain Text"),
    CUSTOM("custom", "Custom Format"),
    AUTO_DETECT("auto", "Auto Detect Format");
}
```


## 4. 基本使用方法

### 4.1 解析测试数据文件

```java
// 基本解析
TestDataParser.ParseResult result = TestDataParser.parseTestData(
    "/path/to/testdata.stdf", 
    TestDataParser.TestFormat.STDF
);

if (result.isSuccess()) {
    TestResultSet resultSet = result.getResultSet();
    System.out.println("解析成功，共处理 " + result.getRecordCount() + " 条记录");
    System.out.println("解析耗时: " + result.getParseTime() + "ms");
} else {
    System.err.println("解析失败:");
    for (TestDataParser.ParseError error : result.getErrors()) {
        System.err.println("  行号: " + error.getLineNumber() + 
                          ", 错误: " + error.getErrorMessage());
    }
}
```


### 4.2 使用自定义配置解析

```java
// 创建解析配置
TestDataParser.ParseConfig config = new TestDataParser.ParseConfig()
    .setFormat(TestDataParser.TestFormat.AUTO_DETECT)  // 自动检测格式
    .setEncoding("UTF-8")                              // 设置编码
    .setTimeout(60000)                                 // 设置超时时间60秒
    .setValidateData(true)                             // 启用数据验证
    .setMaxErrors(50)                                  // 最大错误数50
    .setContinueOnError(true);                         // 出错继续处理

// 使用配置解析
TestDataParser.ParseResult result = TestDataParser.parseTestData(
    "/path/to/testdata.csv", 
    config
);
```


## 5. 数据标准化处理

### 5.1 标准化原始测试结果

```java
// 假设已有原始测试结果
RawTestResult rawResult = getRawTestResult();

// 标准化处理
StandardTestResult standardResult = TestDataParser.standardizeTestResult(rawResult);

if (standardResult != null) {
    System.out.println("标准化结果:");
    System.out.println("  Lot ID: " + standardResult.getLotId());
    System.out.println("  Wafer ID: " + standardResult.getWaferId());
    System.out.println("  Device ID: " + standardResult.getDeviceId());
    System.out.println("  测试项数量: " + standardResult.getTestItems().size());
    
    // 显示统计信息
    TestStatistics stats = standardResult.getStatistics();
    if (stats != null) {
        System.out.println("  总测试数: " + stats.getTotalTests());
        System.out.println("  通过测试数: " + stats.getPassTests());
        System.out.println("  测试良率: " + String.format("%.2f%%", stats.getYield() * 100));
    }
}
```


## 6. 统计分析功能

### 6.1 计算测试统计数据

```java
// 假设已有解析结果
TestResultSet resultSet = getTestResultSet();

// 计算统计信息
TestStatistics statistics = TestDataParser.calculateStatistics(resultSet);

System.out.println("测试统计分析结果:");
System.out.println("  总记录数: " + statistics.getTotalRecords());
System.out.println("  通过记录数: " + statistics.getPassRecords());
System.out.println("  记录良率: " + String.format("%.2f%%", statistics.getRecordYield() * 100));
System.out.println("  总测试数: " + statistics.getTotalTests());
System.out.println("  通过测试数: " + statistics.getPassTests());
System.out.println("  测试良率: " + String.format("%.2f%%", statistics.getYield() * 100));
```


## 7. 异常检测功能

### 7.1 检测测试数据异常

```java
// 假设已有解析结果
TestResultSet resultSet = getTestResultSet();

// 检测异常
List<TestAnomaly> anomalies = TestDataParser.detectAnomalies(resultSet, new TestDataParser.ParseConfig());

System.out.println("检测到 " + anomalies.size() + " 个异常:");

for (TestAnomaly anomaly : anomalies) {
    System.out.println("  异常类型: " + anomaly.getType());
    System.out.println("    描述: " + anomaly.getDescription());
    System.out.println("    记录索引: " + anomaly.getRecordIndex());
    
    TestRecord record = anomaly.getRecord();
    if (record != null) {
        System.out.println("    设备ID: " + record.getDeviceId());
    }
}
```


## 8. 高级使用示例

### 8.1 批量处理测试数据文件

```java
public class BatchTestProcessor {
    public void processTestFiles(List<String> filePaths) {
        for (String filePath : filePaths) {
            try {
                System.out.println("处理文件: " + filePath);
                
                // 解析测试数据
                TestDataParser.ParseResult result = TestDataParser.parseTestData(
                    filePath, 
                    TestDataParser.TestFormat.AUTO_DETECT
                );
                
                if (result.isSuccess()) {
                    // 标准化处理
                    processParsedData(result.getResultSet());
                } else {
                    System.err.println("文件解析失败: " + filePath);
                    handleParseErrors(result.getErrors());
                }
            } catch (Exception e) {
                System.err.println("处理文件时发生异常: " + filePath);
                e.printStackTrace();
            }
        }
    }
    
    private void processParsedData(TestResultSet resultSet) {
        // 标准化处理
        // 注意：这里需要将TestRecord转换为RawTestResult
        // 实际使用中可能需要根据具体情况调整
        
        // 统计分析
        TestStatistics statistics = TestDataParser.calculateStatistics(resultSet);
        System.out.println("统计结果: " + statistics);
        
        // 异常检测
        List<TestAnomaly> anomalies = TestDataParser.detectAnomalies(
            resultSet, 
            new TestDataParser.ParseConfig()
        );
        
        if (!anomalies.isEmpty()) {
            System.out.println("发现 " + anomalies.size() + " 个异常");
            // 处理异常...
        }
    }
    
    private void handleParseErrors(List<TestDataParser.ParseError> errors) {
        for (TestDataParser.ParseError error : errors) {
            System.err.println("  行 " + error.getLineNumber() + ": " + error.getErrorMessage());
        }
    }
}
```


### 8.2 自定义解析器扩展

```java
// 实现自定义解析器
public class CustomTestParser implements TestDataParser.TestFormatParser {
    @Override
    public TestDataParser.TestResultSet parse(InputStream inputStream, TestDataParser.ParseConfig config) throws Exception {
        TestDataParser.TestResultSet resultSet = new TestDataParser.TestResultSet();
        
        // 实现自定义解析逻辑
        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, config.getEncoding()));
        String line;
        int lineNumber = 0;
        
        while ((line = reader.readLine()) != null) {
            lineNumber++;
            try {
                // 解析每一行数据
                TestDataParser.TestRecord record = parseLine(line);
                resultSet.addTestRecord(record);
            } catch (Exception e) {
                if (!config.isContinueOnError() || 
                    resultSet.getTestRecords().size() >= config.getMaxErrors()) {
                    throw new Exception("解析失败 at line " + lineNumber, e);
                }
                // 继续处理其他行
            }
        }
        
        return resultSet;
    }
    
    private TestDataParser.TestRecord parseLine(String line) {
        // 实现具体的行解析逻辑
        TestDataParser.TestRecord record = new TestDataParser.TestRecord();
        // ... 解析逻辑 ...
        return record;
    }
    
    @Override
    public boolean supportsFormat(TestDataParser.TestFormat format) {
        return format == TestDataParser.TestFormat.CUSTOM;
    }
    
    @Override
    public String getFormatName() {
        return "Custom Test Parser";
    }
}

// 注册自定义解析器
TestDataParser.registerParser(new CustomTestParser());
```


## 9. 配置参数详解

### 9.1 ParseConfig 配置项

```java
TestDataParser.ParseConfig config = new TestDataParser.ParseConfig()
    .setFormat(TestDataParser.TestFormat.AUTO_DETECT)  // 数据格式
    .setEncoding("UTF-8")                              // 字符编码
    .setTimeout(30000)                                 // 超时时间(毫秒)
    .setValidateData(true)                             // 是否验证数据
    .setEnableCompression(true)                        // 是否支持压缩
    .setMaxErrors(100)                                 // 最大错误数
    .setContinueOnError(true);                         // 出错是否继续
```


## 10. 错误处理

### 10.1 解析错误处理

```java
TestDataParser.ParseResult result = TestDataParser.parseTestData(filePath, config);

if (!result.isSuccess()) {
    System.err.println("解析失败，错误信息:");
    for (TestDataParser.ParseError error : result.getErrors()) {
        System.err.println("  行号: " + error.getLineNumber());
        System.err.println("  错误: " + error.getErrorMessage());
        System.err.println("  数据: " + error.getErrorData());
        
        if (error.getException() != null) {
            System.err.println("  异常: " + error.getException().getMessage());
        }
    }
}
```


## 11. 性能优化建议

### 11.1 大文件处理
```java
// 对于大文件，建议使用流式处理
TestDataParser.ParseConfig config = new TestDataParser.ParseConfig()
    .setTimeout(120000)        // 增加超时时间
    .setMaxErrors(1000)        // 增加最大错误数
    .setContinueOnError(true); // 出错继续处理
```


### 11.2 内存管理
```java
// 及时释放不需要的对象引用
result = null;
System.gc(); // 建议性垃圾回收
```


## 12. 最佳实践

### 12.1 文件处理流程
```java
public class TestDataManager {
    public void processTestDataFile(String filePath) {
        try {
            // 1. 解析原始数据
            TestDataParser.ParseResult parseResult = TestDataParser.parseTestData(
                filePath, 
                TestDataParser.TestFormat.AUTO_DETECT
            );
            
            if (!parseResult.isSuccess()) {
                handleParseFailure(parseResult.getErrors());
                return;
            }
            
            // 2. 统计分析
            TestStatistics statistics = TestDataParser.calculateStatistics(
                parseResult.getResultSet()
            );
            
            // 3. 异常检测
            List<TestAnomaly> anomalies = TestDataParser.detectAnomalies(
                parseResult.getResultSet(),
                new TestDataParser.ParseConfig()
            );
            
            // 4. 生成报告
            generateReport(parseResult, statistics, anomalies);
            
        } catch (Exception e) {
            System.err.println("处理测试数据文件时发生异常: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    private void handleParseFailure(List<TestDataParser.ParseError> errors) {
        System.err.println("文件解析失败，共 " + errors.size() + " 个错误:");
        for (TestDataParser.ParseError error : errors) {
            System.err.println("  - " + error.getErrorMessage());
        }
    }
    
    private void generateReport(TestDataParser.ParseResult result, 
                              TestStatistics statistics, 
                              List<TestAnomaly> anomalies) {
        System.out.println("=== 测试数据处理报告 ===");
        System.out.println("处理结果: " + (result.isSuccess() ? "成功" : "失败"));
        System.out.println("记录数量: " + result.getRecordCount());
        System.out.println("处理时间: " + result.getParseTime() + "ms");
        System.out.println("统计数据: " + statistics);
        System.out.println("异常数量: " + anomalies.size());
    }
}
```


这个使用说明文档涵盖了 [TestDataParser](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\semiconductor\test\data\TestDataParser.java#L30-L582) 的主要功能和使用方法，可以帮助开发者快速上手并正确使用该工具类。