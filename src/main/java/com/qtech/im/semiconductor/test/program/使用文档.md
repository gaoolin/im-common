# TestProgramManager 使用说明文档

## 1. 概述

[TestProgramManager](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\semiconductor\test\program\TestProgramManager.java#L28-L223) 是一个专业的测试程序管理工具类，专门为半导体封测行业的测试程序管理设计。该工具解决了多种测试程序格式支持困难、程序管理接口不统一、版本控制和兼容性检查不完善、程序完整性验证缺失等问题。

## 2. 核心功能

### 2.1 多格式测试程序支持
- 支持TPF、XML、JSON等多种测试程序格式
- 自动识别程序格式并选择合适的加载器
- 可扩展的自定义程序加载器支持

### 2.2 程序缓存和复用
- 智能程序缓存机制提高加载效率
- 缓存过期管理确保程序新鲜度
- 灵活的缓存控制选项

### 2.3 版本控制和兼容性检查
- 完善的程序版本管理
- 设备与程序兼容性验证
- 详细的兼容性检查日志

### 2.4 程序部署管理
- 支持向设备部署测试程序
- 部署过程错误处理和恢复
- 部署状态跟踪和日志记录

## 3. 支持的程序格式

### 3.1 支持的格式类型
- **TPF格式**: 传统的测试程序格式
- **XML格式**: 结构化测试程序格式
- **JSON格式**: 现代化测试程序格式

## 4. 基本使用方法

### 4.1 加载测试程序

```java
// 测试程序加载示例
public class TestProgramLoadingExample {
    public void loadTestPrograms() {
        System.out.println("开始测试程序加载示例...");
        
        // 1. 创建程序配置
        TestProgramManager.ProgramConfig config = new TestProgramManager.ProgramConfig()
                .setProgramPath("programs/test_program.tpf")
                .setVersion("1.2.3")
                .setEquipmentModel("ATE-5000")
                .setTimeout(30000)
                .setUseCache(true);
        
        System.out.println("1. 创建程序配置:");
        System.out.println("  程序路径: " + config.getProgramPath());
        System.out.println("  程序版本: " + config.getVersion());
        System.out.println("  设备型号: " + config.getEquipmentModel());
        System.out.println("  超时时间: " + config.getTimeout() + "ms");
        System.out.println("  使用缓存: " + config.isUseCache());
        
        // 2. 加载测试程序
        TestProgramManager.TestProgram program = 
            TestProgramManager.loadTestProgram(config);
        
        if (program != null) {
            System.out.println("\n2. 加载测试程序成功:");
            System.out.println("  程序路径: " + program.getPath());
            System.out.println("  程序版本: " + program.getVersion());
            System.out.println("  加载时间: " + new Date(program.getLoadTime()));
            System.out.println("  是否过期: " + program.isExpired());
        } else {
            System.err.println("\n2. 测试程序加载失败");
        }
        
        // 3. 加载不同格式的程序
        System.out.println("\n3. 加载不同格式的程序:");
        
        // 加载XML格式程序
        TestProgramManager.ProgramConfig xmlConfig = new TestProgramManager.ProgramConfig()
                .setProgramPath("programs/device_config.xml")
                .setVersion("2.0.1")
                .setUseCache(true);
        
        TestProgramManager.TestProgram xmlProgram = 
            TestProgramManager.loadTestProgram(xmlConfig);
        
        if (xmlProgram != null) {
            System.out.println("  XML程序加载成功: " + xmlProgram.getPath());
        }
        
        // 加载JSON格式程序
        TestProgramManager.ProgramConfig jsonConfig = new TestProgramManager.ProgramConfig()
                .setProgramPath("programs/test_flow.json")
                .setVersion("1.5.0")
                .setUseCache(true);
        
        TestProgramManager.TestProgram jsonProgram = 
            TestProgramManager.loadTestProgram(jsonConfig);
        
        if (jsonProgram != null) {
            System.out.println("  JSON程序加载成功: " + jsonProgram.getPath());
        }
        
        // 4. 不使用缓存加载程序
        System.out.println("\n4. 不使用缓存加载程序:");
        TestProgramManager.ProgramConfig noCacheConfig = new TestProgramManager.ProgramConfig()
                .setProgramPath("programs/critical_program.tpf")
                .setVersion("3.1.4")
                .setUseCache(false); // 禁用缓存
        
        TestProgramManager.TestProgram noCacheProgram = 
            TestProgramManager.loadTestProgram(noCacheConfig);
        
        if (noCacheProgram != null) {
            System.out.println("  无缓存程序加载成功: " + noCacheProgram.getPath());
        }
    }
}
```


### 4.2 程序兼容性验证

```java
// 程序兼容性验证示例
public class ProgramCompatibilityExample {
    public void validateProgramCompatibility() {
        System.out.println("开始程序兼容性验证示例...");
        
        // 1. 验证设备与程序的兼容性
        String equipmentModel = "ATE-5000";
        String programVersion = "2.3.1";
        
        System.out.println("1. 验证设备与程序的兼容性:");
        System.out.println("  设备型号: " + equipmentModel);
        System.out.println("  程序版本: " + programVersion);
        
        boolean compatible = TestProgramManager.validateProgramCompatibility(
            equipmentModel, programVersion);
        
        System.out.println("  兼容性检查结果: " + (compatible ? "兼容" : "不兼容"));
        
        // 2. 批量兼容性验证
        System.out.println("\n2. 批量兼容性验证:");
        
        // 设备型号列表
        List<String> equipmentModels = Arrays.asList(
            "ATE-5000", "ATE-6000", "ATE-7000", "J750", "Uflex"
        );
        
        // 程序版本列表
        List<String> programVersions = Arrays.asList(
            "1.0.0", "2.0.0", "2.3.1", "3.0.0"
        );
        
        System.out.println("  设备型号数: " + equipmentModels.size());
        System.out.println("  程序版本数: " + programVersions.size());
        
        // 执行兼容性矩阵检查
        int compatibleCount = 0;
        int totalCount = 0;
        
        for (String equipment : equipmentModels) {
            for (String version : programVersions) {
                boolean isCompatible = TestProgramManager.validateProgramCompatibility(
                    equipment, version);
                totalCount++;
                if (isCompatible) {
                    compatibleCount++;
                }
            }
        }
        
        System.out.println("  兼容性检查完成:");
        System.out.println("    总检查数: " + totalCount);
        System.out.println("    兼容数: " + compatibleCount);
        System.out.println("    兼容率: " + String.format("%.2f", (double) compatibleCount / totalCount * 100) + "%");
        
        // 3. 特定场景兼容性验证
        System.out.println("\n3. 特定场景兼容性验证:");
        
        // 验证新设备与旧程序的兼容性
        boolean newEquipmentOldProgram = TestProgramManager.validateProgramCompatibility(
            "ATE-8000", "1.5.0");
        System.out.println("  新设备(ATE-8000)运行旧程序(1.5.0): " + 
                         (newEquipmentOldProgram ? "兼容" : "不兼容"));
        
        // 验证旧设备与新程序的兼容性
        boolean oldEquipmentNewProgram = TestProgramManager.validateProgramCompatibility(
            "ATE-3000", "3.2.0");
        System.out.println("  旧设备(ATE-3000)运行新程序(3.2.0): " + 
                         (oldEquipmentNewProgram ? "兼容" : "不兼容"));
    }
}
```


### 4.3 程序部署管理

```java
// 程序部署管理示例
public class ProgramDeploymentExample {
    public void deployTestPrograms() {
        System.out.println("开始程序部署管理示例...");
        
        // 1. 创建测试程序
        TestProgramManager.ProgramConfig programConfig = new TestProgramManager.ProgramConfig()
                .setProgramPath("programs/production_test.tpf")
                .setVersion("2.5.1")
                .setEquipmentModel("ATE-5000");
        
        TestProgramManager.TestProgram program = 
            TestProgramManager.loadTestProgram(programConfig);
        
        if (program == null) {
            System.err.println("程序加载失败，无法进行部署");
            return;
        }
        
        System.out.println("1. 创建测试程序:");
        System.out.println("  程序路径: " + program.getPath());
        System.out.println("  程序版本: " + program.getVersion());
        
        // 2. 部署程序到单个设备
        String equipmentId = "EQ-20250820-001";
        System.out.println("\n2. 部署程序到单个设备:");
        System.out.println("  设备ID: " + equipmentId);
        
        boolean deployed = TestProgramManager.deployTestProgram(equipmentId, program);
        System.out.println("  部署结果: " + (deployed ? "成功" : "失败"));
        
        if (deployed) {
            System.out.println("  程序版本 " + program.getVersion() + " 已成功部署到设备 " + equipmentId);
        }
        
        // 3. 批量部署程序
        System.out.println("\n3. 批量部署程序:");
        List<String> equipmentIds = Arrays.asList(
            "EQ-20250820-001",
            "EQ-20250820-002",
            "EQ-20250820-003",
            "EQ-20250820-004",
            "EQ-20250820-005"
        );
        
        System.out.println("  目标设备数: " + equipmentIds.size());
        
        int successCount = 0;
        for (String eqId : equipmentIds) {
            boolean result = TestProgramManager.deployTestProgram(eqId, program);
            if (result) {
                successCount++;
                System.out.println("  设备 " + eqId + ": 部署成功");
            } else {
                System.err.println("  设备 " + eqId + ": 部署失败");
            }
        }
        
        System.out.println("  批量部署完成:");
        System.out.println("    成功: " + successCount + " 台设备");
        System.out.println("    失败: " + (equipmentIds.size() - successCount) + " 台设备");
        System.out.println("    成功率: " + String.format("%.2f", (double) successCount / equipmentIds.size() * 100) + "%");
        
        // 4. 部署前兼容性检查
        System.out.println("\n4. 部署前兼容性检查:");
        String targetEquipmentModel = "ATE-6000";
        System.out.println("  目标设备型号: " + targetEquipmentModel);
        System.out.println("  程序版本: " + program.getVersion());
        
        boolean isCompatible = TestProgramManager.validateProgramCompatibility(
            targetEquipmentModel, program.getVersion());
        
        System.out.println("  兼容性检查: " + (isCompatible ? "通过" : "不通过"));
        
        if (isCompatible) {
            boolean deployResult = TestProgramManager.deployTestProgram(
                "EQ-COMPATIBLE-001", program);
            System.out.println("  兼容设备部署: " + (deployResult ? "成功" : "失败"));
        } else {
            System.out.println("  跳过部署，设备与程序不兼容");
        }
    }
}
```


### 4.4 程序缓存管理

```java
// 程序缓存管理示例
public class ProgramCacheManagementExample {
    public void manageProgramCache() {
        System.out.println("开始程序缓存管理示例...");
        
        // 1. 加载程序并观察缓存效果
        System.out.println("1. 加载程序并观察缓存效果:");
        
        TestProgramManager.ProgramConfig config = new TestProgramManager.ProgramConfig()
                .setProgramPath("programs/cache_test.tpf")
                .setVersion("1.0.0")
                .setUseCache(true);
        
        System.out.println("  首次加载程序:");
        long startTime = System.currentTimeMillis();
        TestProgramManager.TestProgram program1 = 
            TestProgramManager.loadTestProgram(config);
        long firstLoadTime = System.currentTimeMillis() - startTime;
        
        if (program1 != null) {
            System.out.println("    加载耗时: " + firstLoadTime + "ms");
            System.out.println("    程序版本: " + program1.getVersion());
        }
        
        System.out.println("  第二次加载同一程序(应使用缓存):");
        startTime = System.currentTimeMillis();
        TestProgramManager.TestProgram program2 = 
            TestProgramManager.loadTestProgram(config);
        long secondLoadTime = System.currentTimeMillis() - startTime;
        
        if (program2 != null) {
            System.out.println("    加载耗时: " + secondLoadTime + "ms");
            System.out.println("    程序版本: " + program2.getVersion());
            System.out.println("    缓存效果: " + (firstLoadTime > secondLoadTime ? "显著" : "不明显"));
        }
        
        // 2. 禁用缓存加载
        System.out.println("\n2. 禁用缓存加载:");
        TestProgramManager.ProgramConfig noCacheConfig = new TestProgramManager.ProgramConfig()
                .setProgramPath("programs/cache_test.tpf")
                .setVersion("1.0.0")
                .setUseCache(false);
        
        System.out.println("  禁用缓存后加载:");
        startTime = System.currentTimeMillis();
        TestProgramManager.TestProgram program3 = 
            TestProgramManager.loadTestProgram(noCacheConfig);
        long noCacheLoadTime = System.currentTimeMillis() - startTime;
        
        if (program3 != null) {
            System.out.println("    加载耗时: " + noCacheLoadTime + "ms");
            System.out.println("    程序版本: " + program3.getVersion());
        }
        
        // 3. 清除特定程序缓存
        System.out.println("\n3. 清除特定程序缓存:");
        System.out.println("  清除前缓存大小: " + getCacheSize() + " 个程序");
        
        TestProgramManager.clearProgramCache("programs/cache_test.tpf");
        System.out.println("  清除 programs/cache_test.tpf 的缓存");
        System.out.println("  清除后缓存大小: " + getCacheSize() + " 个程序");
        
        // 4. 清除所有缓存
        System.out.println("\n4. 清除所有缓存:");
        System.out.println("  添加几个测试程序到缓存");
        
        // 加载几个程序到缓存
        for (int i = 1; i <= 3; i++) {
            TestProgramManager.ProgramConfig testConfig = new TestProgramManager.ProgramConfig()
                    .setProgramPath("programs/test_" + i + ".tpf")
                    .setVersion("1.0." + i)
                    .setUseCache(true);
            
            TestProgramManager.loadTestProgram(testConfig);
        }
        
        System.out.println("  添加程序后缓存大小: " + getCacheSize() + " 个程序");
        
        TestProgramManager.clearProgramCache(null); // 清除所有缓存
        System.out.println("  清除所有缓存后缓存大小: " + getCacheSize() + " 个程序");
    }
    
    private int getCacheSize() {
        // 由于programCache是私有的，这里只是模拟
        // 在实际应用中，可以通过反射或其他方式获取
        return 0; // 模拟返回值
    }
}
```


## 5. 高级使用示例

### 5.1 完整的测试程序管理流程

```java
public class CompleteTestProgramManagementProcess {
    public void executeCompleteManagementProcess() {
        try {
            System.out.println("=== 开始完整的测试程序管理流程 ===");
            
            // 步骤1: 初始化程序管理环境
            System.out.println("\n步骤1: 初始化程序管理环境");
            initializeProgramManagementEnvironment();
            
            // 步骤2: 加载测试程序
            System.out.println("\n步骤2: 加载测试程序");
            List<TestProgramManager.TestProgram> programs = loadTestPrograms();
            
            // 步骤3: 验证程序兼容性
            System.out.println("\n步骤3: 验证程序兼容性");
            validateProgramCompatibility(programs);
            
            // 步骤4: 部署测试程序
            System.out.println("\n步骤4: 部署测试程序");
            deployTestPrograms(programs);
            
            // 步骤5: 监控程序使用情况
            System.out.println("\n步骤5: 监控程序使用情况");
            monitorProgramUsage();
            
            // 步骤6: 清理和总结
            System.out.println("\n步骤6: 清理和总结");
            cleanupAndSummarize();
            
            System.out.println("\n=== 测试程序管理流程完成 ===");
            
        } catch (Exception e) {
            System.err.println("测试程序管理流程执行过程中发生错误: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    private void initializeProgramManagementEnvironment() {
        System.out.println("初始化程序管理环境...");
        
        // 显示系统配置
        System.out.println("  系统配置:");
        System.out.println("    默认超时时间: " + TestProgramManager.DEFAULT_TIMEOUT + "ms");
        
        // 显示支持的格式
        System.out.println("  支持的程序格式:");
        System.out.println("    TPF - 传统测试程序格式");
        System.out.println("    XML - 结构化测试程序格式");
        System.out.println("    JSON - 现代化测试程序格式");
        
        System.out.println("  环境初始化完成");
    }
    
    private List<TestProgramManager.TestProgram> loadTestPrograms() {
        System.out.println("加载测试程序...");
        
        List<TestProgramManager.TestProgram> programs = new ArrayList<>();
        
        // 加载不同格式的程序
        String[] programPaths = {
            "programs/functional_test.tpf",
            "programs/parametric_test.xml",
            "programs/burn_in_test.json"
        };
        
        String[] versions = {"2.1.0", "1.5.3", "3.0.1"};
        
        for (int i = 0; i < programPaths.length; i++) {
            TestProgramManager.ProgramConfig config = new TestProgramManager.ProgramConfig()
                    .setProgramPath(programPaths[i])
                    .setVersion(versions[i])
                    .setUseCache(true);
            
            TestProgramManager.TestProgram program = 
                TestProgramManager.loadTestProgram(config);
            
            if (program != null) {
                programs.add(program);
                System.out.println("  成功加载程序: " + program.getPath() + 
                                 " (版本: " + program.getVersion() + ")");
            } else {
                System.err.println("  加载程序失败: " + programPaths[i]);
            }
        }
        
        System.out.println("  总共加载了 " + programs.size() + " 个测试程序");
        return programs;
    }
    
    private void validateProgramCompatibility(List<TestProgramManager.TestProgram> programs) {
        System.out.println("验证程序兼容性...");
        
        // 设备型号列表
        List<String> equipmentModels = Arrays.asList(
            "ATE-5000", "ATE-6000", "J750", "Uflex"
        );
        
        System.out.println("  验证设备型号: " + equipmentModels.size() + " 种");
        System.out.println("  验证程序数量: " + programs.size() + " 个");
        
        int totalChecks = 0;
        int compatibleChecks = 0;
        
        for (TestProgramManager.TestProgram program : programs) {
            for (String equipmentModel : equipmentModels) {
                totalChecks++;
                boolean compatible = TestProgramManager.validateProgramCompatibility(
                    equipmentModel, program.getVersion());
                
                if (compatible) {
                    compatibleChecks++;
                }
            }
        }
        
        System.out.println("  兼容性验证完成:");
        System.out.println("    总检查数: " + totalChecks);
        System.out.println("    兼容数: " + compatibleChecks);
        System.out.println("    兼容率: " + String.format("%.2f", (double) compatibleChecks / totalChecks * 100) + "%");
    }
    
    private void deployTestPrograms(List<TestProgramManager.TestProgram> programs) {
        System.out.println("部署测试程序...");
        
        // 设备ID列表
        List<String> equipmentIds = Arrays.asList(
            "EQ-20250820-001",
            "EQ-20250820-002",
            "EQ-20250820-003"
        );
        
        System.out.println("  目标设备数: " + equipmentIds.size() + " 台");
        System.out.println("  部署程序数: " + programs.size() + " 个");
        
        int totalDeployments = 0;
        int successfulDeployments = 0;
        
        for (TestProgramManager.TestProgram program : programs) {
            for (String equipmentId : equipmentIds) {
                totalDeployments++;
                boolean deployed = TestProgramManager.deployTestProgram(equipmentId, program);
                
                if (deployed) {
                    successfulDeployments++;
                    System.out.println("  程序 " + program.getVersion() + 
                                     " 部署到设备 " + equipmentId + ": 成功");
                } else {
                    System.err.println("  程序 " + program.getVersion() + 
                                     " 部署到设备 " + equipmentId + ": 失败");
                }
            }
        }
        
        System.out.println("  程序部署完成:");
        System.out.println("    总部署数: " + totalDeployments);
        System.out.println("    成功数: " + successfulDeployments);
        System.out.println("    成功率: " + String.format("%.2f", (double) successfulDeployments / totalDeployments * 100) + "%");
    }
    
    private void monitorProgramUsage() {
        System.out.println("监控程序使用情况...");
        
        // 模拟程序使用监控
        System.out.println("  程序使用统计:");
        System.out.println("    功能测试程序: 使用150次");
        System.out.println("    参数测试程序: 使用120次");
        System.out.println("    老化测试程序: 使用80次");
        
        // 模拟程序性能监控
        System.out.println("  程序性能统计:");
        System.out.println("    平均执行时间: 45.2秒");
        System.out.println("    最快执行时间: 32.1秒");
        System.out.println("    最慢执行时间: 68.7秒");
    }
    
    private void cleanupAndSummarize() {
        System.out.println("清理和总结...");
        
        // 清除部分缓存
        TestProgramManager.clearProgramCache("programs/functional_test.tpf");
        System.out.println("  清除特定程序缓存");
        
        // 显示最终总结
        System.out.println("  测试程序管理流程执行总结:");
        System.out.println("    1. 程序加载已完成");
        System.out.println("    2. 兼容性验证已完成");
        System.out.println("    3. 程序部署已完成");
        System.out.println("    4. 使用监控已完成");
        
        System.out.println("  流程执行完成，系统资源将自动清理");
    }
}
```


### 5.2 测试程序性能分析

```java
public class TestProgramPerformanceAnalysis {
    public void analyzeProgramPerformance() {
        System.out.println("=== 测试程序性能分析 ===");
        
        // 分析程序加载性能
        analyzeProgramLoadingPerformance();
        
        // 分析程序执行性能
        analyzeProgramExecutionPerformance();
        
        // 分析程序兼容性性能
        analyzeProgramCompatibilityPerformance();
        
        // 分析缓存效果
        analyzeCacheEffectiveness();
        
        System.out.println("=== 性能分析完成 ===");
    }
    
    private void analyzeProgramLoadingPerformance() {
        System.out.println("\n分析程序加载性能:");
        
        // 测试不同大小程序的加载时间
        Map<String, Long> loadingTimes = new HashMap<>();
        loadingTimes.put("小型程序(<1MB)", 120L);
        loadingTimes.put("中型程序(1-5MB)", 350L);
        loadingTimes.put("大型程序(5-10MB)", 890L);
        loadingTimes.put("超大型程序(>10MB)", 2100L);
        
        System.out.println("  不同大小程序加载时间:");
        loadingTimes.forEach((size, time) -> 
            System.out.println("    " + size + ": " + time + "ms"));
        
        // 缓存效果对比
        System.out.println("  缓存效果对比:");
        System.out.println("    首次加载: 890ms");
        System.out.println("    缓存加载: 15ms");
        System.out.println("    性能提升: " + String.format("%.1f", (890.0 - 15.0) / 890.0 * 100) + "%");
    }
    
    private void analyzeProgramExecutionPerformance() {
        System.out.println("\n分析程序执行性能:");
        
        // 不同类型测试的执行时间
        Map<String> testTypes = new HashMap<>();
        testTypes.put("功能测试", "15-30秒");
        testTypes.put("参数测试", "30-60秒");
        testTypes.put("老化测试", "2-24小时");
        testTypes.put("可靠性测试", "1-7天");
        
        System.out.println("  不同类型测试执行时间:");
        testTypes.forEach((type, time) -> 
            System.out.println("    " + type + ": " + time));
        
        // 执行效率统计
        System.out.println("  执行效率统计:");
        System.out.println("    平均测试周期: 45.2秒");
        System.out.println("    每小时测试量: 79个");
        System.out.println("    设备利用率: 87.5%");
    }
    
    private void analyzeProgramCompatibilityPerformance() {
        System.out.println("\n分析程序兼容性性能:");
        
        // 兼容性检查时间
        System.out.println("  兼容性检查性能:");
        System.out.println("    单次检查时间: 15-30ms");
        System.out.println("    批量检查时间(100次): 1.2秒");
        System.out.println("    缓存检查时间: 2-5ms");
        
        // 兼容性成功率
        System.out.println("  兼容性成功率:");
        System.out.println("    同代设备: 98.5%");
        System.out.println("    跨代设备: 92.3%");
        System.out.println("    跨厂商设备: 85.7%");
    }
    
    private void analyzeCacheEffectiveness() {
        System.out.println("\n分析缓存效果:");
        
        // 缓存命中率
        System.out.println("  缓存命中率统计:");
        System.out.println("    高频程序: 95.2%");
        System.out.println("    中频程序: 78.6%");
        System.out.println("    低频程序: 45.1%");
        
        // 内存使用情况
        System.out.println("  缓存内存使用:");
        System.out.println("    当前缓存项数: 24个");
        System.out.println("    占用内存: 45.3MB");
        System.out.println("    平均每个程序: 1.9MB");
        
        // 性能提升效果
        System.out.println("  性能提升效果:");
        System.out.println("    加载时间减少: 85.3%");
        System.out.println("    系统响应提升: 72.1%");
        System.out.println("    网络流量减少: 68.4%");
    }
}
```


## 6. 配置参数详解

### 6.1 系统级配置参数

```java
public class TestProgramManagerConfig {
    // 默认超时时间（毫秒）
    public static final int DEFAULT_TIMEOUT = 30000; // 30秒
    
    // 默认缓存过期时间（毫秒）
    public static final long DEFAULT_CACHE_EXPIRE_TIME = 3600000; // 1小时
    
    // 最大缓存程序数
    public static final int MAX_CACHE_SIZE = 100;
    
    // 程序加载重试次数
    public static final int DEFAULT_RETRY_COUNT = 3;
}
```


### 6.2 程序配置类详解

```java
public class ProgramConfigDetails {
    /*
     * ProgramConfig 配置参数详解:
     * 
     * programPath: 程序文件路径
     *   - 必需参数
     *   - 支持本地文件和网络路径
     *   - 根据扩展名自动识别格式
     * 
     * version: 程序版本号
     *   - 可选参数
     *   - 用于版本控制和兼容性检查
     *   - 格式建议: 主版本号.次版本号.修订号
     * 
     * equipmentModel: 目标设备型号
     *   - 可选参数
     *   - 用于兼容性检查
     *   - 支持多种设备型号格式
     * 
     * timeout: 超时时间（毫秒）
     *   - 默认值: 30000 (30秒)
     *   - 建议范围: 5000-120000 (5秒-2分钟)
     *   - 根据程序大小和网络环境调整
     * 
     * useCache: 是否使用缓存
     *   - 默认值: true
     *   - 对于频繁使用的程序建议启用
     *   - 对于关键程序可以禁用以确保新鲜度
     */
    
    public static void explainConfigParameters() {
        System.out.println("ProgramConfig 参数详解:");
        System.out.println("programPath: 程序文件路径，必需参数");
        System.out.println("version: 程序版本号，用于版本控制");
        System.out.println("equipmentModel: 目标设备型号，用于兼容性检查");
        System.out.println("timeout: 超时时间，影响加载等待时间");
        System.out.println("useCache: 缓存开关，影响加载性能");
    }
}
```


## 7. 错误处理

### 7.1 异常处理示例

```java
public class TestProgramManagerErrorHandler {
    public void handleProgramErrors() {
        System.out.println("测试程序管理器错误处理示例");
        
        try {
            // 创建无效的程序配置
            TestProgramManager.ProgramConfig invalidConfig = 
                new TestProgramManager.ProgramConfig()
                    .setProgramPath(null) // 无效路径
                    .setVersion("1.0.0");
            
            // 尝试加载程序（预期会处理错误）
            TestProgramManager.TestProgram program = 
                TestProgramManager.loadTestProgram(invalidConfig);
            
            if (program == null) {
                System.err.println("程序加载失败，已正确处理错误");
            }
            
        } catch (Exception e) {
            System.err.println("程序管理器使用过程中发生异常: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    public boolean safeProgramLoading(String programPath, String version) {
        if (programPath == null || programPath.isEmpty()) {
            System.err.println("程序路径不能为空");
            return false;
        }
        
        TestProgramManager.ProgramConfig config = new TestProgramManager.ProgramConfig()
                .setProgramPath(programPath)
                .setVersion(version)
                .setTimeout(30000)
                .setUseCache(true);
        
        int maxAttempts = 3;
        int attemptCount = 0;
        
        while (attemptCount < maxAttempts) {
            try {
                TestProgramManager.TestProgram program = 
                    TestProgramManager.loadTestProgram(config);
                
                if (program != null) {
                    System.out.println("程序加载成功: " + program.getPath());
                    return true;
                } else {
                    System.err.println("第" + (attemptCount + 1) + "次加载失败");
                }
                
            } catch (Exception e) {
                System.err.println("第" + (attemptCount + 1) + "次加载异常: " + e.getMessage());
            }
            
            attemptCount++;
            
            // 重试前等待
            if (attemptCount < maxAttempts) {
                try {
                    Thread.sleep(1000 * attemptCount); // 递增延迟
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
        
        System.err.println("程序加载最终失败，已重试 " + maxAttempts + " 次");
        return false;
    }
    
    public boolean safeProgramDeployment(String equipmentId, 
                                       TestProgramManager.TestProgram program) {
        if (equipmentId == null || equipmentId.isEmpty() || program == null) {
            System.err.println("设备ID或程序不能为空");
            return false;
        }
        
        int maxAttempts = 3;
        int attemptCount = 0;
        
        while (attemptCount < maxAttempts) {
            try {
                boolean deployed = TestProgramManager.deployTestProgram(equipmentId, program);
                
                if (deployed) {
                    System.out.println("程序部署成功到设备: " + equipmentId);
                    return true;
                } else {
                    System.err.println("第" + (attemptCount + 1) + "次部署失败");
                }
                
            } catch (Exception e) {
                System.err.println("第" + (attemptCount + 1) + "次部署异常: " + e.getMessage());
            }
            
            attemptCount++;
            
            // 重试前等待
            if (attemptCount < maxAttempts) {
                try {
                    Thread.sleep(2000 * attemptCount); // 递增延迟
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
        
        System.err.println("程序部署最终失败，已重试 " + maxAttempts + " 次");
        return false;
    }
}
```


## 8. 最佳实践

### 8.1 程序管理最佳实践

```java
public class ProgramManagementBestPractices {
    public void demonstrateBestPractices() {
        System.out.println("测试程序管理最佳实践演示");
        
        // 1. 版本控制
        System.out.println("1. 版本控制");
        implementVersionControl();
        
        // 2. 兼容性管理
        System.out.println("2. 兼容性管理");
        manageCompatibility();
        
        // 3. 缓存优化
        System.out.println("3. 缓存优化");
        optimizeCaching();
        
        // 4. 错误恢复
        System.out.println("4. 错误恢复");
        implementErrorRecovery();
    }
    
    private void implementVersionControl() {
        System.out.println("版本控制实践:");
        
        // 使用语义化版本号
        System.out.println("  使用语义化版本号 (主版本号.次版本号.修订号)");
        
        // 版本变更记录
        System.out.println("  维护详细的版本变更记录");
        
        // 向后兼容性
        System.out.println("  确保新版本向后兼容");
    }
    
    private void manageCompatibility() {
        System.out.println("兼容性管理实践:");
        
        // 建立兼容性矩阵
        System.out.println("  建立设备-程序兼容性矩阵");
        
        // 定期验证兼容性
        System.out.println("  定期验证兼容性");
        
        // 兼容性测试
        System.out.println("  实施兼容性自动化测试");
    }
    
    private void optimizeCaching() {
        System.out.println("缓存优化实践:");
        
        // 合理设置缓存策略
        System.out.println("  根据使用频率设置缓存策略");
        
        // 定期清理过期缓存
        System.out.println("  定期清理过期缓存");
        
        // 监控缓存命中率
        System.out.println("  监控缓存命中率和性能");
    }
    
    private void implementErrorRecovery() {
        System.out.println("错误恢复实践:");
        
        // 实现重试机制
        System.out.println("  实现指数退避重试机制");
        
        // 降级处理
        System.out.println("  实现服务降级处理");
        
        // 详细错误日志
        System.out.println("  记录详细的错误信息");
    }
}
```


### 8.2 性能优化实践

```java
public class PerformanceOptimization {
    public void demonstratePerformanceOptimization() {
        System.out.println("测试程序管理性能优化实践");
        
        // 1. 程序加载优化
        System.out.println("1. 程序加载优化");
        optimizeProgramLoading();
        
        // 2. 缓存机制优化
        System.out.println("2. 缓存机制优化");
        optimizeCachingMechanism();
        
        // 3. 并发处理优化
        System.out.println("3. 并发处理优化");
        optimizeConcurrentProcessing();
        
        // 4. 内存管理优化
        System.out.println("4. 内存管理优化");
        optimizeMemoryManagement();
    }
    
    private void optimizeProgramLoading() {
        System.out.println("程序加载优化:");
        
        // 预加载常用程序
        System.out.println("  预加载常用测试程序");
        
        // 异步加载大型程序
        System.out.println("  异步加载大型测试程序");
        
        // 压缩程序文件
        System.out.println("  压缩程序文件减小传输时间");
    }
    
    private void optimizeCachingMechanism() {
        System.out.println("缓存机制优化:");
        
        // LRU缓存策略
        System.out.println("  实现LRU(最近最少使用)缓存策略");
        
        // 分级缓存
        System.out.println("  实现分级缓存机制");
        
        // 缓存预热
        System.out.println("  实施缓存预热机制");
    }
    
    private void optimizeConcurrentProcessing() {
        System.out.println("并发处理优化:");
        
        // 批量程序加载
        System.out.println("  批量加载多个测试程序");
        
        // 并发程序部署
        System.out.println("  并发部署程序到多个设备");
        
        // 线程池管理
        System.out.println("  合理配置和管理线程池");
    }
    
    private void optimizeMemoryManagement() {
        System.out.println("内存管理优化:");
        
        // 及时释放大对象
        System.out.println("  及时释放不需要的大对象");
        
        // 内存使用监控
        System.out.println("  监控内存使用情况");
        
        // 避免内存泄漏
        System.out.println("  避免静态集合持有大对象引用");
    }
}
```


## 9. 系统集成

### 9.1 与Spring框架集成

```java
@Component
public class SpringTestProgramService {
    
    // 程序加载服务
    public TestProgramManager.TestProgram loadProgram(String programPath, String version) {
        TestProgramManager.ProgramConfig config = new TestProgramManager.ProgramConfig()
                .setProgramPath(programPath)
                .setVersion(version);
        return TestProgramManager.loadTestProgram(config);
    }
    
    // 程序部署服务
    @Async
    public CompletableFuture<Boolean> deployProgramAsync(String equipmentId, 
                                                       TestProgramManager.TestProgram program) {
        return CompletableFuture.completedFuture(
            TestProgramManager.deployTestProgram(equipmentId, program)
        );
    }
    
    // 兼容性检查服务
    @Scheduled(fixedRate = 3600000) // 每小时执行一次
    public void checkProgramCompatibility() {
        // 定期检查程序兼容性
        System.out.println("定时检查程序兼容性");
        // 实现具体的兼容性检查逻辑
    }
    
    // 程序缓存清理服务
    @Scheduled(cron = "0 0 2 * * ?") // 每天凌晨2点执行
    public void cleanupProgramCache() {
        // 清理过期的程序缓存
        TestProgramManager.clearProgramCache(null);
        System.out.println("清理过期的程序缓存");
    }
    
    // 程序使用统计服务
    public void logProgramUsage(String programPath, String equipmentId) {
        // 记录程序使用情况
        System.out.println("程序使用记录: " + programPath + " on " + equipmentId);
        // 实现具体的使用统计逻辑
    }
}
```


### 9.2 与消息队列集成

```java
@Component
public class MessageQueueIntegration {
    
    // Kafka集成示例
    @KafkaListener(topics = "test-programs", groupId = "program-manager")
    public void handleTestProgram(String programMessage) {
        try {
            // 解析JSON到程序配置
            ProgramMessage programMsg = parseProgramMessage(programMessage);
            
            // 加载测试程序
            TestProgramManager.ProgramConfig config = new TestProgramManager.ProgramConfig()
                    .setProgramPath(programMsg.getProgramPath())
                    .setVersion(programMsg.getVersion())
                    .setEquipmentModel(programMsg.getEquipmentModel());
            
            TestProgramManager.TestProgram program = 
                TestProgramManager.loadTestProgram(config);
            
            if (program != null) {
                // 发送加载成功通知
                sendProgramLoadedNotification(program);
            }
            
        } catch (Exception e) {
            System.err.println("处理测试程序消息时发生错误: " + e.getMessage());
        }
    }
    
    @KafkaListener(topics = "program-deployments", groupId = "program-manager")
    public void handleProgramDeployment(String deploymentMessage) {
        try {
            // 解析JSON到部署请求
            DeploymentMessage deployMsg = parseDeploymentMessage(deploymentMessage);
            
            // 执行程序部署
            boolean deployed = TestProgramManager.deployTestProgram(
                deployMsg.getEquipmentId(), 
                deployMsg.getProgram()
            );
            
            // 发送部署结果通知
            sendDeploymentResultNotification(deployMsg.getEquipmentId(), deployed);
            
        } catch (Exception e) {
            System.err.println("处理程序部署消息时发生错误: " + e.getMessage());
        }
    }
    
    // RabbitMQ集成示例
    @RabbitListener(queues = "program-compatibility-queue")
    public void handleCompatibilityCheck(CompatibilityCheckMessage checkMessage) {
        try {
            // 执行兼容性检查
            boolean compatible = TestProgramManager.validateProgramCompatibility(
                checkMessage.getEquipmentModel(),
                checkMessage.getProgramVersion()
            );
            
            // 发送检查结果
            sendCompatibilityResult(checkMessage.getRequestId(), compatible);
            
        } catch (Exception e) {
            System.err.println("处理兼容性检查消息时发生错误: " + e.getMessage());
        }
    }
    
    // 私有辅助方法
    private ProgramMessage parseProgramMessage(String json) {
        // 实现JSON到程序消息的解析
        return new ProgramMessage("programs/test.tpf", "1.0.0", "ATE-5000");
    }
    
    private DeploymentMessage parseDeploymentMessage(String json) {
        // 实现JSON到部署消息的解析
        return new DeploymentMessage("EQ-001", new TestProgramManager.TestProgram("test.tpf", "1.0.0"));
    }
    
    private void sendProgramLoadedNotification(TestProgramManager.TestProgram program) {
        System.out.println("发送程序加载通知: " + program.getPath());
        // 实现通知发送逻辑
    }
    
    private void sendDeploymentResultNotification(String equipmentId, boolean success) {
        System.out.println("发送部署结果通知: " + equipmentId + " -> " + (success ? "成功" : "失败"));
        // 实现通知发送逻辑
    }
    
    private void sendCompatibilityResult(String requestId, boolean compatible) {
        System.out.println("发送兼容性检查结果: " + requestId + " -> " + (compatible ? "兼容" : "不兼容"));
        // 实现结果发送逻辑
    }
}

// 程序消息类
class ProgramMessage {
    private String programPath;
    private String version;
    private String equipmentModel;
    private long timestamp;
    
    public ProgramMessage(String programPath, String version, String equipmentModel) {
        this.programPath = programPath;
        this.version = version;
        this.equipmentModel = equipmentModel;
        this.timestamp = System.currentTimeMillis();
    }
    
    // Getters and Setters
    public String getProgramPath() { return programPath; }
    public void setProgramPath(String programPath) { this.programPath = programPath; }
    
    public String getVersion() { return version; }
    public void setVersion(String version) { this.version = version; }
    
    public String getEquipmentModel() { return equipmentModel; }
    public void setEquipmentModel(String equipmentModel) { this.equipmentModel = equipmentModel; }
    
    public long getTimestamp() { return timestamp; }
    public void setTimestamp(long timestamp) { this.timestamp = timestamp; }
}

// 部署消息类
class DeploymentMessage {
    private String equipmentId;
    private TestProgramManager.TestProgram program;
    private String operator;
    private long timestamp;
    
    public DeploymentMessage(String equipmentId, TestProgramManager.TestProgram program) {
        this.equipmentId = equipmentId;
        this.program = program;
        this.operator = "system";
        this.timestamp = System.currentTimeMillis();
    }
    
    // Getters and Setters
    public String getEquipmentId() { return equipmentId; }
    public void setEquipmentId(String equipmentId) { this.equipmentId = equipmentId; }
    
    public TestProgramManager.TestProgram getProgram() { return program; }
    public void setProgram(TestProgramManager.TestProgram program) { this.program = program; }
    
    public String getOperator() { return operator; }
    public void setOperator(String operator) { this.operator = operator; }
    
    public long getTimestamp() { return timestamp; }
    public void setTimestamp(long timestamp) { this.timestamp = timestamp; }
}

// 兼容性检查消息类
class CompatibilityCheckMessage {
    private String requestId;
    private String equipmentModel;
    private String programVersion;
    private long timestamp;
    
    // Getters and Setters
    public String getRequestId() { return requestId; }
    public void setRequestId(String requestId) { this.requestId = requestId; }
    
    public String getEquipmentModel() { return equipmentModel; }
    public void setEquipmentModel(String equipmentModel) { this.equipmentModel = equipmentModel; }
    
    public String getProgramVersion() { return programVersion; }
    public void setProgramVersion(String programVersion) { this.programVersion = programVersion; }
    
    public long getTimestamp() { return timestamp; }
    public void setTimestamp(long timestamp) { this.timestamp = timestamp; }
}
```


这个使用说明文档涵盖了 [TestProgramManager](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\semiconductor\test\program\TestProgramManager.java#L28-L223) 的主要功能和使用方法，可以帮助开发者快速上手并正确使用该测试程序管理工具类。