# SpcTool 使用说明文档

## 1. 概述

[SpcTool](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\semiconductor\quality\spc\SpcTool.java#L11-L23) 是一个专业的统计过程控制（SPC）工具类，专门用于半导体封测行业的质量数据分析、控制图生成、过程能力分析和质量异常检测。该工具解决了质量数据统计分析复杂、质量异常检测不及时、质量趋势预测困难和质量改进措施不明确等问题。

## 2. 核心功能

### 2.1 SPC控制图生成
- 支持多种控制图类型（X̄-R图、X̄-S图、I-MR图等）
- 自动计算控制限和中心线
- 实时数据点状态评估

### 2.2 过程能力分析
- CPK、PPK等关键能力指数计算
- 规格限对比分析
- 过程能力评级

### 2.3 质量异常实时检测
- 多种SPC规则检查
- 实时异常预警
- 异常模式识别

### 2.4 质量趋势预测
- 历史数据分析
- 趋势预测和相关性分析
- 质量改进建议

## 3. 支持的控制图类型和数据类型

### 3.1 控制图类型
```java
public enum ChartType {
    X_BAR_R("均值-极差图", "X̄-R Chart"),           // 用于计量型数据的均值和极差控制
    X_BAR_S("均值-标准差图", "X̄-S Chart"),         // 用于计量型数据的均值和标准差控制
    INDIVIDUALS("单值图", "I-MR Chart"),           // 用于单值和移动极差控制
    P_CHART("不合格品率图", "P Chart"),            // 用于不合格品率控制
    NP_CHART("不合格品数图", "NP Chart"),          // 用于不合格品数控制
    C_CHART("缺陷数图", "C Chart"),               // 用于缺陷数控制
    U_CHART("单位缺陷数图", "U Chart"),            // 用于单位缺陷数控制
    EWMA("指数加权移动平均图", "EWMA Chart"),       // 用于检测小幅度过程偏移
    CUSUM("累积和控制图", "CUSUM Chart")           // 用于检测过程偏移的累积效应
}
```


### 3.2 数据类型
```java
public enum DataType {
    CONTINUOUS("连续型数据"),     // 如尺寸、重量等连续数值
    ATTRIBUTE("计数型数据"),      // 如合格/不合格等属性数据
    DEFECT("缺陷数据")           // 如缺陷数量等计数数据
}
```


## 4. 基本使用方法

### 4.1 创建测量数据

```java
// 创建单个测量数据点
SpcTool.Measurement measurement = new SpcTool.Measurement(
    95.5,                                   // 测量值
    LocalDateTime.now()                     // 时间戳
);

// 创建带批次信息的测量数据
SpcTool.Measurement batchMeasurement = new SpcTool.Measurement(
    "MEAS_001",                             // 数据点ID
    95.5,                                   // 测量值
    LocalDateTime.now(),                    // 时间戳
    "BATCH_20250821",                      // 批次ID
    "PRODUCT_X",                           // 产品ID
    true                                   // 数据有效性
);

// 添加自定义属性
batchMeasurement.setAttribute("operator", "张三");
batchMeasurement.setAttribute("machine", "MACHINE_01");
batchMeasurement.setAttribute("shift", "白班");

System.out.println("测量数据: " + batchMeasurement);
```


### 4.2 定义规格限

```java
// 定义规格限
SpcTool.SpecificationLimits specLimits = new SpcTool.SpecificationLimits(
    100.0,        // 上规格限 (USL)
    90.0,         // 下规格限 (LSL)
    95.0,         // 目标值
    "mm"          // 单位
);

System.out.println("规格限定义: " + specLimits);
System.out.println("是否有上规格限: " + specLimits.hasUpperLimit());
System.out.println("是否有下规格限: " + specLimits.hasLowerLimit());
System.out.println("是否有目标值: " + specLimits.hasTarget());
```


### 4.3 SPC控制图生成

```java
// 准备测量数据
List<SpcTool.Measurement> measurements = Arrays.asList(
    new SpcTool.Measurement(95.2, LocalDateTime.now().minusMinutes(10)),
    new SpcTool.Measurement(95.5, LocalDateTime.now().minusMinutes(8)),
    new SpcTool.Measurement(94.8, LocalDateTime.now().minusMinutes(6)),
    new SpcTool.Measurement(96.1, LocalDateTime.now().minusMinutes(4)),
    new SpcTool.Measurement(95.9, LocalDateTime.now().minusMinutes(2)),
    new SpcTool.Measurement(95.3, LocalDateTime.now())
);

// 生成X̄-R控制图
SpcTool.ControlChart controlChart = SpcTool.generateControlChart(
    measurements, 
    SpcTool.ChartType.X_BAR_R
);

if (controlChart != null) {
    System.out.println("控制图生成成功:");
    System.out.println("  图表类型: " + controlChart.getChartType().getChineseName());
    System.out.println("  数据点数: " + controlChart.getDataPoints().size());
    
    // 显示控制限
    SpcTool.ControlLimits limits = controlChart.getControlLimits();
    System.out.println("  中心线: " + limits.getCenterLine());
    System.out.println("  上控制限: " + limits.getUpperControlLimit());
    System.out.println("  下控制限: " + limits.getLowerControlLimit());
    System.out.println("  上警告限: " + limits.getUpperWarningLimit());
    System.out.println("  下警告限: " + limits.getLowerWarningLimit());
    
    // 显示数据点状态
    System.out.println("  数据点状态:");
    for (SpcTool.ChartDataPoint point : controlChart.getDataPoints()) {
        System.out.println("    " + point.getTimestamp().toLocalTime() + 
                          ": " + String.format("%.2f", point.getValue()) + 
                          " (" + point.getStatus().getDescription() + ")");
    }
}
```


### 4.4 CPK计算

```java
// 使用前面定义的测量数据和规格限计算CPK
SpcTool.ProcessCapability capability = SpcTool.calculateCPK(measurements, specLimits);

if (capability != null) {
    System.out.println("过程能力分析结果:");
    System.out.println("  Cp: " + String.format("%.2f", capability.getCp()));
    System.out.println("  Cpk: " + String.format("%.2f", capability.getCpk()));
    System.out.println("  Pp: " + String.format("%.2f", capability.getPp()));
    System.out.println("  Ppk: " + String.format("%.2f", capability.getPpk()));
    System.out.println("  均值: " + String.format("%.4f", capability.getMean()));
    System.out.println("  标准差: " + String.format("%.4f", capability.getStdDev()));
    System.out.println("  能力评级: " + capability.getRating().getDescription());
    System.out.println("  评级标准: " + capability.getRating().getCriteria());
}
```


### 4.5 质量异常实时检测

```java
// 创建实时数据流（模拟）
Stream<SpcTool.Measurement> dataStream = Stream.of(
    new SpcTool.Measurement(95.2, LocalDateTime.now().minusSeconds(30)),
    new SpcTool.Measurement(95.5, LocalDateTime.now().minusSeconds(25)),
    new SpcTool.Measurement(105.8, LocalDateTime.now().minusSeconds(20)), // 异常值
    new SpcTool.Measurement(96.1, LocalDateTime.now().minusSeconds(15)),
    new SpcTool.Measurement(95.9, LocalDateTime.now().minusSeconds(10)),
    new SpcTool.Measurement(85.3, LocalDateTime.now().minusSeconds(5))   // 异常值
);

// 检测实时异常
List<SpcTool.QualityAlert> alerts = SpcTool.detectRealTimeAnomalies(dataStream);

System.out.println("检测到 " + alerts.size() + " 个质量异常:");
for (SpcTool.QualityAlert alert : alerts) {
    System.out.println("  预警ID: " + alert.getAlertId());
    System.out.println("    产品: " + alert.getProductName());
    System.out.println("    级别: " + alert.getAlertLevel().getDescription());
    System.out.println("    消息: " + alert.getMessage());
    System.out.println("    时间: " + alert.getTimestamp());
    System.out.println("    违反规则: " + alert.getRuleViolated());
    System.out.println("    相关测量点数: " + alert.getRelatedMeasurements().size());
}
```


### 4.6 质量趋势预测

```java
// 准备历史数据
List<SpcTool.Measurement> historicalMeasurements = new ArrayList<>();
LocalDateTime baseTime = LocalDateTime.now().minusDays(30);
for (int i = 0; i < 100; i++) {
    double value = 95.0 + Math.sin(i * 0.1) * 2 + (Math.random() - 0.5) * 0.5;
    historicalMeasurements.add(new SpcTool.Measurement(
        value, 
        baseTime.plusHours(i)
    ));
}

// 创建历史数据对象
SpcTool.HistoricalData historicalData = new SpcTool.HistoricalData(
    historicalMeasurements,
    baseTime,
    baseTime.plusDays(30),
    "PRODUCT_X"
);

// 预测质量趋势
SpcTool.QualityTrend trend = SpcTool.predictQualityTrend(historicalData);

if (trend != null) {
    System.out.println("质量趋势预测结果:");
    System.out.println("  产品: " + trend.getProductName());
    System.out.println("  数据点数: " + trend.getHistoricalData().size());
    System.out.println("  趋势斜率: " + String.format("%.4f", trend.getTrendSlope()));
    System.out.println("  趋势方向: " + trend.getTrendDirection());
    System.out.println("  相关系数: " + String.format("%.2f", trend.getCorrelationCoefficient()));
    
    // 显示预测结果
    SpcTool.QualityTrend.TrendPrediction prediction = trend.getPrediction();
    System.out.println("  预测趋势: " + prediction.getPrediction());
    System.out.println("  预测值: " + String.format("%.2f", prediction.getPredictedValue()));
    System.out.println("  趋势率: " + String.format("%.4f", prediction.getTrendRate()));
    System.out.println("  方法论: " + prediction.getMethodology());
}
```


## 5. 高级使用示例

### 5.1 完整的SPC分析流程

```java
public class SpcAnalysisWorkflow {
    public void performCompleteSpcAnalysis() {
        try {
            System.out.println("=== 开始完整的SPC分析流程 ===");
            
            // 1. 准备数据
            List<SpcTool.Measurement> measurements = generateSampleData();
            SpcTool.SpecificationLimits specLimits = defineSpecificationLimits();
            
            // 2. 生成控制图
            System.out.println("步骤1: 生成控制图");
            SpcTool.ControlChart controlChart = SpcTool.generateControlChart(
                measurements, SpcTool.ChartType.X_BAR_R);
            
            if (controlChart != null) {
                displayControlChart(controlChart);
            }
            
            // 3. 计算过程能力
            System.out.println("\n步骤2: 计算过程能力");
            SpcTool.ProcessCapability capability = SpcTool.calculateCPK(measurements, specLimits);
            
            if (capability != null) {
                displayProcessCapability(capability);
            }
            
            // 4. 检测异常
            System.out.println("\n步骤3: 检测质量异常");
            Stream<SpcTool.Measurement> dataStream = measurements.stream();
            List<SpcTool.QualityAlert> alerts = SpcTool.detectRealTimeAnomalies(dataStream);
            
            if (!alerts.isEmpty()) {
                displayQualityAlerts(alerts);
            } else {
                System.out.println("  未检测到质量异常");
            }
            
            // 5. 趋势预测
            System.out.println("\n步骤4: 质量趋势预测");
            SpcTool.HistoricalData historicalData = new SpcTool.HistoricalData(
                measurements, 
                LocalDateTime.now().minusDays(7),
                LocalDateTime.now(),
                "PRODUCT_X"
            );
            
            SpcTool.QualityTrend trend = SpcTool.predictQualityTrend(historicalData);
            if (trend != null) {
                displayQualityTrend(trend);
            }
            
            System.out.println("\n=== SPC分析流程完成 ===");
            
        } catch (Exception e) {
            System.err.println("SPC分析过程中发生错误: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    private List<SpcTool.Measurement> generateSampleData() {
        List<SpcTool.Measurement> measurements = new ArrayList<>();
        LocalDateTime baseTime = LocalDateTime.now().minusHours(24);
        
        // 生成正态分布的样本数据
        Random random = new Random(42); // 固定种子确保可重复性
        for (int i = 0; i < 50; i++) {
            // 以95为中心，标准差为1的正态分布
            double value = 95.0 + random.nextGaussian() * 1.0;
            // 偶尔添加一些异常值
            if (i == 15 || i == 35) {
                value += (random.nextBoolean() ? 5 : -5);
            }
            
            measurements.add(new SpcTool.Measurement(
                value,
                baseTime.plusMinutes(i * 30)
            ));
        }
        
        return measurements;
    }
    
    private SpcTool.SpecificationLimits defineSpecificationLimits() {
        return new SpcTool.SpecificationLimits(
            98.0,  // USL
            92.0,  // LSL
            95.0,  // Target
            "mm"   // Unit
        );
    }
    
    private void displayControlChart(SpcTool.ControlChart chart) {
        System.out.println("  控制图类型: " + chart.getChartType().getChineseName());
        System.out.println("  数据点数: " + chart.getDataPoints().size());
        
        SpcTool.ControlLimits limits = chart.getControlLimits();
        System.out.println("  控制限:");
        System.out.println("    中心线: " + formatValue(limits.getCenterLine()));
        System.out.println("    上控制限: " + formatValue(limits.getUpperControlLimit()));
        System.out.println("    下控制限: " + formatValue(limits.getLowerControlLimit()));
        
        // 显示最后几个数据点
        List<SpcTool.ChartDataPoint> points = chart.getDataPoints();
        System.out.println("  最近5个数据点:");
        points.stream()
            .skip(Math.max(0, points.size() - 5))
            .forEach(point -> System.out.println("    " + 
                point.getTimestamp().toLocalTime() + ": " + 
                formatValue(point.getValue()) + " (" + 
                point.getStatus().getDescription() + ")"));
    }
    
    private void displayProcessCapability(SpcTool.ProcessCapability capability) {
        System.out.println("  过程能力指数:");
        System.out.println("    Cp: " + formatValue(capability.getCp()));
        System.out.println("    Cpk: " + formatValue(capability.getCpk()));
        System.out.println("    Pp: " + formatValue(capability.getPp()));
        System.out.println("    Ppk: " + formatValue(capability.getPpk()));
        System.out.println("  统计信息:");
        System.out.println("    均值: " + formatValue(capability.getMean()));
        System.out.println("    标准差: " + formatValue(capability.getStdDev()));
        System.out.println("  能力评级: " + capability.getRating().getDescription());
    }
    
    private void displayQualityAlerts(List<SpcTool.QualityAlert> alerts) {
        System.out.println("  检测到 " + alerts.size() + " 个质量异常:");
        for (SpcTool.QualityAlert alert : alerts) {
            System.out.println("    级别: " + alert.getAlertLevel().getDescription());
            System.out.println("    消息: " + alert.getMessage());
            System.out.println("    相关数据点: " + alert.getRelatedMeasurements().size());
        }
    }
    
    private void displayQualityTrend(SpcTool.QualityTrend trend) {
        System.out.println("  趋势分析:");
        System.out.println("    数据点数: " + trend.getHistoricalData().size());
        System.out.println("    趋势方向: " + trend.getTrendDirection());
        System.out.println("    相关系数: " + formatValue(trend.getCorrelationCoefficient()));
        
        SpcTool.QualityTrend.TrendPrediction prediction = trend.getPrediction();
        System.out.println("  趋势预测:");
        System.out.println("    预测类型: " + prediction.getPrediction());
        System.out.println("    预测值: " + formatValue(prediction.getPredictedValue()));
    }
    
    private String formatValue(Double value) {
        return value != null ? String.format("%.4f", value) : "N/A";
    }
}
```


### 5.2 自定义SPC规则检查器

```java
public class CustomSpcRuleChecker implements SpcTool.SpcRuleChecker {
    @Override
    public List<SpcTool.ControlRuleViolation> checkViolations(
            SpcTool.ControlChart chart, List<SpcTool.Measurement> data) {
        
        List<SpcTool.ControlRuleViolation> violations = new ArrayList<>();
        
        // 自定义规则: 检查连续10点在中心线同一侧
        checkRule4(chart, violations);
        
        // 自定义规则: 检查周期性模式
        checkRule5(chart, violations);
        
        return violations;
    }
    
    private void checkRule4(SpcTool.ControlChart chart, 
                           List<SpcTool.ControlRuleViolation> violations) {
        SpcTool.ControlLimits limits = chart.getControlLimits();
        Double centerLine = limits.getCenterLine();
        
        if (centerLine == null) return;
        
        List<SpcTool.ChartDataPoint> points = chart.getDataPoints();
        if (points.size() < 10) return;
        
        for (int i = 0; i <= points.size() - 10; i++) {
            List<SpcTool.ChartDataPoint> subPoints = points.subList(i, i + 10);
            boolean allAbove = subPoints.stream().allMatch(point -> point.getValue() > centerLine);
            boolean allBelow = subPoints.stream().allMatch(point -> point.getValue() < centerLine);
            
            if (allAbove || allBelow) {
                violations.add(new SpcTool.ControlRuleViolation(
                    4, 
                    "连续10点在中心线同一侧（自定义规则）", 
                    subPoints, 
                    SpcTool.QualityAlertLevel.WARNING
                ));
            }
        }
    }
    
    private void checkRule5(SpcTool.ControlChart chart, 
                           List<SpcTool.ControlRuleViolation> violations) {
        List<SpcTool.ChartDataPoint> points = chart.getDataPoints();
        if (points.size() < 12) return;
        
        // 简单的周期性检测（检查是否存在2周期模式）
        for (int i = 0; i <= points.size() - 12; i++) {
            boolean hasPattern = true;
            for (int j = 0; j < 6; j++) {
                double val1 = points.get(i + j * 2).getValue();
                double val2 = points.get(i + j * 2 + 1).getValue();
                
                // 检查相邻点是否有明显差异
                if (Math.abs(val1 - val2) < 0.5) {
                    hasPattern = false;
                    break;
                }
            }
            
            if (hasPattern) {
                List<SpcTool.ChartDataPoint> patternPoints = points.subList(i, i + 12);
                violations.add(new SpcTool.ControlRuleViolation(
                    5, 
                    "检测到周期性模式（自定义规则）", 
                    patternPoints, 
                    SpcTool.QualityAlertLevel.WARNING
                ));
            }
        }
    }
    
    @Override
    public boolean supportsChartType(SpcTool.ChartType chartType) {
        // 支持所有图表类型
        return true;
    }
    
    @Override
    public String getCheckerName() {
        return "CustomSpcRuleChecker";
    }
}

// 注册自定义规则检查器
// SpcTool.registerRuleChecker(new CustomSpcRuleChecker());
```


## 6. 配置参数详解

### 6.1 测量数据配置

```java
SpcTool.Measurement measurement = new SpcTool.Measurement(
    "MEAS_001",           // 数据点唯一ID
    95.5,                 // 测量值
    LocalDateTime.now(),  // 时间戳
    "BATCH_20250821",     // 批次ID
    "PRODUCT_X",          // 产品ID
    true                  // 数据有效性标记
);

// 添加自定义属性
measurement.setAttribute("operator", "张三");
measurement.setAttribute("machine", "MACHINE_01");
measurement.setAttribute("temperature", 25.0);
measurement.setAttribute("humidity", 60.0);
```


### 6.2 规格限配置

```java
SpcTool.SpecificationLimits specLimits = new SpcTool.SpecificationLimits(
    100.0,        // 上规格限 (USL) - 可为null表示无上限
    90.0,         // 下规格限 (LSL) - 可为null表示无下限
    95.0,         // 目标值 - 可为null表示无目标值
    "mm"          // 单位
);
```


### 6.3 控制图配置

```java
// 控制图通过generateControlChart方法自动生成
// 但可以手动配置控制限参数
SpcTool.ControlLimits customLimits = new SpcTool.ControlLimits();
customLimits.setCenterLine(95.0);
customLimits.setUpperControlLimit(98.0);
customLimits.setLowerControlLimit(92.0);
customLimits.setUpperWarningLimit(97.0);
customLimits.setLowerWarningLimit(93.0);
customLimits.setParameter("confidenceLevel", 0.9973); // 3σ水平
customLimits.setParameter("sampleSize", 5);
```


### 6.4 阈值配置

```java
// 在质量异常检测中使用阈值配置
// 目前主要通过SPC规则自动检测，但可以扩展自定义阈值检测
```


## 7. 错误处理

### 7.1 异常处理示例

```java
public class SpcErrorHandler {
    public void handleSpcAnalysis() {
        try {
            // 执行SPC分析
            List<SpcTool.Measurement> measurements = getMeasurements();
            SpcTool.SpecificationLimits limits = getSpecificationLimits();
            
            SpcTool.ProcessCapability capability = SpcTool.calculateCPK(measurements, limits);
            
            if (capability != null) {
                System.out.println("CPK计算成功: " + capability.getCpk());
            } else {
                System.out.println("CPK计算返回空值，可能数据不足或规格限未定义");
            }
            
        } catch (Exception e) {
            System.err.println("SPC分析异常: " + e.getMessage());
            
            // 根据异常类型进行不同处理
            if (e instanceof IllegalArgumentException) {
                System.err.println("输入参数错误，请检查数据格式");
            } else if (e instanceof ArithmeticException) {
                System.err.println("计算错误，可能标准差为零");
            } else {
                System.err.println("未知错误，请联系技术支持");
            }
            
            // 记录详细错误信息
            e.printStackTrace();
        }
    }
    
    private List<SpcTool.Measurement> getMeasurements() {
        // 模拟获取测量数据
        return Arrays.asList(
            new SpcTool.Measurement(95.0, LocalDateTime.now())
        );
    }
    
    private SpcTool.SpecificationLimits getSpecificationLimits() {
        // 模拟获取规格限
        return new SpcTool.SpecificationLimits(100.0, 90.0, 95.0, "mm");
    }
}
```


## 8. 最佳实践

### 8.1 数据质量管理

```java
public class DataQualityManager {
    public List<SpcTool.Measurement> validateAndCleanData(List<SpcTool.Measurement> rawData) {
        List<SpcTool.Measurement> cleanedData = new ArrayList<>();
        
        for (SpcTool.Measurement measurement : rawData) {
            // 1. 检查数据有效性
            if (!measurement.isValid()) {
                System.out.println("跳过无效数据点: " + measurement.getId());
                continue;
            }
            
            // 2. 检查数值合理性
            double value = measurement.getValue();
            if (Double.isNaN(value) || Double.isInfinite(value)) {
                System.out.println("跳过异常数值: " + measurement.getId());
                continue;
            }
            
            // 3. 检查时间戳合理性
            LocalDateTime timestamp = measurement.getTimestamp();
            if (timestamp.isAfter(LocalDateTime.now().plusMinutes(5))) {
                System.out.println("跳过未来时间戳数据: " + measurement.getId());
                continue;
            }
            
            // 4. 添加到清理后的数据集
            cleanedData.add(measurement);
        }
        
        System.out.println("数据清理完成: " + rawData.size() + " -> " + cleanedData.size());
        return cleanedData;
    }
    
    public boolean isDataSufficientForAnalysis(List<SpcTool.Measurement> data) {
        if (data == null || data.isEmpty()) {
            System.out.println("数据为空，不足以进行分析");
            return false;
        }
        
        // 检查数据量是否足够
        if (data.size() < 10) {
            System.out.println("数据量不足（少于10个点），建议收集更多数据");
            return false;
        }
        
        // 检查有效数据比例
        long validCount = data.stream().filter(SpcTool.Measurement::isValid).count();
        double validRatio = (double) validCount / data.size();
        if (validRatio < 0.8) {
            System.out.println("有效数据比例过低: " + String.format("%.1f%%", validRatio * 100));
            return false;
        }
        
        return true;
    }
}
```


### 8.2 性能优化

```java
public class SpcPerformanceOptimizer {
    private final Map<String, SpcTool.ProcessCapability> capabilityCache = new ConcurrentHashMap<>();
    private final Map<String, SpcTool.ControlChart> chartCache = new ConcurrentHashMap<>();
    private final long cacheTimeout = 60000; // 1分钟缓存
    
    public SpcTool.ProcessCapability getCachedCapability(
            List<SpcTool.Measurement> measurements, 
            SpcTool.SpecificationLimits limits, 
            String cacheKey) {
        
        // 检查缓存
        CachedResult<SpcTool.ProcessCapability> cached = 
            (CachedResult<SpcTool.ProcessCapability>) capabilityCache.get(cacheKey);
        
        if (cached != null && !cached.isExpired()) {
            System.out.println("使用缓存的过程能力结果: " + cacheKey);
            return cached.getResult();
        }
        
        // 计算新的结果
        SpcTool.ProcessCapability capability = SpcTool.calculateCPK(measurements, limits);
        
        // 更新缓存
        if (capability != null) {
            capabilityCache.put(cacheKey, new CachedResult<>(capability, System.currentTimeMillis() + cacheTimeout));
        }
        
        return capability;
    }
    
    public SpcTool.ControlChart getCachedControlChart(
            List<SpcTool.Measurement> measurements, 
            SpcTool.ChartType chartType, 
            String cacheKey) {
        
        // 检查缓存
        CachedResult<SpcTool.ControlChart> cached = 
            (CachedResult<SpcTool.ControlChart>) chartCache.get(cacheKey);
        
        if (cached != null && !cached.isExpired()) {
            System.out.println("使用缓存的控制图: " + cacheKey);
            return cached.getResult();
        }
        
        // 生成新的控制图
        SpcTool.ControlChart chart = SpcTool.generateControlChart(measurements, chartType);
        
        // 更新缓存
        if (chart != null) {
            chartCache.put(cacheKey, new CachedResult<>(chart, System.currentTimeMillis() + cacheTimeout));
        }
        
        return chart;
    }
    
    // 缓存结果内部类
    private static class CachedResult<T> {
        private final T result;
        private final long expireTime;
        
        public CachedResult(T result, long expireTime) {
            this.result = result;
            this.expireTime = expireTime;
        }
        
        public T getResult() { return result; }
        public boolean isExpired() { return System.currentTimeMillis() > expireTime; }
    }
}
```


## 9. 系统集成

### 9.1 与Web服务集成

```java
@RestController
@RequestMapping("/api/spc")
public class SpcController {
    
    @PostMapping("/control-chart")
    public ResponseEntity<?> generateControlChart(@RequestBody ControlChartRequest request) {
        try {
            List<SpcTool.Measurement> measurements = convertToMeasurements(request.getMeasurements());
            SpcTool.ChartType chartType = SpcTool.ChartType.valueOf(request.getChartType());
            
            SpcTool.ControlChart chart = SpcTool.generateControlChart(measurements, chartType);
            
            if (chart != null) {
                return ResponseEntity.ok(convertToResponse(chart));
            } else {
                return ResponseEntity.badRequest().body("控制图生成失败");
            }
        } catch (Exception e) {
            return ResponseEntity.status(500).body("服务器内部错误: " + e.getMessage());
        }
    }
    
    @PostMapping("/capability")
    public ResponseEntity<?> calculateCapability(@RequestBody CapabilityRequest request) {
        try {
            List<SpcTool.Measurement> measurements = convertToMeasurements(request.getMeasurements());
            SpcTool.SpecificationLimits limits = convertToSpecificationLimits(request.getSpecificationLimits());
            
            SpcTool.ProcessCapability capability = SpcTool.calculateCPK(measurements, limits);
            
            if (capability != null) {
                return ResponseEntity.ok(convertToResponse(capability));
            } else {
                return ResponseEntity.badRequest().body("过程能力计算失败");
            }
        } catch (Exception e) {
            return ResponseEntity.status(500).body("服务器内部错误: " + e.getMessage());
        }
    }
    
    @PostMapping("/anomalies")
    public ResponseEntity<?> detectAnomalies(@RequestBody AnomalyDetectionRequest request) {
        try {
            Stream<SpcTool.Measurement> dataStream = convertToMeasurementStream(request.getMeasurements());
            List<SpcTool.QualityAlert> alerts = SpcTool.detectRealTimeAnomalies(dataStream);
            
            return ResponseEntity.ok(convertToResponse(alerts));
        } catch (Exception e) {
            return ResponseEntity.status(500).body("异常检测失败: " + e.getMessage());
        }
    }
    
    // 辅助转换方法
    private List<SpcTool.Measurement> convertToMeasurements(Object measurements) {
        // 实现数据转换逻辑
        return new ArrayList<>();
    }
    
    private SpcTool.SpecificationLimits convertToSpecificationLimits(Object limits) {
        // 实现规格限转换逻辑
        return null;
    }
    
    private Stream<SpcTool.Measurement> convertToMeasurementStream(Object measurements) {
        // 实现数据流转换逻辑
        return Stream.empty();
    }
    
    private Object convertToResponse(SpcTool.ControlChart chart) {
        // 实现控制图响应转换
        return new Object();
    }
    
    private Object convertToResponse(SpcTool.ProcessCapability capability) {
        // 实现过程能力响应转换
        return new Object();
    }
    
    private Object convertToResponse(List<SpcTool.QualityAlert> alerts) {
        // 实现异常响应转换
        return new Object();
    }
}
```


### 9.2 与调度系统集成

```java
@Component
public class ScheduledSpcTasks {
    
    // 每小时生成一次控制图
    @Scheduled(cron = "0 0 * * * ?")
    public void generateHourlyControlCharts() {
        System.out.println("开始生成小时控制图...");
        
        // 获取需要监控的产品列表
        List<String> productIds = getProductIdsToMonitor();
        
        for (String productId : productIds) {
            try {
                // 获取最近一小时的测量数据
                List<SpcTool.Measurement> measurements = getRecentMeasurements(productId, 1);
                
                if (!measurements.isEmpty()) {
                    // 生成控制图
                    SpcTool.ControlChart chart = SpcTool.generateControlChart(
                        measurements, SpcTool.ChartType.X_BAR_R);
                    
                    if (chart != null) {
                        // 保存或发送控制图
                        saveControlChart(chart, productId);
                        System.out.println("产品 " + productId + " 的控制图生成成功");
                    }
                }
            } catch (Exception e) {
                System.err.println("生成产品 " + productId + " 的控制图时发生错误: " + e.getMessage());
            }
        }
    }
    
    // 每天计算一次过程能力
    @Scheduled(cron = "0 0 1 * * ?") // 每天凌晨1点
    public void calculateDailyProcessCapability() {
        System.out.println("开始计算日过程能力...");
        
        List<String> productIds = getProductIdsToMonitor();
        
        for (String productId : productIds) {
            try {
                // 获取最近24小时的测量数据
                List<SpcTool.Measurement> measurements = getRecentMeasurements(productId, 24);
                SpcTool.SpecificationLimits limits = getProductSpecificationLimits(productId);
                
                if (!measurements.isEmpty() && limits != null) {
                    SpcTool.ProcessCapability capability = SpcTool.calculateCPK(measurements, limits);
                    
                    if (capability != null) {
                        // 保存过程能力结果
                        saveProcessCapability(capability, productId);
                        System.out.println("产品 " + productId + " 的过程能力计算成功: Cpk=" + capability.getCpk());
                        
                        // 如果能力不足，发送预警
                        if (capability.getCpk() < 1.33) {
                            sendCapabilityAlert(productId, capability);
                        }
                    }
                }
            } catch (Exception e) {
                System.err.println("计算产品 " + productId + " 的过程能力时发生错误: " + e.getMessage());
            }
        }
    }
    
    // 每5分钟检测实时异常
    @Scheduled(fixedRate = 300000) // 5分钟
    public void detectRealTimeAnomalies() {
        System.out.println("开始检测实时质量异常...");
        
        try {
            // 获取最近5分钟的测量数据流
            Stream<SpcTool.Measurement> dataStream = getRecentMeasurementStream(5);
            
            List<SpcTool.QualityAlert> alerts = SpcTool.detectRealTimeAnomalies(dataStream);
            
            if (!alerts.isEmpty()) {
                System.out.println("检测到 " + alerts.size() + " 个实时异常");
                // 发送异常通知
                sendAnomalyNotifications(alerts);
            }
        } catch (Exception e) {
            System.err.println("实时异常检测失败: " + e.getMessage());
        }
    }
    
    // 辅助方法
    private List<String> getProductIdsToMonitor() {
        // 从配置或数据库获取需要监控的产品列表
        return Arrays.asList("PRODUCT_A", "PRODUCT_B", "PRODUCT_C");
    }
    
    private List<SpcTool.Measurement> getRecentMeasurements(String productId, int hours) {
        // 从数据源获取指定产品和时间范围的测量数据
        return new ArrayList<>();
    }
    
    private SpcTool.SpecificationLimits getProductSpecificationLimits(String productId) {
        // 获取产品的规格限定义
        return new SpcTool.SpecificationLimits(100.0, 90.0, 95.0, "mm");
    }
    
    private void saveControlChart(SpcTool.ControlChart chart, String productId) {
        // 保存控制图到数据库或文件系统
        System.out.println("保存控制图 for " + productId);
    }
    
    private void saveProcessCapability(SpcTool.ProcessCapability capability, String productId) {
        // 保存过程能力结果
        System.out.println("保存过程能力 for " + productId + ": Cpk=" + capability.getCpk());
    }
    
    private void sendCapabilityAlert(String productId, SpcTool.ProcessCapability capability) {
        // 发送过程能力不足的预警
        System.out.println("发送过程能力预警 for " + productId + ": Cpk=" + capability.getCpk());
    }
    
    private Stream<SpcTool.Measurement> getRecentMeasurementStream(int minutes) {
        // 获取实时测量数据流
        return Stream.empty();
    }
    
    private void sendAnomalyNotifications(List<SpcTool.QualityAlert> alerts) {
        // 发送异常通知
        System.out.println("发送 " + alerts.size() + " 个异常通知");
    }
}
```


这个使用说明文档涵盖了 [SpcTool](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\semiconductor\quality\spc\SpcTool.java#L11-L23) 的主要功能和使用方法，可以帮助开发者快速上手并正确使用该SPC工具类。