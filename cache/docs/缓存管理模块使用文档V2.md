## 缓存管理模块使用文档

### 1. 模块概述

这是一个轻量级、高性能的Java缓存管理模块，基于Caffeine实现，支持本地缓存和Redis分布式缓存。模块采用分层设计，提供了灵活的配置选项和多种缓存保护机制。

### 2. 核心组件介绍

#### 2.1 Cache接口
`Cache<K, V>`接口定义了缓存的基本操作规范，包括:
- 基本操作: [get](file://E:\dossier\others\im-framework\cache\src\main\java\org\im\cache\core\Cache.java#L30-L30), [put](file://E:\dossier\others\im-framework\cache\src\main\java\org\im\cache\core\Cache.java#L38-L38), [remove](file://E:\dossier\others\im-framework\cache\src\main\java\org\im\cache\core\Cache.java#L80-L80)
- 批量操作: [getAll](file://E:\dossier\others\im-framework\cache\src\main\java\org\im\cache\core\Cache.java#L65-L65), [putAll](file://E:\dossier\others\im-framework\cache\src\main\java\org\im\cache\core\Cache.java#L72-L72), [removeAll](file://E:\dossier\others\im-framework\cache\src\main\java\org\im\cache\core\Cache.java#L88-L88)
- 过期控制: [put](file://E:\dossier\others\im-framework\cache\src\main\java\org\im\cache\core\Cache.java#L38-L38) (带TTL), [putAtFixedTime](file://E:\dossier\others\im-framework\cache\src\main\java\org\im\cache\core\Cache.java#L57-L57)
- 自动加载: [getOrLoad](file://E:\dossier\others\im-framework\cache\src\main\java\org\im\cache\core\Cache.java#L131-L131)
- 管理操作: [clear](file://E:\dossier\others\im-framework\cache\src\main\java\org\im\cache\core\Cache.java#L108-L108), [size](file://E:\dossier\others\im-framework\cache\src\main\java\org\im\cache\core\Cache.java#L103-L103), [containsKey](file://E:\dossier\others\im-framework\cache\src\main\java\org\im\cache\core\Cache.java#L96-L96)

#### 2.2 CacheManager接口
[CacheManager](file://E:\dossier\others\im-framework\cache\src\main\java\org\im\cache\core\CacheManager.java#L14-L109)负责管理多个缓存实例:
- 创建和获取缓存: [createCache](file://E:\dossier\others\im-framework\cache\src\main\java\org\im\cache\core\CacheManager.java#L24-L24), [getCache](file://E:\dossier\others\im-framework\cache\src\main\java\org\im\cache\core\CacheManager.java#L47-L47), [getOrCreateCache](file://E:\dossier\others\im-framework\cache\src\main\java\org\im\cache\core\CacheManager.java#L58-L58)
- 管理缓存列表: [getCacheNames](file://E:\dossier\others\im-framework\cache\src\main\java\org\im\cache\core\CacheManager.java#L86-L86), [removeCache](file://E:\dossier\others\im-framework\cache\src\main\java\org\im\cache\core\CacheManager.java#L79-L79)
- 统计信息: [getStats](file://E:\dossier\others\im-framework\cache\src\main\java\org\im\cache\core\Cache.java#L115-L115)

#### 2.3 配置类
[CacheConfig](file://E:\dossier\others\im-framework\cache\src\main\java\org\im\cache\config\CacheConfig.java#L15-L505)和[CacheConfigBuilder](file://E:\dossier\others\im-framework\cache\src\main\java\org\im\cache\config\CacheConfigBuilder.java#L16-L170)提供了丰富的配置选项:
- 基础配置: 缓存名称、最大大小、过期策略
- 统计配置: 是否启用统计信息
- 保护机制: 空值保护、击穿保护、雪崩保护

### 3. 快速开始

#### 3.1 创建简单缓存

```java
// 使用默认配置创建缓存
Cache<String, Object> cache = CacheBuilder.newBuilder().build();

// 使用自定义配置创建缓存
Cache<String, Object> customCache = CacheBuilder.newBuilder()
    .cacheName("myCache")
    .maximumSize(1000)
    .expireAfterWrite(30, TimeUnit.MINUTES)
    .recordStats(true)
    .build();
```


#### 3.2 基本操作

```java
// 存储数据
cache.put("key1", "value1");

// 获取数据
String value = cache.get("key1");

// 删除数据
boolean removed = cache.remove("key1");

// 批量操作
Set<String> keys = Set.of("key1", "key2");
Map<String, Object> values = cache.getAll(keys);

Map<String, Object> dataToStore = Map.of("key3", "value3", "key4", "value4");
cache.putAll(dataToStore);
```


### 4. 高级功能使用

#### 4.1 过期策略

```java
// 写入后过期
Cache<String, Object> writeExpireCache = CacheBuilder.newBuilder()
    .expireAfterWrite(30, TimeUnit.MINUTES)
    .build();

// 访问后过期
Cache<String, Object> accessExpireCache = CacheBuilder.newBuilder()
    .expireAfterAccess(10, TimeUnit.MINUTES)
    .build();

// 组合使用
Cache<String, Object> combinedCache = CacheBuilder.newBuilder()
    .expireAfterWrite(30, TimeUnit.MINUTES)
    .expireAfterAccess(10, TimeUnit.MINUTES)
    .build();
```


#### 4.2 自动加载机制

```java
// 使用loader函数自动加载数据
User user = cache.getOrLoad("userId", key -> {
    return loadUserFromDatabase(key);
});
```


#### 4.3 统计信息

```java
// 启用统计
Cache<String, Object> cache = CacheBuilder.newBuilder()
    .recordStats(true)
    .build();

// 获取统计信息
CacheStats stats = cache.getStats();
System.out.println("命中次数: " + stats.hitCount());
System.out.println("未命中次数: " + stats.missCount());
System.out.println("命中率: " + stats.hitRate());
```


### 5. 缓存保护机制

#### 5.1 缓存穿透保护

```java
// 启用空值保护
CacheConfig config = CacheConfigBuilder.newBuilder()
    .nullValueProtection(true)
    .nullValueExpireTime(TimeUnit.MINUTES.toMillis(5))
    .build();
```


#### 5.2 缓存击穿保护

```java
// 启用击穿保护
CacheConfig config = CacheConfigBuilder.newBuilder()
    .breakdownProtection(true)
    .breakdownLockTimeout(TimeUnit.SECONDS.toMillis(30))
    .build();
```


#### 5.3 缓存雪崩保护

```java
// 启用雪崩保护
CacheConfig config = CacheConfigBuilder.newBuilder()
    .avalancheProtection(true)
    .avalancheProtectionWindow(TimeUnit.MINUTES.toMillis(5))
    .build();
```


### 6. 注解驱动缓存

模块提供了声明式缓存支持:

#### 6.1 @Cacheable

```java
@Cacheable(cacheNames = "users", key = "#userId")
public User getUserById(String userId) {
    return userRepository.findById(userId);
}
```


#### 6.2 @CachePut

```java
@CachePut(cacheNames = "users", key = "#user.id")
public User updateUser(User user) {
    return userRepository.save(user);
}
```


#### 6.3 @CacheEvict

```java
@CacheEvict(cacheNames = "users", key = "#userId")
public void deleteUser(String userId) {
    userRepository.deleteById(userId);
}

@CacheEvict(cacheNames = "users", allEntries = true)
public void clearAllUsers() {
    // 清除所有用户缓存
}
```


## 最佳实践指南

### 1. 缓存设计原则

#### 1.1 合理设置缓存大小
```java
// 根据应用内存情况合理设置最大缓存大小
Cache<String, Object> cache = CacheBuilder.newBuilder()
    .maximumSize(10000)  // 避免OOM
    .build();
```


#### 1.2 选择合适的过期策略
```java
// 对于相对静态数据使用写入后过期
Cache<String, Config> configCache = CacheBuilder.newBuilder()
    .expireAfterWrite(1, TimeUnit.HOURS)
    .build();

// 对于访问模式不确定的数据使用访问后过期
Cache<String, Session> sessionCache = CacheBuilder.newBuilder()
    .expireAfterAccess(30, TimeUnit.MINUTES)
    .build();
```


### 2. 键的设计

```java
// 确保键的唯一性和一致性
public class UserKeyGenerator implements CacheKeyGenerator {
    @Override
    public Object generate(Object target, Method method, Object... params) {
        // 生成稳定、唯一的键
        return "user:" + params[0];  // 假设第一个参数是userId
    }
}
```


### 3. 异常处理

```java
// 缓存操作应该有完善的异常处理机制
try {
    return cache.get(key);
} catch (Exception e) {
    logger.warn("Cache get failed for key: {}", key, e);
    // 降级到直接访问数据源
    return loadFromDataSource(key);
}
```


### 4. 资源管理

```java
// 应用关闭时及时释放缓存资源
@Override
public void destroy() {
    if (cache != null) {
        cache.close();
    }
}

// 或使用ShutdownHook
Runtime.getRuntime().addShutdownHook(new Thread(() -> {
    if (cache != null) {
        cache.close();
    }
}));
```


### 5. 混合缓存模式（L1+L2）

```java
public class HybridCache<K, V> implements Cache<K, V> {
    private final Cache<K, V> localCache;  // 本地缓存(L1)
    private final RedisCache<K, V> remoteCache; // Redis缓存(L2)
    
    @Override
    public V get(K key) {
        // 先查本地缓存
        V value = localCache.get(key);
        if (value != null) {
            return value;
        }
        
        // 本地未命中，查远程缓存
        value = remoteCache.get(key);
        if (value != null) {
            // 回填本地缓存
            localCache.put(key, value);
        }
        
        return value;
    }
    
    @Override
    public void put(K key, V value) {
        localCache.put(key, value);
        remoteCache.put(key, value);
    }
}
```


### 6. 监控与调优

```java
// 定期输出缓存统计信息
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
scheduler.scheduleAtFixedRate(() -> {
    CacheStats stats = cache.getStats();
    logger.info("Cache stats - Hit rate: {}, Miss count: {}, Load success count: {}",
                stats.hitRate(), stats.missCount(), stats.loadSuccessCount());
}, 0, 1, TimeUnit.MINUTES);
```


### 7. 适用场景推荐

#### 7.1 推荐使用场景
1. **单体应用性能优化**: 提升应用响应速度
2. **热点数据缓存**: 缓存频繁访问的数据
3. **计算结果缓存**: 缓存复杂计算的结果
4. **数据库查询缓存**: 减少数据库访问压力
5. **会话数据缓存**: 缓存用户会话信息

#### 7.2 不推荐使用场景
1. **大规模分布式系统**: 需要跨节点数据共享
2. **海量数据缓存**: 数据量超过单机内存容量
3. **持久化需求**: 需要缓存数据持久化
4. **复杂数据结构**: 需要List、Set等复杂数据结构

通过遵循以上最佳实践，您可以充分发挥该缓存管理模块的优势，在保证性能的同时提高系统的稳定性和可维护性。