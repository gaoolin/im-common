# QTech 缓存管理体系使用手册

## 1. 简介

QTech 缓存管理体系是一套完整、专业、高性能的缓存解决方案，基于 Caffeine 缓存库构建，提供了本地缓存和分布式缓存的支持。该体系具有以下特点：

- **通用化**：支持多种缓存实现（本地缓存、Redis等）
- **规范化**：统一的缓存操作接口
- **灵活性**：可配置的缓存策略和参数
- **容错性**：具备缓存穿透、击穿、雪崩防护
- **专业性**：提供监控、统计、日志等专业功能
- **复用性**：可在不同项目中复用
- **解耦性**：与业务代码解耦

## 2. 核心组件

### 2.1 Cache 接口
缓存操作的核心接口，定义了缓存的基本操作方法。

### 2.2 CacheConfig 类
缓存配置类，用于配置缓存的各种参数。

### 2.3 CacheManager 接口
缓存管理器接口，负责缓存实例的创建、管理和销毁。

### 2.4 缓存注解
提供声明式缓存支持，包括 [@Cacheable](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\cache\annotation\Cacheable.java#L26-L80)、[@CachePut](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\cache\annotation\CachePut.java#L16-L63)、[@CacheEvict](file://E:\dossier\others\im-common\src\main\java\com\qtech\im\cache\annotation\CacheEvict.java#L15-L55)。

## 3. 快速开始

### 3.1 添加依赖

在 [pom.xml](file://E:\dossier\others\im-common\pom.xml) 中添加必要的依赖：

```xml
<dependencies>
    <!-- QTech 缓存管理库 -->
    <dependency>
        <groupId>com.qtech</groupId>
        <artifactId>im-common</artifactId>
        <version>1.0.0</version>
    </dependency>
    
    <!-- Caffeine 缓存库 -->
    <dependency>
        <groupId>com.github.ben-manes.caffeine</groupId>
        <artifactId>caffeine</artifactId>
        <version>3.1.8</version>
    </dependency>
</dependencies>
```


### 3.2 基本使用

```java
import com.qtech.im.cache.Cache;
import com.qtech.im.cache.CacheConfig;
import com.qtech.im.cache.CacheManager;
import com.qtech.im.cache.impl.LocalCacheManager;

// 创建缓存管理器
CacheManager cacheManager = new LocalCacheManager();

// 创建缓存配置
CacheConfig config = new CacheConfig("userCache");
config.setMaximumSize(1000);
config.setExpireAfterWrite(30, TimeUnit.MINUTES);

// 创建缓存实例
Cache<String, User> userCache = cacheManager.createCache("userCache", config);

// 使用缓存
String userId = "12345";
User user = userCache.get(userId);
if (user == null) {
    // 从数据库加载用户
    user = loadUserFromDatabase(userId);
    if (user != null) {
        userCache.put(userId, user);
    }
}

// 关闭缓存管理器
cacheManager.close();
```


## 4. 缓存配置

### 4.1 CacheConfig 配置项

```java
CacheConfig config = new CacheConfig();
config.setName("exampleCache");                           // 缓存名称
config.setMaximumSize(10000);                             // 最大缓存项数
config.setExpireAfterWrite(30, TimeUnit.MINUTES);         // 写入后30分钟过期
config.setExpireAfterAccess(10, TimeUnit.MINUTES);        // 访问后10分钟过期
config.setRecordStats(true);                              // 启用统计
config.setEnableNullValueProtection(true);                // 启用空值保护
config.setEnableBreakdownProtection(true);                // 启用击穿保护
config.setEnableAvalancheProtection(true);                // 启用雪崩保护
```


### 4.2 缓存类型配置

```java
// 本地缓存配置
CacheConfig localConfig = new CacheConfig("localCache");
localConfig.setCacheType(CacheConfig.CacheType.LOCAL);

// 分布式缓存配置（需要额外的分布式缓存实现）
CacheConfig distributedConfig = new CacheConfig("distributedCache");
distributedConfig.setCacheType(CacheConfig.CacheType.DISTRIBUTED);
```


## 5. 缓存操作

### 5.1 基本操作

```java
// 获取缓存值
User user = userCache.get("userId");

// 设置缓存值
userCache.put("userId", user);

// 设置带过期时间的缓存值
userCache.put("userId", user, 1, TimeUnit.HOURS);

// 删除缓存项
boolean removed = userCache.remove("userId");

// 判断缓存项是否存在
boolean exists = userCache.containsKey("userId");

// 获取缓存大小
long size = userCache.size();

// 清空缓存
userCache.clear();
```


### 5.2 批量操作

```java
// 批量获取
Set<String> userIds = Set.of("user1", "user2", "user3");
Map<String, User> users = userCache.getAll(userIds);

// 批量设置
Map<String, User> userMap = new HashMap<>();
userMap.put("user1", user1);
userMap.put("user2", user2);
userCache.putAll(userMap);

// 批量删除
Set<String> keysToRemove = Set.of("user1", "user2");
int removedCount = userCache.removeAll(keysToRemove);
```


### 5.3 自动加载机制

```java
// 获取或加载（如果缓存中不存在则自动加载）
User user = userCache.getOrLoad("userId", this::loadUserFromDatabase);

// 获取或加载（指定过期时间）
User user = userCache.getOrLoad("userId", this::loadUserFromDatabase, 1, TimeUnit.HOURS);
```


## 6. 缓存统计和监控

### 6.1 缓存统计信息

```java
// 获取缓存统计信息
com.qtech.im.cache.CacheStats stats = userCache.getStats();
System.out.println("请求总数: " + stats.getRequestCount());
System.out.println("命中次数: " + stats.getHitCount());
System.out.println("未命中次数: " + stats.getMissCount());
System.out.println("命中率: " + String.format("%.2f%%", stats.getHitRate() * 100));
System.out.println("平均加载时间: " + stats.getAverageLoadTime() + "ms");
```


### 6.2 缓存管理器统计

```java
// 获取缓存管理器统计信息
CacheManagerStats managerStats = cacheManager.getStats();
System.out.println("缓存实例数量: " + managerStats.getCacheCount());
System.out.println("运行时间: " + managerStats.getUptime() + "ms");
```


## 7. 缓存注解支持

### 7.1 @Cacheable 注解

```java
import com.qtech.im.cache.annotation.Cacheable;

@Service
public class UserService {
    
    @Cacheable(cacheName = "userCache", key = "#userId")
    public User getUserById(String userId) {
        // 模拟从数据库加载用户
        return loadUserFromDatabase(userId);
    }
    
    @Cacheable(cacheName = "userListCache", key = "#departmentId")
    public List<User> getUsersByDepartment(String departmentId) {
        // 模拟从数据库加载部门用户列表
        return loadUsersFromDatabase(departmentId);
    }
}
```


### 7.2 @CachePut 注解

```java
import com.qtech.im.cache.annotation.CachePut;

@Service
public class UserService {
    
    @CachePut(cacheName = "userCache", key = "#user.id")
    public User updateUser(User user) {
        // 更新数据库中的用户
        saveUserToDatabase(user);
        return user;
    }
}
```


### 7.3 @CacheEvict 注解

```java
import com.qtech.im.cache.annotation.CacheEvict;

@Service
public class UserService {
    
    @CacheEvict(cacheName = "userCache", key = "#userId")
    public void deleteUser(String userId) {
        // 从数据库删除用户
        deleteUserFromDatabase(userId);
    }
    
    @CacheEvict(cacheName = "userCache", allEntries = true)
    public void clearAllUsers() {
        // 清除所有用户缓存
        clearUserDatabase();
    }
}
```


### 7.4 自定义键生成器

```java
import com.qtech.im.cache.annotation.CacheKeyGenerator;

public class CustomKeyGenerator implements CacheKeyGenerator {
    
    @Override
    public Object generate(Object target, Method method, Object... params) {
        // 自定义键生成逻辑
        return "custom:" + method.getName() + ":" + Arrays.toString(params);
    }
}

// 在注解中使用自定义键生成器
@Cacheable(cacheName = "customCache", keyGenerator = CustomKeyGenerator.class)
public String getCustomData(String param) {
    return "data:" + param;
}
```


## 8. 缓存管理器

### 8.1 本地缓存管理器

```java
import com.qtech.im.cache.CacheManager;
import com.qtech.im.cache.impl.LocalCacheManager;

// 创建本地缓存管理器
CacheManager cacheManager = new LocalCacheManager();

// 获取缓存实例
Cache<String, User> userCache = cacheManager.getCache("userCache");

// 获取或创建缓存实例
Cache<String, User> userCache = cacheManager.getOrCreateCache("userCache", config);

// 获取所有缓存名称
String[] cacheNames = cacheManager.getCacheNames();

// 删除缓存实例
boolean removed = cacheManager.removeCache("userCache");
```


### 8.2 缓存生命周期管理

```java
// 在应用关闭时关闭缓存管理器
Runtime.getRuntime().addShutdownHook(new Thread(() -> {
    cacheManager.close();
}));
```


## 9. 高级特性

### 9.1 缓存穿透防护

```java
// 启用空值保护
CacheConfig config = new CacheConfig("protectedCache");
config.setEnableNullValueProtection(true);
config.setNullValueExpireTime(TimeUnit.MINUTES.toMillis(1)); // 空值1分钟后过期
```


### 9.2 缓存击穿防护

```java
// 启用击穿保护
CacheConfig config = new CacheConfig("protectedCache");
config.setEnableBreakdownProtection(true);
config.setBreakdownLockTimeout(TimeUnit.SECONDS.toMillis(10)); // 锁超时10秒
```


### 9.3 缓存雪崩防护

```java
// 启用雪崩保护
CacheConfig config = new CacheConfig("protectedCache");
config.setEnableAvalancheProtection(true);
config.setAvalancheProtectionRange(TimeUnit.MINUTES.toMillis(5)); // 5分钟随机范围
```


## 10. 使用示例

### 10.1 完整使用示例

```java
import com.qtech.im.cache.Cache;
import com.qtech.im.cache.CacheConfig;
import com.qtech.im.cache.CacheManager;
import com.qtech.im.cache.impl.LocalCacheManager;
import com.qtech.im.cache.annotation.Cacheable;
import com.qtech.im.cache.annotation.CachePut;
import com.qtech.im.cache.annotation.CacheEvict;

@Service
public class UserService {
    private final Cache<String, User> userCache;
    
    public UserService(CacheManager cacheManager) {
        CacheConfig config = new CacheConfig("userCache");
        config.setMaximumSize(10000);
        config.setExpireAfterWrite(30, TimeUnit.MINUTES);
        this.userCache = cacheManager.createCache("userCache", config);
    }
    
    @Cacheable(cacheName = "userCache", key = "#userId")
    public User getUserById(String userId) {
        System.out.println("从数据库加载用户: " + userId);
        return loadUserFromDatabase(userId);
    }
    
    @CachePut(cacheName = "userCache", key = "#user.id")
    public User updateUser(User user) {
        System.out.println("更新用户: " + user.getId());
        saveUserToDatabase(user);
        return user;
    }
    
    @CacheEvict(cacheName = "userCache", key = "#userId")
    public void deleteUser(String userId) {
        System.out.println("删除用户: " + userId);
        deleteUserFromDatabase(userId);
    }
    
    private User loadUserFromDatabase(String userId) {
        // 模拟数据库查询
        return new User(userId, "User " + userId);
    }
    
    private void saveUserToDatabase(User user) {
        // 模拟数据库保存
    }
    
    private void deleteUserFromDatabase(String userId) {
        // 模拟数据库删除
    }
}

// 测试类
public class CacheTest {
    public static void main(String[] args) {
        CacheManager cacheManager = new LocalCacheManager();
        UserService userService = new UserService(cacheManager);
        
        // 第一次调用，从数据库加载
        User user1 = userService.getUserById("123");
        
        // 第二次调用，从缓存获取
        User user2 = userService.getUserById("123");
        
        // 更新用户，同时更新缓存
        User updatedUser = new User("123", "Updated User");
        userService.updateUser(updatedUser);
        
        // 删除用户，同时清除缓存
        userService.deleteUser("123");
        
        cacheManager.close();
    }
}
```


### 10.2 缓存监控示例

```java
public class CacheMonitor {
    private final CacheManager cacheManager;
    
    public void printCacheStats() {
        String[] cacheNames = cacheManager.getCacheNames();
        for (String cacheName : cacheNames) {
            Cache<?, ?> cache = cacheManager.getCache(cacheName);
            if (cache != null) {
                com.qtech.im.cache.CacheStats stats = cache.getStats();
                System.out.println("缓存名称: " + cacheName);
                System.out.println("  命中率: " + String.format("%.2f%%", stats.getHitRate() * 100));
                System.out.println("  请求总数: " + stats.getRequestCount());
                System.out.println("  命中次数: " + stats.getHitCount());
                System.out.println("  未命中次数: " + stats.getMissCount());
                System.out.println("  平均加载时间: " + String.format("%.2fms", stats.getAverageLoadTime()));
            }
        }
    }
}
```


## 11. 最佳实践

### 11.1 缓存设计原则

1. **合理设置缓存大小**：根据系统内存和数据访问模式设置合适的缓存大小
2. **选择合适的过期策略**：根据数据更新频率选择写入后过期或访问后过期
3. **启用统计监控**：通过统计信息优化缓存配置
4. **处理缓存穿透**：对空值也进行缓存，防止恶意攻击
5. **防止缓存击穿**：使用分布式锁或互斥机制
6. **避免缓存雪崩**：设置随机过期时间

### 11.2 性能优化建议

1. **预热缓存**：系统启动时预加载热点数据
2. **批量操作**：尽量使用批量获取和设置操作
3. **合理使用注解**：避免在复杂业务逻辑中滥用缓存注解
4. **监控缓存命中率**：定期检查缓存效果并调整配置

### 11.3 安全考虑

1. **敏感数据加密**：缓存敏感数据时进行加密处理
2. **访问控制**：限制对缓存管理接口的访问权限
3. **日志记录**：记录缓存操作日志用于审计

## 12. 故障排除

### 12.1 常见问题

1. **缓存未生效**：检查缓存键是否正确生成
2. **内存溢出**：检查缓存大小限制是否合理
3. **性能问题**：检查缓存配置和使用方式
4. **数据不一致**：检查缓存更新和清除逻辑

### 12.2 调试技巧

1. **启用统计信息**：通过统计信息分析缓存效果
2. **日志记录**：记录缓存操作日志
3. **监控工具**：使用缓存监控工具

## 13. 扩展功能

### 13.1 集成Spring

```java
@Configuration
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        return new LocalCacheManager();
    }
    
    @Bean
    public Cache<String, User> userCache(CacheManager cacheManager) {
        CacheConfig config = new CacheConfig("userCache");
        config.setMaximumSize(10000);
        return cacheManager.createCache("userCache", config);
    }
}
```


### 13.2 Redis分布式缓存扩展

```java
// 可以实现RedisCache来支持分布式缓存
public class RedisCache<K, V> implements Cache<K, V> {
    // Redis缓存实现...
}
```


## 14. 联系方式

如有问题或建议，请联系开发团队或提交 issue。